---
id: 68d275dd800f404d22a07564
title: 实现深度优先搜索算法
challengeType: 27
dashedName: lab-depth-first-search
---

# --description--

在这个实验中，你将实现一个称为<dfn>深度优先搜索</dfn>的图遍历算法。

与<dfn>广度优先搜索</dfn>从源节点开始搜索增量边长度不同，<dfn>深度优先搜索</dfn>首先沿着一条路径的边尽可能深入。

一旦到达路径的一端，搜索将回溯到最后一个有未访问边路径的节点并继续搜索。

与广度优先搜索不同，每次访问节点时，它不会访问所有邻居节点。相反，它首先访问其中一个邻居节点，并沿着该路径继续前进，直到该路径上没有更多节点可以访问。

为了实现这个算法，你需要使用一个栈（一个后进先出的数组，遵循<dfn>后进先出</dfn>原则）。栈在深度优先搜索算法中很有帮助，因为当你将邻居节点添加到栈中时，你希望首先访问最近添加的邻居节点并从栈中移除它们。

这个算法的一个简单输出是从给定节点可以到达的节点列表。因此，你也需要跟踪你访问过的节点。

**目标**：实现以下用户需求并通过所有测试以完成实验。

**用户需求：**

1. 你应该有一个名为 `dfs` 的函数。
1. `dfs` 函数应该接受两个参数：
   - 一个无向邻接矩阵。
   - 一个节点标签，它是 `0` 到 `n - 1` 之间的节点数值，其中 `n` 是图中节点的总数。
1. `dfs` 函数应该实现深度优先搜索算法，输出从传递给它的节点可以到达的所有节点的列表。

# --hints--

你应该有一个名为 `dfs` 的函数，它接受两个参数。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs)
  sig = inspect.signature(dfs)
  assert len(sig.parameters) == 2
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1)` 应该返回 `[1, 2, 3, 0]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 1) == [1, 2, 3, 0]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3)` 应该返回 `[3, 2, 1, 0]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]], 3) == [3, 2, 1, 0]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3)` 应该返回 `[3]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]], 3) == [3]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3)` 应该返回 `[3, 2]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 3) == [3, 2]
`) })
```

`dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0)` 应该返回 `[0, 1]`。

```js
({ test: () => runPython(`
  assert dfs([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]], 0) == [0, 1]
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs(graph, root):
    stack = []
    temp_v = None
    visited = []
    temp_v_neighbors = []
    stack.append(root)
    while stack:
        temp_v = stack.pop()
        if temp_v not in visited:
            visited.append(temp_v)
            temp_v_neighbors = graph[temp_v]
            for n, is_neighbor in enumerate(temp_v_neighbors):
                if is_neighbor == 1:
                    stack.append(n)
    return visited
```