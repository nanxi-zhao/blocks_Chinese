---
id: 68cabc534d2e741f33a3fe1d
title: 构建游戏角色属性追踪器
challengeType: 27
dashedName: lab-game-character-stats
---

# --description--

在这个实验中，你将构建一个游戏角色属性追踪器。该程序将允许你创建具有特定属性的角色，更新这些属性，并检索角色的当前属性。

**目标：** 完成以下用户故事并让所有测试通过以完成实验。

**用户故事：**

1. 创建一个名为`GameCharacter`的类，该类代表游戏角色并管理角色属性。
2. 实例化时，新的`GameCharacter`对象应该具有以下属性：
    - `_name`设置为实例化时刻给定的字符串。
    - `_health`设置为`100`。
    - `_mana`设置为`50`。
    - `_level`设置为`1`。
3. 为角色名称创建一个只读访问的`name`属性。
4. 对于`health`属性：
     - 定义一个getter，返回当前健康值。
     - 定义一个setter，防止健康值设置低于`0`，并将健康值上限设为`100`。
5. 对于`mana`属性：
     - 定义一个getter，返回当前魔法值。
     - 定义一个setter，防止魔法值设置低于`0`，并将魔法值上限设为`50`。
6. 为`level`创建一个getter，返回角色的当前等级。
7. 定义一个名为`level_up`的方法，该方法：
    - 将角色等级增加1。
    - 使用相应的属性setter将健康值重置为`100`，魔法值重置为`50`。
    - 打印形式为`<name> leveled up to <level>!`的消息（其中`<name>`和`<level>`应分别替换为角色名称和新等级）。
8. 定义一个`__str__`方法，返回包含以下内容的格式化字符串：
    - 角色名称。
    - 角色等级。
    - 角色当前健康值。
    - 角色当前魔法值。
   例如，一个名为`Kratos`的角色，在实例化后，应表示为以下形式：

   ```md
    Name: Kratos
    Level: 1
    Health: 100
    Mana: 50
   ```

## 使用示例

```python
hero = GameCharacter('Kratos') # 创建一个名为Kratos的新角色
print(hero)  # 显示角色属性

hero.health -= 30  # 减少30点健康值
hero.mana -= 10    # 减少10点魔法值
print(hero)  # 显示更新后的属性

hero.level_up()  # 角色升级
print(hero)  # 显示升级后的属性
```

# --hints--

你应该有一个`GameCharacter`类。

```js
({ test: () => assert(runPython(`_Node(_code).has_class("GameCharacter")`)) })
```

你应该在`GameCharacter`类中有一个`__init__`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__init__")`) 
})
```

`__init__`方法应该有两个参数，第一个是`self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.__init__).parameters)
    assert params[0] == "self"
    assert len(params) == 2
    `) 
})
```

你应该将`self._name`设置为实例化时刻给定的字符串。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._name == "Kratos"
    `) 
})
```

你应该将`self._health`赋值为`100`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._health == 100
    `) 
})
```

你应该将`self._mana`赋值为`50`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._mana == 50
    `) 
})
```

你应该将`self._level`赋值为`1`。

```js
({ 
    test: () => runPython(`
    character = GameCharacter("Kratos")
    assert character._level == 1
    `) 
})
```

你应该在`GameCharacter`类中有一个`name`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("name")`) 
})
```

`name`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_args("self")`) 
})
```

你应该在`name`方法中返回`self._name`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_return("self._name")`)
})
```

`name`方法应该有一个`@property`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("name").has_decorators("property")`) 
})
```

你应该在`GameCharacter`类中有一个`health`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("health")`) 
})
```

`health`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_args("self")`) 
})
```

你应该在`health`方法中返回`self._health`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_return("self._health")`)
})
```

`health`方法应该有一个`@property`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("health").has_decorators("property")`) 
})
```

你应该创建一个`health` setter方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1]`) 
})
```

`health` setter方法应该有一个`@health.setter`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("health")[1].has_decorators("health.setter")`) 
})
```

`health` setter方法应该有两个参数，第一个是`self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.health.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果给`health` setter的值小于`0`，你应该将`self._health`设置为`0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = -1
    assert char.health == 0
    char.health = -10
    assert char.health == 0
`)})
```

如果给`health` setter的值大于`100`，你应该将`self._health`设置为`100`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 101
    assert char.health == 100
    char.health = 200
    assert char.health == 100
`)})
```

当值在`0`和`100`之间时，你应该将`self._health`设置为给`health` setter的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.health = 95
    assert char.health == 95
    char.health = 1
    assert char.health == 1
`)})
```

你应该在`GameCharacter`类中有一个`mana`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("mana")`) 
})
```

`mana`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_args("self")`) 
})
```

你应该在`mana`方法中返回`self._mana`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_return("self._mana")`)
})
```

`mana`方法应该有一个`@property`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("mana").has_decorators("property")`) 
})
```

你应该创建一个`mana` setter方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1]`) 
})
```

`mana` setter方法应该有一个`@mana.setter`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_functions("mana")[1].has_decorators("mana.setter")`) 
})
```

`mana` setter方法应该有两个参数，第一个是`self`。

```js
({ 
    test: () => runPython(`
    import inspect
    params = list(inspect.signature(GameCharacter.mana.fset).parameters)
    assert params[0] == "self"
    assert len(params) == 2`) 
})
```

如果给`mana` setter的值小于`0`，你应该将`self._mana`设置为`0`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = -1
    assert char.mana == 0
    char.mana = -10
    assert char.mana == 0
`)})
```

如果给`mana` setter的值大于`50`，你应该将`self._mana`设置为`50`。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 51
    assert char.mana == 50
    char.mana = 100
    assert char.mana == 50
`)})
```

如果值在`0`和`50`之间，你应该将`self._mana`设置为给`mana` setter的值。

```js
({ 
    test: () => runPython(`
    char = GameCharacter("test")
    char.mana = 25
    assert char.mana == 25
    char.mana = 0
    assert char.mana == 0
    char.mana = 50
    assert char.mana == 50
`)})
```

你应该在`GameCharacter`类中有一个`level`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level")`) 
})
```

`level`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_args("self")`) 
})
```

你应该在`level`方法中返回`self._level`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_return("self._level")`)
})
```

`level`方法应该有一个`@property`装饰器。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level").has_decorators("property")`) 
})
```

你应该在`GameCharacter`类中有一个`level_up`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("level_up")`) 
})
```

`level_up`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_args("self")`) 
})
```

你应该在`level_up`方法中将`self._level`增加`1`。

```js
({ 
  test: () => runPython(`
    node = _Node(_code).find_class("GameCharacter").find_function("level_up")
    assert (
        node.has_stmt("self._level += 1") or
        node.has_stmt("self._level = self._level + 1")
    )
`)
})
```

你应该在`level_up`方法中将`self.health`设置为`100`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.health = 100")`) 
})
```

你应该在`level_up`方法中将`self.mana`设置为`50`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("level_up").has_stmt("self.mana = 50")`) 
})
```

`level_up`方法应该打印`<name> leveled up to <level>!`（其中`<name>`和`<level>`应分别替换为角色名称和新等级）。

```js
({
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.level_up()
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
            
    assert "test leveled up to 2!" in output
`)
})
```

你应该在`GameCharacter`类中有一个`__str__`方法。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").has_function("__str__")`) 
})
```

`__str__`方法应该只有一个参数`self`。

```js
({ 
    test: () => runPython(`assert _Node(_code).find_class("GameCharacter").find_function("__str__").has_args("self")`) 
})
```

你的`__str__`方法应该使用提供的格式返回包含角色属性的字符串。

```js
({ 
  test: () => runPython(`
    import io
    import sys
            
    captured_output = io.StringIO()
    sys.stdout = captured_output
            
    gc = GameCharacter("test")
    gc.mana = 15
    gc.health = 77
    print(gc)
            
    sys.stdout = sys.__stdout__
    output = captured_output.getvalue()
    expected = """Name: test
    Level: 1
    Health: 77
    Mana: 15"""
    assert expected in output
`)
})
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
class GameCharacter:
    def __init__(self, name):
        self._name = name
        self._health = 100
        self._mana = 50
        self._level = 1

    @property
    def name(self):
        return self._name

    @property
    def health(self):
        return self._health

    @health.setter
    def health(self, value):
        if value < 0:
            self._health = 0
        elif value > 100:
            self._health = 100
        else:
            self._health = value

    @property
    def mana(self):
        return self._mana

    @mana.setter
    def mana(self, value):
        if value < 0:
            self._mana = 0
        elif value > 50:
            self._mana = 50
        else:
            self._mana = value

    @property
    def level(self):
        return self._level

    def level_up(self):
        self._level += 1
        self.health = 100
        self.mana = 50
        print(f"{self._name} leveled up to {self._level}!")

    def __str__(self):
        return (
            f"Name: {self._name}\n"
            f"Level: {self._level}\n"
            f"Health: {self._health}\n"
            f"Mana: {self._mana}"
        )
```