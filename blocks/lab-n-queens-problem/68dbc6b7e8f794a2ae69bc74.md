---
id: 68dbc6b7e8f794a2ae69bc74
title: 实现N皇后算法
challengeType: 27
dashedName: step-1
---

# --description--

N皇后问题要求你在N×N的棋盘上放置N个皇后，使得没有两个皇后相互攻击（没有两个皇后共享行、列或对角线）。

例如，如果有一个4x4的棋盘，一个有效的排列是：

```md
[1, 3, 0, 2]
```

这意味着在第0行，皇后放置在第1列；在第1行，皇后放置在第3列；在第2行，皇后放置在第0列；在第3行，皇后放置在第2列。

直观地看，这种排列看起来像：

```md
. Q . .
. . . Q
Q . . .
. . Q .
```

其中`Q`代表皇后，`.`代表空方格。

在这个实验中，你将使用深度优先搜索方法实现N皇后问题求解器。


**目标**：完成以下用户故事并让所有测试通过以完成实验。

**用户故事：**

1. 你应该有一个名为`dfs_n_queens`的函数。
2. 该函数应该恰好接受一个参数：一个整数`n`。
3. 如果`n`小于`1`，函数应该返回一个空列表（`[]`）。
4. 函数应该返回一个解决方案列表；每个解决方案本身是一个长度为`n`的列表，其中索引`i`处的元素是第`i`行中皇后的列索引（从0开始）。

# --hints--

你应该有一个名为`dfs_n_queens`的函数，该函数接受一个参数。

```js
({ test: () => runPython(`
  import inspect
  assert inspect.isfunction(dfs_n_queens)
  sig = inspect.signature(dfs_n_queens)
  assert len(sig.parameters) == 1
`) })
```

如果`n`小于`1`，函数应该返回一个空列表。

```js
({ test: () => runPython(`
  assert dfs_n_queens(0) == []
  assert dfs_n_queens(-1) == []
  assert dfs_n_queens(-5) == []
`) })
```

函数应该返回一个解决方案列表，其中每个解决方案是一个长度为`n`的列表。

```js
({ test: () => runPython(`
  result = dfs_n_queens(4)
  assert isinstance(result, list)
  for solution in result:
    assert isinstance(solution, list)
    assert len(solution) == 4
`) })
```

`dfs_n_queens(1)`应该返回`[[0]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(1) == [[0]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(2)`应该返回`[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(2) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(3)`应该返回`[]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(3) == []
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(4)`应该返回`[[1, 3, 0, 2], [2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(4) == [[1, 3, 0, 2], [2, 0, 3, 1]]
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
`) })
```

`dfs_n_queens(5)`应该返回`[[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]`。

```js
({ test: () => runPython(`
  assert dfs_n_queens(5) == [[0, 2, 4, 1, 3], [0, 3, 1, 4, 2], [1, 3, 0, 2, 4], [1, 4, 2, 0, 3], [2, 0, 3, 1, 4], [2, 4, 1, 3, 0], [3, 0, 2, 4, 1], [3, 1, 4, 2, 0], [4, 1, 3, 0, 2], [4, 2, 0, 3, 1]]
  assert dfs_n_queens(3) == []
`) })
```

`len(dfs_n_queens(5))`应该是`10`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(5)) == 10
  assert len(dfs_n_queens(6)) == 4
`) })
```

`len(dfs_n_queens(8))`应该是`92`。

```js
({ test: () => runPython(`
  assert len(dfs_n_queens(8)) == 92
  assert len(dfs_n_queens(5)) == 10

`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
def dfs_n_queens(n):
    if n < 1:
        return []

    results = []

    def is_safe(queens, row, col):
        for r, c in enumerate(queens):
            if c == col or abs(row - r) == abs(col - c):
                return False
        return True

    def dfs(queens):
        row = len(queens)
        if row == n:
            results.append(queens[:])
            return
        for col in range(n):
            if is_safe(queens, row, col):
                queens.append(col)
                dfs(queens)
                queens.pop()

    dfs([])
    return results
```