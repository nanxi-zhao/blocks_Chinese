---
id: 68e2c945cc1d8e778152be31
title: 构建玩家界面
challengeType: 27
dashedName: build-a-player-interface
---

# --description--

**目标：** 完成以下用户故事并让所有测试通过以完成实验。

**用户故事：**

1. 你应该定义一个名为`Player`的抽象类，该类继承自`abc.ABC`类。
1. `Player`类应该有一个`__init__`方法，该方法设置：
   - `moves`属性为空列表。
   - `position`属性为`(0, 0)`。
   - `path`属性为包含初始位置的列表。
1. `Player`类应该有一个名为`make_move`的方法，该方法：
   - 使用`random.choice`从`moves`属性（在具体类中定义）获取随机移动。
   - 将所选移动的值添加到当前位置并更新`position`属性。
   - 将新的`position`元组追加到`path`属性。
   - 返回新的`position`。
1. `Player`类应该有一个名为`level_up`的抽象方法，将在具体类中实现。
1. 你应该定义一个继承自`Player`类的`Pawn`类。
1. `Pawn`类应该使用`super()`调用父类的`__init__`方法，然后将`moves`属性设置为表示`x, y`坐标的元组列表。
1. 每个坐标元组应该表示以下方向的`1`单位移动：上、下、左、右。
1. `Pawn`类应该通过向`moves`属性添加更多移动来实现具体的`level_up`方法。添加的移动应该表示四种对角线移动（例如，`1`单位向下加`1`单位向左）。

**注意：** 应该不使用别名导入标准库模块。在`Pawn`类变得可实例化之前，与`Player`类相关的测试将失败。

# --hints--

你应该有一个名为`Player`的类。

```js
({ test: () => runPython(`assert _Node(_code).has_class("Player")`) })
```

`Player`类应该继承自`abc`模块的`ABC`类。

```js
({ test: () => runPython(`
from abc import ABC
import ast
cls = _Node(_code).find_class("Player")
assert cls.inherits_from("ABC") or cls.inherits_from("abc.ABC")
`) })
```

`Player`类应该有一个`__init__`方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("__init__")`) })
```

`Player`的`__init__`方法应该有一个参数`self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("__init__").has_args("self")`) })
```

`Player`的`__init__`方法应该将`self.moves`设置为空列表。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.moves = []") or init.has_stmt("self.moves = list()")
`) })
```

`Player`的`__init__`方法应该将`self.position`设置为`(0, 0)`。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.position = (0, 0)")
`) })
```

`Player`的`__init__`方法应该将`self.path`设置为包含初始位置的列表。

```js
({ test: () => runPython(`
init = _Node(_code).find_class("Player").find_function("__init__")
assert init.has_stmt("self.path = [self.position]")
`) })
```

`Player`类应该有一个`make_move`方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("make_move")`) })
```

`Player`的`make_move`方法应该有一个参数`self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("make_move").has_args("self")`) })
```

`Player`的`make_move`方法应该使用`random.choice`从`moves`属性获取随机移动。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").block_has_call("choice", "make_move")`) })
```

`Player`的`make_move`方法应该通过将随机选择的移动坐标添加到它来更新`position`属性。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "无法实例化Pawn"

  p.make_move()
  assert p.position == (1, 2)
  p.make_move()
  assert p.position == (2, 4)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "缺少导入"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player`的`make_move`方法应该将新的`position`元组追加到`path`属性。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "无法实例化Pawn"

  p.make_move()
  assert p.path == [(0, 0), (1, 2)]
  p.make_move()
  assert p.path == [(0, 0), (1, 2), (2, 4)]

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "缺少导入"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player`的`make_move`方法应该返回更新后的`position`属性。

```js
({ test: () => runPython(`
def test_func():
  try:
    p = Pawn()
  except TypeError:
    assert False, "无法实例化Pawn"

  assert p.make_move() == (1, 2)

def custom_choice(seq):
  return (1, 2)

flag = None

try:
  original_choice = choice
  choice = custom_choice
  flag = "choice"
    
  test_func()

except NameError:
  try:
    original_choice = random.choice
    random.choice = custom_choice
    flag = "random.choice"

    test_func()

  except NameError:
    assert False, "缺少导入"
finally:
  if flag == "choice":
    choice = original_choice
  elif flag == "random.choice":
    random.choice = original_choice
`) })
```

`Player`类应该有一个`level_up`方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").has_function("level_up")`) })
```

`Player`的`level_up`方法应该有一个参数`self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Player").find_function("level_up").has_args("self")`) })
```

`Player`的`level_up`方法应该是一个抽象方法。

```js
({ test: () => runPython(`
target = _Node(_code).find_class("Player").find_function("level_up")
assert target.has_decorators("abstractmethod") or target.has_decorators("abc.abstractmethod")
`) })
```

`Player`类应该是一个抽象类。

```js
({ test: () => runPython(`
try:
  Player()
except TypeError as e:
  assert str(e) == "Can't instantiate abstract class Player with abstract method level_up"
else:
  assert False, "Player类应该是不可实例化的"
`) })
```

你应该有一个名为`Pawn`的类。

```js
({ test: () => runPython(`assert _Node(_code).has_class("Pawn")`) })
```

`Pawn`类应该继承自`Player`类。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").inherits_from("Player")`) })
```

`Pawn`类应该有一个`__init__`方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("__init__")`) })
```

`Pawn`的`__init__`方法应该有一个参数`self`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_args("self")`) })
```

`Pawn`的`__init__`方法应该使用`super`函数调用父类的`__init__`。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").find_function("__init__").has_stmt("super().__init__()")`) })
```

`Pawn`的`__init__`方法应该将`moves`属性设置为表示`x, y`坐标的元组列表，其中每个坐标元组表示以下方向的`1`单位移动：上、下、左、右。

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]
assert isinstance(p.moves, list)
assert len(p.moves) == 4
assert all(move in p.moves for move in moves)
`) })
```

`Pawn`类应该有一个`level_up`方法。

```js
({ test: () => runPython(`assert _Node(_code).find_class("Pawn").has_function("level_up")`) })
```

`Pawn`的`level_up`方法应该将四种对角线移动的`1`单位添加到`moves`属性。

```js
({ test: () => runPython(`
p = Pawn()
moves = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
p.level_up()
assert isinstance(p.moves, list)
assert len(p.moves) == 8
assert all(move in p.moves for move in moves)
`) })
```

# --seed--

## --seed-contents--

```py

```

# --solutions--

```py
from abc import ABC, abstractmethod
from random import choice


class Player(ABC):
    def __init__(self):
        self.moves = []
        self.position = (0, 0)
        self.path = [self.position]

    def make_move(self):
        x, y = self.position
        move = choice(self.moves)
        new_x = move[0] + x
        new_y = move[1] + y
        self.position = (new_x, new_y)
        self.path.append(self.position)
        return self.position

    @abstractmethod
    def level_up(self):
        pass


class Pawn(Player):
    def __init__(self):
        super().__init__()
        self.moves = [(0, 1), (1, 0), (-1, 0), (0, -1)]

    def level_up(self):
        self.moves.extend([(1, 1), (1, -1), (-1, 1), (-1, -1)])
```