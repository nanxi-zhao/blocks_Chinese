---
id: 6716249b5405164036fd0b0d
title: Build a Sorting Visualizer
challengeType: 25
dashedName: build-a-sorting-visualizer
demoType: onClick
---

# --description--

冒泡排序算法通过从序列开始处比较相邻元素对来排序整数序列。如果第一个元素大于第二个元素，则交换它们。然后继续处理下一对元素。当到达序列的最后一个元素时，它会从序列的开始处重新开始一个新的循环，并重复这个过程直到元素被排序。当一个循环完成且没有交换时，算法停止。

对于这个实验，我们已经提供了所有的HTML和CSS。你将使用JavaScript来完成冒泡排序可视化工具，使其能够可视化冒泡排序算法排序五个整数数组所需的每个步骤。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户需求：**

1. 你应该有一个名为 `generateElement` 的函数，返回一个介于 `1` 和 `100` 之间的随机整数（包含边界值）。
1. 你应该有一个名为 `generateArray` 的函数，使用 `generateElement` 函数返回一个包含五个随机整数的数组。
1. 你应该有一个名为 `generateContainer` 的函数，创建并返回一个空的 `div` 元素。
1. 你应该有一个名为 `fillArrContainer` 的函数，接受一个HTML元素作为第一个参数，一个数组作为第二个参数。
1. `fillArrContainer` 应该接受一个元素作为第一个参数，一个整数数组作为第二个参数，然后用五个 `span` 元素填充该元素，每个 `span` 显示数组中的一个整数。
1. 你应该有一个名为 `isOrdered` 的函数，接受两个整数并返回一个布尔值，指示第一个整数是否小于或等于第二个整数。
1. 你应该有一个名为 `swapElements` 的函数，接受一个整数数组和一个数字索引。
1. `swapElements` 函数应该就地修改数组，如果 `isOrdered` 返回 `false`，则交换传入索引处的元素和其后的元素。
1. 你应该有一个名为 `highlightCurrentEls` 的函数，接受一个HTML元素和一个数字索引。
1. `highlightCurrentEls` 函数应该设置给定元素在给定索引处的子元素以及紧随其后的子元素的 `border` 为 `dashed` 样式、`red` 颜色和你选择的宽度。
1. 当你点击 `#generate-btn` 时，你应该使用 `fillArrContainer` 函数用五个 `span` 元素填充 `#starting-array`，每个元素都有一个随机数作为文本。如果存在其他元素，应该从 `#array-container` 中移除。
1. 你应该实现冒泡排序算法，使得在你点击 `#sort-btn` 后，`#array-container` 包含冒泡排序算法排序起始数组所需的每个步骤的 `div` 元素，包括代表起始数组的 `div` 和代表已排序数组的 `div`。你迄今为止创建的函数在这里可能很有用。
1. 每个 `div` 应该包含五个 `span` 元素，代表数组在排序过程中的当前状态。
1. 在你点击 `#sort-btn` 后，`#starting-array` 应该代表起始步骤，显示初始数组并突出显示前两个整数。
1. 对于每个排序步骤，你应该使用 `highlightCurrentEls` 来突出显示正在比较的两个数字，并在下一步中使用 `swapElements` 来交换它们。

# --hints--

你应该有一个名为 `generateElement` 的函数。

```js
assert.isFunction(generateElement);
```

你的 `generateElement` 函数应该返回一个介于 `1` 和 `100` 之间的随机整数（包含边界值）。

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    assert.strictEqual(generateElement(), 26);
    assert.strictEqual(generateElement(), 9);
} finally {
    randomMocker.restore();
}
```

你应该有一个名为 `generateArray` 的函数。

```js
assert.isFunction(generateArray)
```

你的 `generateArray` 函数应该使用 `generateElement` 函数。

```js
let flag = false;
const temp = generateElement;
generateElement = () => flag = true;
try {
    generateArray();
    assert.isTrue(flag);
} finally {
    generateElement = temp;
}
```

你的 `generateArray` 函数应该返回一个包含五个介于 `1` 和 `100` 之间的随机整数的数组。

```js
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {
    assert.deepEqual(generateArray(), [26, 9, 58, 23, 38])
} finally {
    randomMocker.restore();
}
```

你应该有一个名为 `generateContainer` 的函数。

```js
assert.isFunction(generateContainer);
```

你的 `generateContainer` 函数应该返回一个空的 `div` 元素。

```js
const div = generateContainer();
assert.equal(div.tagName, "DIV");
assert.isEmpty(div.children);
```

你应该有一个名为 `fillArrContainer` 的函数。

```js
assert.isFunction(fillArrContainer);
```

你的 `fillArrContainer()` 应该接受一个元素作为第一个参数，一个整数数组作为第二个参数，然后用五个 `span` 元素填充该元素，每个 `span` 显示数组中的一个整数。

```js
const testDiv = document.createElement("div");
const testArr = [15, 98, 17, 5, 63]
fillArrContainer(testDiv, testArr);
const children = testDiv.children;
assert.lengthOf(children, 5);
Array.from(children).forEach((el, i) => {
    assert.equal(el.tagName, "SPAN");
    assert.equal(el.innerText.trim(), testArr[i])
})
```

你应该有一个名为 `isOrdered` 的函数。

```js
assert.isFunction(isOrdered);
```

你的 `isOrdered` 函数应该接受两个整数并返回一个布尔值，指示第一个整数是否小于或等于第二个整数。

```js
assert.lengthOf(isOrdered, 2);
assert.isTrue(isOrdered(2, 60));
assert.isFalse(isOrdered(10, 3));
assert.isTrue(isOrdered(5, 5));
```

你应该有一个名为 `swapElements` 的函数。

```js
assert.isFunction(swapElements);
```

你的 `swapElements` 函数接受一个整数数组和一个数字索引作为参数。如果第一个元素大于第二个元素，它应该就地修改传入的数组，交换给定索引处的元素和其后的元素。

```js
const testArr = [22, 4, 87, 47, 33];
swapElements(testArr, 0);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 1);
assert.deepEqual(testArr, [4, 22, 87, 47, 33]);
swapElements(testArr, 2);
assert.deepEqual(testArr, [4, 22, 47, 87, 33]);
swapElements(testArr, 3);
assert.deepEqual(testArr, [4, 22, 47, 33, 87]);
```

你应该有一个名为 `highlightCurrentEls` 的函数。

```js
assert.isFunction(highlightCurrentEls);
```

你的 `highlightCurrentEls` 函数应该给指定元素的后代元素（位于给定索引和下一个索引处）添加一个 `dashed`、`red` 的边框，并设置为你选择的宽度。

```js
const testDiv = document.createElement("div");
document.querySelector("body").appendChild(testDiv)
for (let i = 0; i < 5; i++) {
    testDiv.appendChild(document.createElement("span"));
}
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|#F00|hsl\(0,\s*100%,\s*50%\))/;
const revertBorder = () => {
    for (const el of children) {
        el.style.border = "revert";
    }
}
const children = testDiv.children;

for (let i = 0; i < 3; i++) {
    highlightCurrentEls(testDiv, i);
    for (let j = 0; j < 5; j++) {
        let b = getComputedStyle(children[j]).border;
        if (j == i || j == i + 1) {            
            assert.match(b, redBorderRegex);
            assert.isAbove(parseFloat(b), 0);
        } else {
            assert.notMatch(b, redBorderRegex);
        }
    }
    revertBorder();
}
testDiv.remove();
```

当你点击 `#generate-btn` 时，你应该用五个 `span` 元素填充 `#starting-array`，每个元素都有一个介于 `1` 和 `100` 之间的随机数作为文本。

```js
const genBtn = document.querySelector("#generate-btn");
genBtn.click();
const children = document.querySelector("#starting-array").querySelectorAll("span");
assert.lengthOf(children, 5);
Array.from(children).forEach(el => {
    assert.equal(el.tagName, "SPAN");
    const num = Number(el.innerText.trim());
    assert.isAtMost(num, 100);
    assert.isAtLeast(num, 1);
})
```

当 `#starting-array` 已经包含一个生成的数组，或者 `#array-container` 包含已排序的数组时，点击 `#generate-btn` 应该移除 `#array-container` 中的其他元素，只留下 `#starting-array` 并生成新的数字。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
genBtn.dispatchEvent(new Event("click"));

const prevNumbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));

sortBtn.dispatchEvent(new Event("click"));
genBtn.dispatchEvent(new Event("click"));

const container = document.querySelector("#array-container");
assert.lengthOf(container.children, 1);
const numbers = Array.from(document.querySelector("#starting-array").querySelectorAll("span")).map(el => Number(el.innerText.trim()));
assert.lengthOf(numbers, 5);
assert.isTrue(prevNumbers.some((num, index) => num !== numbers[index]))
```

在你点击 `#sort-btn` 后，`#array-container` 应该包含与冒泡排序算法排序起始数组所需步骤一样多的 `div` 元素，包括代表起始数组的 `div` 和代表已排序数组的 `div`。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
// 使用 randomMocker 确保起始数组需要13个步骤才能排序
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.lengthOf(container.children, 13)
    Array.from(container.children).forEach(el => {assert.equal(el.tagName, "DIV")})
} finally {
    randomMocker.restore();
}
```

在你点击 `#sort-btn` 后，`#array-container` 内的每个 `div` 应该包含五个 `span`，每个都有一个数字作为文本，并排列以表示冒泡排序算法排序起始数组所需的步骤。

```js
const finalArr = [9, 23, 26, 38, 58];
const arrays = [
    [26, 9, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 58, 23, 38],
    [9, 26, 23, 58, 38],
    [9, 26, 23, 38, 58],
    [9, 26, 23, 38, 58],
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr,
    finalArr
]
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
const randomMocker = new __helpers.RandomMocker();
randomMocker.mock();
try {    
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    const container = document.querySelector("#array-container");
    assert.isNotEmpty(container.children);
    Array.from(container.children).forEach((el, i) => {
        Array.from(el.children).forEach((j, k) => {
            assert.strictEqual(Number(j.innerText.trim()), arrays[i][k])
        })
    })
} finally {
    randomMocker.restore();
}
```

当你点击 `#sort-btn` 时，你应该使用 `highlightCurrentEls` 函数来突出显示每一步中正在比较的元素。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");
let flag = false;
const temp = highlightCurrentEls;
highlightCurrentEls = () => flag = true;
try {
    genBtn.dispatchEvent(new Event("click"));
    sortBtn.dispatchEvent(new Event("click"));
    assert.isTrue(flag);
} finally {
    highlightCurrentEls = temp;
}
```

在你点击 `#sort-btn` 后，`#starting-array` 应该代表起始步骤，显示初始数组并使用 `highlightCurrentEls` 突出显示前两个整数。

```js
const genBtn = document.querySelector("#generate-btn");
const sortBtn = document.querySelector("#sort-btn");   
genBtn.dispatchEvent(new Event("click"));
sortBtn.dispatchEvent(new Event("click"));
const firstContainer = document.querySelector("#starting-array");
const children = firstContainer.children
const redBorderRegex = /dashed (rgb\(255,\s*0,\s*0\)|#FF0000|hsl\(0,\s*100%,\s*50%\))/;
assert.match(getComputedStyle(children[0]).border, redBorderRegex);
assert.match(getComputedStyle(children[1]).border, redBorderRegex);
```

# --seed--

## --seed-contents--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js

```

# --solutions--

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Sorting Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <main>
        <div id="array-container">
            <div id="starting-array"></div>
        </div>
        <div id="btn-container">
            <button id="generate-btn" type="button">Generate Array</button>
            <button id="sort-btn" type="button">Sort Array</button>
        </div>
    </main>
    <script src="script.js"></script>
</body>

</html>
```

```css
* {
    box-sizing: border-box;
}

main {
    height: 100vh;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
}

#array-container {
    max-height: 95vh;
    display: flex;
    flex-direction: column;
    flex-wrap: wrap;
    gap: 2px;

}

#array-container>div {
    min-width: 8rem;
    height: 2rem;
    box-shadow: rgba(50, 50, 93, 0.25) 0px 2px 5px -1px, rgba(0, 0, 0, 0.3) 0px 1px 3px -1px;
    border-radius: 10px;
    margin-bottom: 0.2rem;
    border: 2px solid darkgray;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
}

#starting-array {
    border: 4px solid darkblue !important;
}

#btn-container {
    display: flex;
    justify-content: space-around;
}

button {
    padding: 2px;
    margin: 5px;
}

#sort-btn {
   display: none 
}

span {
    border-radius: 2px;
    padding: 0.5px;
    margin: 0
}

@media (min-width: 430px) {
  #array-container>div {
    min-width: 12rem;    
  }
  span {
    padding: 1px;
    margin: 1px;
  }
}
```

```js
const arrayContainer = document.getElementById("array-container");
const generateArrayBtn = document.getElementById("generate-btn");
const sortArrayBtn = document.getElementById("sort-btn");
const arrayLength = 5;
const minVal = 1;
const maxVal = 100;
const isStart = () => arrayContainer.children.length === 1;
const clearArrayContainer = () => { arrayContainer.innerHTML = '<div id="starting-array"></div>' };
const showSortBtn = () => {sortArrayBtn.style.display = "inline-block"};
const hideSortBtn = () => {sortArrayBtn.style.display = "none"};
const generateElement = () => Math.floor(Math.random() * maxVal + minVal);
const generateArray = () => Array.from({ length: arrayLength }, generateElement);
const fillArrContainer = (container, arr) => {
    container.innerHTML = "";
    arr.forEach(i => {
        const el = document.createElement("span");
        el.innerText = i;
        el.id = `number-${i}`
        container.appendChild(el);
    })
}
const isOrdered = (el1, el2) => el1 <= el2;

const swapElements = (arr, n = 0) => {
    if (n < arr.length - 1 && !isOrdered(arr[n], arr[n + 1])) {
        const temp = arr[n];
        arr[n] = arr[n + 1];
        arr[n + 1] = temp;
    }
}
const getLastChildren = () => arrayContainer.lastElementChild;
const getLastArr = () => {
    const els = Array.from(getLastChildren().children);
    const arr = els.map(el => Number(el.id.replace("number-", "")));
    return arr;
}
const generateContainer = () => {
    const container = document.createElement("div");
    arrayContainer.appendChild(container);
    return container;
}
const highlightCurrentEls = (container, n = 0) => {
    const children = container.children;
    children[n].style.border = "2px dashed red";
    children[n + 1].style.border = "2px dashed red";
}

const highlightSorted = () => {
    getLastChildren().style.border = "4px solid green";
}

const bubbleSort = () => {
    let swapped = true;
    while (swapped) {
        const startingArr = getLastArr();
        startingArr.forEach((_, i) => {
            if (i + 1 < arrayLength) {
                highlightCurrentEls(getLastChildren(), i);
                const arr = getLastArr();
                swapElements(arr, i);
                fillArrContainer(generateContainer(), arr);
            }
        })
        const lastArr = getLastArr()
        if (startingArr.every((el, i) => el === lastArr[i])) swapped = false;
    }
}


generateArrayBtn.addEventListener("click", () => {
    if (!isStart()) {
        clearArrayContainer();
    }
    fillArrContainer(document.getElementById("starting-array"), generateArray());
    showSortBtn();
});

sortArrayBtn.addEventListener("click", () => {
    bubbleSort();
    highlightSorted();
    hideSortBtn();
})
```

