---
id: 67fe85a1b634a335b18ae09a
title: What Is Scope in Python and How Does It Work?
challengeType: 19
dashedName: what-is-scope-in-python-and-how-does-it-work
---

# --description--

在 Python 中，作用域（scope）决定了变量可被访问的范围，也影响变量的生命周期和在不同代码区域如何被解析。

为了解析变量作用域，Python 遵循 **LEGB** 规则，代表：

- **Local（局部）**：函数或类内部定义的变量。
- **Enclosing（闭包/嵌套）**：在嵌套函数中定义的外层函数变量。
- **Global（全局）**：模块或文件顶层定义的变量。
- **Built-in（内置）**：Python 的内置名称，例如内置函数、模块和关键字。

下面逐项解释这些规则，帮助你理解变量是如何被解析的。

**局部作用域（Local）** 表示在函数或类内部声明的变量只能在该函数或类内部访问。

示例：

```python
def my_func():
    my_var = 10
    print(my_var)
```

在这个例子中，`my_func` 有自己的作用域，外部无法直接访问该作用域内的变量。调用 `my_func()` 会打印 `10`，但在函数外打印 `my_var` 会导致 `NameError`：

```python
def my_func():
    my_var = 10 # 仅在 my_func 内部可见
    print(my_var)

my_func() # 10

print(my_var) # NameError: name 'my_var' is not defined
```

**闭包/嵌套作用域（Enclosing）** 意味着嵌套函数可以访问其外层函数中定义的变量。

例如：

```python
def outer_func():
    msg = 'Hello there!'

    def inner_func():
        print(msg)

    inner_func()

outer_func() # Hello there!
```

在上例中，`inner_func` 可以访问 `outer_func` 中的 `msg`。但需要注意的是，外层函数不能访问嵌套函数内部定义的变量：

```python
def outer_func():
    msg = 'Hello there!'
    print(res)

    def inner_func():
        res = 'How are you?'
        print(msg)

    inner_func()

outer_func() # NameError: name 'res' is not defined
```

这是因为 `res` 仅在 `inner_func` 的局部作用域中有效。注意 `outer_func` 在调用 `inner_func` 之前就尝试打印 `res`。

一种解决方法是在外层作用域（也就是 `outer_func` 内）先初始化 `res`，然后在内层函数中使用 `nonlocal` 声明以允许修改该变量：

```python
def outer_func():
    msg = 'Hello there!'
    res = ""  # 在闭包作用域中声明 res

    def inner_func():
        nonlocal res  # 允许修改外层作用域的变量
        res = 'How are you?'
        print(msg)  # 访问 outer_func() 中的 msg

    inner_func()
    print(res)  # 现在 res 已被修改并可访问

outer_func()

# 输出：
# Hello there!
# How are you?
```

**全局作用域（Global）** 指在任何函数或类外部定义的变量，可以在程序的任意位置访问。例如：

```python
my_var = 100

def show_var():
    print(my_var)

show_var() # 100
print(my_var) # 100
```

若希望在函数内部将一个局部变量提升为全局变量，可以使用 `global` 关键字：

```python
my_var_1 = 7

def show_vars():
    global my_var_2
    my_var_2 = 10
    print(my_var_1)
    print(my_var_2)

show_vars() # 7 10

# my_var_2 现在是全局变量，可在程序任意位置访问
print(my_var_2) # 10
```

也可以使用 `global` 来修改一个已存在的全局变量：

```python
my_var = 10  # 全局变量

def change_var():
    global my_var  # 允许修改全局变量
    my_var = 20

change_var()

print(my_var)  # my_var 现在在全局范围被修改为 20
```

最后，**内置作用域（Built-in）** 包含了 Python 的内置函数、模块和关键字，这些名称在程序中任何位置都可用：

```python
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

# --questions--

## --text--

What is the rule Python follows to determine the scope of a variable?

## --answers--

STACK: Static, Temporary, Active, Constant, Keyword

### --feedback--

It consists of four levels, starting from the most specific to the most general.

---

TREE: Temporary, Reserved, Enclosing, External

### --feedback--

It consists of four levels, starting from the most specific to the most general.

---

LEGB: Local, Enclosing, Global, Built-in

---

SCOPE: Script, Constant, Outer, Python, Embedded

### --feedback--

It consists of four levels, starting from the most specific to the most general.

## --video-solution--

3

## --text--

What does the `nonlocal` keyword do?

## --answers--

Makes a variable global.

### --feedback--

It helps modify variables in an outer function.

---

Creates a new local variable.

### --feedback--

It helps modify variables in an outer function.

---

Prevents variable reassignment.

### --feedback--

It helps modify variables in an outer function.

---

Allows modifying a variable from an enclosing function

## --video-solution--

4

## --text--

Which keyword can you use to modify a global variable in Python?

## --answers--

`global`

---

`local`

### --feedback--

It allows changes to a variable outside the function.

---

`static`

### --feedback--

It allows changes to a variable outside the function.

---

`nonlocal`

### --feedback--

It allows changes to a variable outside the function.

## --video-solution--

1
