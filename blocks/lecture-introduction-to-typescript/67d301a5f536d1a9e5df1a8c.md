---
id: 67d301a5f536d1a9e5df1a8c
title: What Is Type Narrowing, and How Does It Work?
challengeType: 19
dashedName: what-is-type-narrowing-and-how-does-it-work
---

# --description--

有时你会遇到需要把广泛类型的值缩小为更具体类型的场景。例如，确保某个对象符合你定义的接口，或判断某个字符串是否在预设值列表中。实现类型缩小有很多方法。

第一种是基于 truthiness（真值性）进行缩小。回想上一课的例子：

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

尝试直接访问 `email.value` 会触发编译错误，因为 `email` 可能为 `null`。不过，我们可以用条件判断先确认 `email` 为 truthy 再访问属性：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

在更新后的例子中，因为 `null` 不是 truthy 值，TypeScript 能在条件块内推断出 `email` 必定是 `input` 元素，因此不再报编译错误。

也可以反向使用 truthiness 检查：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

在这种写法中，如果 `email` 为 falsy（例如 `null`），我们抛出错误终止执行；因此当程序执行到 `console.log()` 时，TypeScript 就知道 `email` 不可能为 `null`。

可选链（optional chaining）也是一种类型缩小的形式，基于相同的前提：如果 `email` 为 `null`，就不会去访问属性。

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

对于其他类型，你还可以使用 `typeof` 进行缩小。看下面这个变量可能为字符串或数字的例子：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

在这个例子中会出现编译错误，因为不能对字符串执行数学运算。我们可以通过 `typeof` 判断来缩小类型：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

使用 `typeof` 后，TypeScript 就知道 `myVal` 是数字，我们可以安全地进行算术运算。

对于更复杂的对象类型，如果对象来自类实例，你可以使用 `instanceof` 来缩小类型。回到 `querySelector()` 的例子：

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

这种方法和之前类似，但 `instanceof` 是运行时检查——即使类型注解有误，JavaScript 也会在运行时确认 `email` 是否为 `input` 元素。

接下来看从 API 获取 `User` 对象并打印信息的例子：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

我们把 `myUser` 传给函数时会遇到编译错误，因为虽然我们知道 API 会返回正确结构，但 TypeScript 并不确定，而 `.json()` 方法也没有泛型信息。

一种“粗暴”的解决方法是进行类型断言（cast）：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

但类型断言会削弱 TypeScript 捕获潜在错误的能力。更稳妥的做法是写一个类型守卫（type guard）：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

关键在于返回类型 `user is User`：当函数返回 `true` 时，TypeScript 会把 `user` 视为 `User` 类型。我们通过 truthiness 检查（`!!user`）和 `typeof` 缩小来确保对象结构匹配——注意 `typeof null` 会返回 `"object"`，因此需要先做 truthiness 检查。

把这些逻辑结合起来：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

这样组合后就不会产生编译错误，代码也能正常构建。

类型缩小是帮助你写出更安全、错误更少代码的强大工具——但请记住 TypeScript 的类型并非完全僵化，所以尽量避免在没有缩小的前提下滥用类型断言。

# --questions--

## --text--

Which of the following is NOT a method of type narrowing discussed in the lecture?

## --answers--

Truthiness checks.

### --feedback--

While all of these can be used to narrow a type, one of them wasn't mentioned.

---

Optional chaining.

### --feedback--

While all of these can be used to narrow a type, one of them wasn't mentioned.

---

`typeof` operator.

### --feedback--

While all of these can be used to narrow a type, one of them wasn't mentioned.

---

Switch statements.

## --video-solution--

4

## --text--

What is the purpose of the `user is User` syntax in the type guard function?

## --answers--

It casts the `user` parameter to the `User` type.

### --feedback--

Think about the word `is`, and how the phrase `user is User` works.

---

It indicates that the function returns a boolean value.

### --feedback--

Think about the word `is`, and how the phrase `user is` User works.

---

It indicated that `user` satisfies the `User` interface.

---

It creates a new instance of the `User` interface.

### --feedback--

Think about the word `is`, and how the phrase `user is` User works.

## --video-solution--

3

## --text--

Which of the following is true about type casting in TypeScript?

## --answers--

It's the recommended way to resolve type issues.

### --feedback--

Type casting should be done as a last resort.

---

It strengthens TypeScript's ability to catch errors.

### --feedback--

Type casting should be done as a last resort.

---

It's done using the `as` keyword.

---

It should always be used instead of type guards.

### --feedback--

Type casting should be done as a last resort.

## --video-solution--

3
