---
id: 67d2f5b78609f97400923f7f
title: What Are State Management Libraries, and When Should You Use Them?
challengeType: 19
dashedName: what-are-state-management-libraries-and-when-should-you-use-them
---

# --description--

随着应用规模增大，组件间数据流的管理会变得复杂。

刚开始时，React 的 `useState` 钩子往往足够用，但随着功能增加，你可能会遇到：

- 需要把 props 传给不需要它们的组件（也就是 prop drilling）
- 在应用不同部分保持数据同步困难
- 处理会影响多个组件的复杂更新变得棘手

这些问题会使代码库更难维护、调试和测试，这时状态管理库就很有用——它们提供了一个中心位置，组件可以在此读取或更新所需数据。

下面我们看几种常见的状态管理方案，以及何时使用它们。

Context API 是 React 内置的状态共享机制，能让你在组件间共享状态而无需第三方库。它是在 `useState` 之上的一个成熟升级方案，适合用于主题切换或用户认证状态之类的场景。

不过，Context API 对于高频更新的场景支持不佳，可能导致不必要的重渲染，因此在电商或社交平台这类复杂应用中并不是最佳选择。

下面是一个演示 Context API 基本用法的计数器示例：

```jsx
import { useState, createContext } from 'react';

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

这段代码创建了一个 Context 和一个 Provider，用来在应用中共享 `count` 状态。

`CounterProvider` 使用 `useState` 初始化并管理 `count` 及其 setter，然后把它们通过 Provider 传给子组件。

当你用 `CounterProvider` 包裹整个应用时，`count` 状态就可以在应用任意位置使用。

下面展示如何在应用中包裹 `CounterProvider`：

```jsx
import { CounterProvider } from './context/CounterContext';

function App() {
  return (
    <CounterProvider>
        {/* App components */}
    </CounterProvider>
  );
}

export default App;
```

以及如何在组件中使用 `count` 状态：

```jsx
import React, { useContext } from 'react';
import { CounterContext } from '../context/CounterContext';

const Counter = () => {
  const { count, setCount } = useContext(CounterContext);

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Context API Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => setCount(count - 1)}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => setCount(count + 1)}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

可以看到，`count` 与 `setCount` 通过 `useContext` 获取，界面显示当前 `count`，并通过 `setCount` 实现加减。

另一个流行的状态管理库是 Redux。Redux 在 React 生态中使用广泛，适合大型应用（如电商、社交平台等）。

Redux 通过提供中心化的 store 和严格的状态更新流程来管理状态，采用 actions、reducers 和 middleware 的可预测模式。

Actions 是携带信息的对象，通常由用户交互触发，用来把数据发送到 Redux store。

Reducers 是函数，定义了在接收到某类 action 后，状态应如何以不可变方式更新。

Middleware 则位于 action 派发与 reducer 之间，允许你在不修改核心流程的情况下扩展 Redux（例如记录日志或处理异步操作）。

关于 Redux 的常见抱怨是上手需要很多样板代码。为此，Redux 团队推出了 Redux Toolkit 和 RTK Query，大大简化了配置流程。

通常你会用 `createSlice()` 在单个文件中同时定义 actions 和 reducers，文件名常以 `Slice` 结尾，如 `productSlice`、`userSlice` 或 `counterSlice`。

下面是一个 `counterSlice` 的基础示例：

```jsx
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',

  initialState: { count: 0 },

  reducers: {
    increment: (state) => {
      state.count += 1;
    },
    decrement: (state) => {
      state.count -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;

export default counterSlice.reducer;
```

接下来你需要用 `Provider` 包裹整个应用，用 `useSelector()` 选择 slice 的一部分状态，再用 `useDispatch()` 派发 action 来更新状态。

还有一种值得考虑的方案是 Zustand。

Zustand 是一个轻量级的状态管理库，API 简洁，基于钩子（hooks），相比 Redux 更少样板代码，上手更快。

Zustand 适合小到中等规模的应用。它通过 `useStore` 钩子在组件中直接访问状态，无需 actions、reducers 或 Provider。

下面是实现计数功能的 `useCounterStore`：

```jsx
import { create } from 'zustand';

const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useCounterStore;
```

以及在应用中初始化并使用该状态：

```jsx
// Import the useCounterStore (it's just a hook)
import useCounterStore from '../useCounterStore';

const Counter = () => {
  // Initialize the states with the useCounterStore hook
  const { count, increment, decrement } = useCounterStore();

  return (
    <>
      <div style={{ textAlign: 'center' }}>
        <h1>Zustand Counter</h1>
        <button style={{ marginRight: '5px' }} onClick={() => decrement()}>
          Decrease
        </button>
        <span>{count}</span>
        <button style={{ marginLeft: '5px' }} onClick={() => increment()}>
          Increase
        </button>
      </div>
    </>
  );
};

export default Counter;
```

前端生态不断演进，新的状态管理库层出不穷，但我们讨论的这些在行业内被广泛使用。

# --questions--

## --text--

Which of these is a reason to use a state management library?

## --answers--

To avoid writing any state logic in your application.

### --feedback--

Think about the benefits of managing complex state across multiple components and pages.

---

To automatically update the UI without re-rendering.

### --feedback--

Think about the benefits of managing complex state across multiple components and pages.

---

To create a consistent and predictable data flow.

---

To eliminate the need for props entirely.

### --feedback--

Think about the benefits of managing complex state across multiple components and pages.

## --video-solution--

3

## --text--

Which of these is NOT a state management library?

## --answers--

Context API

### --feedback--

Think about which one is used specifically for API requests.

---

Redux

### --feedback--

Think about which one is used specifically for API requests.

---

Zustand

### --feedback--

Think about which one is used specifically for API requests.

---

Axios

## --video-solution--

4

## --text--

What was a common complaint about Redux, and how was it addressed?

## --answers--

It had limited browser support, which was addressed by creating polyfills.

### --feedback--

Think about the improvements that were made to reduce setup complexity.

---

It had performance issues, which were addressed by optimizing its middleware.

### --feedback--

Think about the improvements that were made to reduce setup complexity.

---

It required a lot of complex boilerplate code, which was addressed by Redux Toolkit and RTK Query.

---

There was a lack of documentation, which was addressed by adding more examples.

### --feedback--

Think about the improvements that were made to reduce setup complexity.

## --video-solution--

3
