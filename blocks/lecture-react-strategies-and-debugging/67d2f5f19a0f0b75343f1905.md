---
id: 67d2f5f19a0f0b75343f1905
title: What Are React Server Components, and How Do They Work?
challengeType: 19
dashedName: what-are-react-server-components-and-how-do-they-work
---

# --description--

React Server Components（RSCs）正在改变 React 开发者的思路。通过把更多工作移到服务器端，RSC 可以带来很多好处。

我们来看看什么是服务器组件、它们如何工作，以及为什么会引入服务器组件。

React Server Components 是在服务器上渲染的 React 组件，服务器只把最终生成的 HTML 发给客户端。这意味着这些组件可以直接访问服务器端资源，并显著减少发送到浏览器的 JavaScript 体积。

传统的 React 应用主要采用“客户端组件”体系来处理渲染、交互和副作用等工作。在 React Server Components 出现之前，术语“客户端组件”并不常被特别提及。

但客户端组件体系也有缺点，比如打包出的 JavaScript 体积大、首屏加载较慢等。

像 Next.js 和 Gatsby 这样的 React 框架通过把部分流程下放到服务器端来缓解这些问题，但这些做法没有统一标准。如果你用过这些框架，可能听说过 `getServerSideProps` 或 `getServerData`。

React Server Components 的出现允许你把某些组件完全放到服务器端运行，在用户浏览器执行任何代码之前就完成数据获取和计算。

服务器组件首先在 Next.js 中流行并得到良好支持，Remix 和 Gatsby 等其他框架也在跟进；Vite 社区里还有一个实验性的插件 `vite-plugin-react-server`，可以用来构建服务器组件。

那么服务器组件是如何工作的呢？

一个展示 React Server Components 的好方法是使用数据获取的示例。

在传统的客户端组件中，浏览器负责发起 API 请求。由于数据获取是副作用，你会在 `useEffect` 钩子中执行这些请求。

同时通常会用 `loading`、`data`、`error` 这样的状态变量来表示加载状态、展示数据或显示错误信息。

使用 React Server Components 时，你可以把整个组件移到服务器端，在那里直接获取数据，而不需要使用 `useState` 或 `useEffect`：

```jsx
const Users = async () => {
  const res = await fetch("https://jsonplaceholder.typicode.com/users");
  const users = await res.json();

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users;
```

Because React Server Components only run on the server, you can just fetch data from an API and render just once. Also, since data fetching happens on the server, closer to the source, your app may perform better, especially for people with slow network connections.

Once major gotcha is that all the code for server components remain on the server, and doesn't get shipped to the browser. That means you can't use React hooks with them, and they don't have access to Web APIs or browser event listeners. So how can you add interactivity?

In the Next.js app router, all components are server components by default. If you want to add interactivity, you need to mark the component as a client component with the `"use client"` directive.

Let's say you want to make the previous example a client component. Here's how you can do that:

```jsx
"use client";

import { useState, useEffect } from "react";

const Users2 = () => {
  const [status, setStatus] = useState({
    users: [],
    loading: true,
    error: null,
  });

  async function fetchUsers() {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/users");
      const data = await res.json();
      setStatus((prevStatus) => ({
        ...prevStatus,
        users: data,
        loading: false,
      }));
    } catch (err) {
      setStatus((prevStatus) => ({
        ...prevStatus,
        error: err.message,
        loading: false,
      }));
    }
  }

  useEffect(() => {
    fetchUsers();
  }, []);

  if (status.loading) {
    return <p>Loading Users...</p>;
  }
  if (status.error) {
    return <p>Error getting users: {status.error}</p>;
  }

  return (
    <>
      <h1 className="text-4xl text-center mt-6">Users</h1>
      <ul className="text-center mt-3">
        {status.users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </>
  );
};

export default Users2;
```

If you want to add interactivity like click events, the component also has to be marked as a client component:

```jsx
"use client";

import { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <>
      <h1>Counter</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <h2>{count}</h2>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </>
  );
};

export default Counter;
```

If you don't add the use client directive to the component, you get an error with a message that says "You're importing a server component that needs `useState`. This React hook only works in a client component. To fix, mark the file (or its parent) with the `"use client"` directive."

The main benefits that come with React Server Components are that data fetching becomes simpler, the code is easier to read, and client complexity is reduced.

由于 React Server Components 仅在服务器端运行，你可以直接从 API 获取数据并只渲染一次。而且因为数据获取在服务器端、更靠近数据源进行，应用性能可能更好，尤其对网络较慢的用户更友好。

需要注意的一点是：服务器组件的所有代码都保留在服务器上，并不会发送到浏览器。这意味着你不能在服务器组件中使用 React 钩子（hooks），也无法访问 Web API 或浏览器事件监听器。那么如何为它们添加交互性呢？

在 Next.js 的 app router 中，默认所有组件都是服务器组件。如果你想加入交互性，需要使用 `"use client"` 指令将组件标记为客户端组件。

如果你想把前面的示例改成客户端组件，可以这样做：

# --questions--


React Server Components 在哪里运行？

## --answers--

仅在服务器上运行。

---

在客户端和服务器两端都运行。

### --feedback--

请注意 RSCs 不会在浏览器中执行，它们用于在服务器端预渲染数据。

---

完全在服务器上运行。

---

在 Web Worker 中运行。

### --feedback--

请注意 RSCs 不会在浏览器中执行，它们用于在服务器端预渲染数据。

## --video-solution--

3
3

为什么 React Server Components 无法访问 React 钩子和浏览器的 Web API？

## --answers--

因为它们在浏览器加载之前就渲染完成。

### --feedback--

这些组件从不在浏览器中执行，因此无法使用客户端特性。

---

因为它们只在服务器上运行，并不会被发送到浏览器。

---

因为它们受限于 React 的渲染周期。

### --feedback--

这些组件从不在浏览器中执行，因此无法使用客户端特性。

---

它们仅用于样式目的。

### --feedback--

这些组件从不在浏览器中执行，因此无法使用客户端特性。

## --video-solution--

2


在使用 Next.js 的 app router 时，如何为组件添加交互性？

## --answers--

将组件包裹在 `<ClientProvider>` 标签中。

### --feedback--

Next.js 假定所有组件默认是服务器组件，除非明确声明为客户端组件。

---

使用 Next.js 的 `withClient()` 函数。

### --feedback--

Next.js 假定所有组件默认是服务器组件，除非明确声明为客户端组件。

---

在 `next.config.js` 中启用客户端渲染。

### --feedback--

Next.js 假定所有组件默认是服务器组件，除非明确声明为客户端组件。

---

使用 `"use client"` 指令将组件标记为客户端组件。

## --video-solution--

4
## --video-solution--

4
