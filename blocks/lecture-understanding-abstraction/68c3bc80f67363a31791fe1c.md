---
id: 68c3bc80f67363a31791fe1c
title: 什么是抽象，它如何帮助保持复杂系统的有序性？
challengeType: 19
dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized
---

# --description--

现在我们已经了解了封装、继承和多态，让我们来讨论面向对象编程的下一个关键概念——抽象。

抽象是隐藏复杂实现细节并只显示对象或系统基本特征的过程。可以把它想象成关注某事物做什么而不是如何做。

抽象不仅限于 Python。它是一个编程概念，可以在许多支持面向对象编程的语言中实现。

为了说明抽象，想象一下你在开车。当你坐在驾驶座上时，你会与方向盘、换挡器以及油门和刹车踏板等基本部件交互。你不需要知道发动机如何工作、变速器如何换挡或制动系统背后的物理原理等复杂实现细节。

这就是抽象在起作用！它为你提供了一个简化的界面来与复杂系统交互。

再次以汽车为例，简化界面是方向盘、刹车和油门，而复杂系统是汽车本身。

至于 Python 如何实现抽象，它是通过 `abc` 模块实现的。

这个模块提供了 `ABC` 类（代表"抽象基类"）和 `@abstractmethod` 装饰器。

`ABC` 是 meant to be inherited from 的类，但你不能直接从中创建对象。它定义了其子类必须实现的方法和属性的通用接口。

另一方面，抽象方法是在抽象基类（ABC）中使用 `@abstractmethod` 装饰器声明的方法。它可能没有实现或只有基本的默认实现。但是，任何子类都必须覆盖它才能被认为是具体的和可实例化的，即使提供了默认实现。

以下是 Python 中抽象类的基本语法：

```py
from abc import ABC, abstractmethod

# 定义一个抽象基类
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# 实现抽象方法的具体子类
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('ConcreteClassOne 中的实现')

# 另一个具体子类
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('ConcreteClassTwo 中的实现')
```

这是一个基本示例：

```py
from abc import ABC, abstractmethod

class Animal(ABC): # 继承自抽象基类
   @abstractmethod # 抽象方法装饰器
   def make_sound(self):  # 子类必须覆盖的方法
       pass

# 将覆盖抽象方法的具体类
class Dog(Animal):
   def make_sound(self):
       print('汪汪!')

# 将覆盖抽象方法的另一个具体类
class Cat(Animal):
   def make_sound(self):
       print('喵喵!')

# 将覆盖抽象方法的另一个具体类
class Monkey(Animal):
   def make_sound(self):
       print('哦哦啊啊!')

# 创建每个具体类的实例
animals = [Dog(), Cat(), Monkey()]

# 遍历实例调用 make_sound 方法
for animal in animals:
   animal.make_sound()

# 输出:
# 汪汪!
# 喵喵!
# 哦哦啊啊!
```

在这个示例中:

- 我们从 `abc` 模块导入 `ABC` 类和 `abstractmethod`。
- 然后我们创建一个继承自 `ABC` 的 `Animal` 类，并在其中创建一个抽象方法 `make_sound`，`Animal` 的每个子类都必须覆盖它。
- 我们创建具体类 `Dog`、`Cat` 和 `Monkey`，它们必须覆盖 `make_sound` 抽象方法。
- 我们实例化具体类并调用它们的 `make_sound` 方法，展示它们如何以各自的方式实现 `make_sound` 抽象方法。

记住你不能创建 Animal 类的实例。如果你尝试这样做会发生什么:

```py
dog = Animal() 
# TypeError: Can't instantiate abstract class Animal 
# without an implementation for abstract method 'make_sound'
```

同样的规则适用于没有提供抽象方法实现的子类。即使你定义了 Animal 的子类，在它覆盖 make_sound 之前你也不能实例化它。以下示例展示了这一点:

```py
class Bird(Animal):
    pass

bird = Bird()
# TypeError: Can't instantiate abstract class Bird 
# without an implementation for abstract method 'make_sound'
```

这是另一个示例，这次是你可以传递给具体方法实例的实例属性:

```py
from abc import ABC, abstractmethod

# 任何可以说话的玩具的蓝图
class TalkingToy(ABC):
   def __init__(self, name):
       self.name = name
   @abstractmethod
   def speak(self):
       pass

class RobotToy(TalkingToy):
   def speak(self):
       print(f'{self.name} 说哔哔! 我是机器人!')

class TeddyBearToy(TalkingToy):
   def speak(self):
       print(f"{self.name} 说抱抱我! 我很可爱!")

class DinosaurToy(TalkingToy):
   def speak(self):
       print(f'{self.name} 说吼吼吼!')

# 创建玩具
rusty = RobotToy('Rusty')
fluffy = TeddyBearToy('Fluffy')
rex = DinosaurToy('Rex')

toys = [rusty, fluffy, rex]
for toy in toys:
   toy.speak()

# 输出:
# Rusty 说哔哔! 我是机器人!
# Fluffy 说抱抱我! 我很可爱!
# Rex 说吼吼吼!
```

在这个示例中:

- 我们有一个抽象基类 `TalkingToy`，它定义了任何可以说话的玩具的蓝图。
- 子类 `RobotToy`、`TeddyBearToy` 和 `DinosaurToy` 以各自的方式实现 `speak` 方法。
- 当我们创建这些子类的实例并调用 `speak` 方法时，每个玩具都以自己独特的方式说话。

总之，Python 中的抽象通过增加可重用性来简化复杂系统。

你已经看到如何在多个子类中重用抽象类的单个方法，同时强制每个子类提供其特定行为。

这种方法使你的代码保持组织性、灵活性和易于维护，特别是当你的应用程序增长时。

# --questions--

## --text--

面向对象编程中抽象的主要目标是什么？

## --answers--

向用户暴露所有内部实现细节。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

将多个类合并为一个。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

防止方法在子类中被覆盖。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

隐藏复杂逻辑并只显示基本特征

### --feedback--

想想抽象如何简化与复杂系统的交互。

## --video-solution--

4

## --text--

Python 如何通过其 `ABC` 模块实现抽象？

## --answers--

允许直接实例化抽象类。

### --feedback--

ABC 模块强制子类实现方法。

---

使用装饰器和继承来定义子类必须实现的抽象方法。

### --feedback--

ABC 模块强制子类实现方法。

---

通过自动隐藏所有带双下划线的方法。

### --feedback--

ABC 模块强制子类实现方法。

---

通过将类转换为函数。

### --feedback--

ABC 模块强制子类实现方法。

## --video-solution--

2

## --text--

在汽车抽象的类比中，什么代表简化界面和复杂系统？

## --answers--

界面是发动机活塞，复杂系统是方向盘。

### --feedback--

想想界面是你直接交互的部分，而复杂系统是它的工作原理。

---

界面是方向盘、刹车和油门，复杂系统是发动机、变速器和制动物理原理。

### --feedback--

想想界面是你直接交互的部分，而复杂系统是它的工作原理。

---

界面是汽车手册，复杂系统是仪表板控制。

### --feedback--

想想界面是你直接交互的部分，而复杂系统是它的工作原理。

---

界面是燃料类型，复杂系统是轮胎。

### --feedback--

想想界面是你直接交互的部分，而复杂系统是它的工作原理。

## --video-solution--

2