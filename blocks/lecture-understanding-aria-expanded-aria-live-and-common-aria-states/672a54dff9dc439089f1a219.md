---
id: 672a54dff9dc439089f1a219
title: 什么是 aria-live 属性，它是如何工作的？
challengeType: 19
dashedName: what-is-the-aria-live-attribute
---

# --interactive--

`aria-live` 属性在你的页面上创建一个实时区域，可用于在实时区域中发生动态内容更改时立即通知屏幕阅读器用户。

实时区域的常见用途包括在执行操作后显示的消息（如错误消息或确认消息）、定期更新的内容（如股票行情、跑马灯或倒计时器）或一般状态消息（如进程更新）。

由于屏幕阅读器的阅读焦点一次只能在一个地方，当屏幕阅读器用户的焦点在页面的另一部分时，他们不会注意到内容更改。实时区域允许屏幕阅读器用户实时自动通知页面上发生的更改。没有实时区域，屏幕阅读器用户可能会错过对视力用户可用的重要内容更新，因为视力用户有能力扫描整个页面。

该属性有三个可能的值，基于信息的优先级。

如果你将 `aria-live` 设置为值 `assertive`，这意味着更新非常重要。它具有最高优先级，因此用户应立即收到通知。

这意味着屏幕阅读器将中断当前正在进行的任何公告，以宣布实时区域中的内容更改。这种中断可能极其破坏性，因此 `assertive` 值应仅用于时间敏感或关键通知。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="session-warning" aria-live="assertive">
  <p>您的会话将在 30 秒后过期。</p>
</div>

<script src="index.js"></script>

```

```css
.session-warning {
  background-color: #ffcc00;
  color: #000;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  padding: 1em 1.5em;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 0.4s ease, transform 0.4s ease;
}

.session-warning.visible {
  opacity: 1;
  transform: translateY(0);
}

.session-warning.fade-out {
  opacity: 0;
  transform: translateY(10px);
}

```

```js
document.addEventListener("DOMContentLoaded", () => {
  const warning = document.querySelector(".session-warning");

  setTimeout(() => {
    warning.classList.add("visible");
  }, 100);

  setTimeout(() => {
    warning.classList.add("fade-out");
  }, 8000);

  warning.addEventListener("transitionend", () => {
    if (warning.classList.contains("fade-out")) {
      warning.remove();
    }
  });
});

```

:::

下一个按优先级排序的值是 `polite`。

这个值意味着更新不紧急，因此屏幕阅读器可以等到当前公告完成或用户停止输入后再宣布更新。大多数实时区域将使用 `polite` 值。

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css">

<div class="upload-success" aria-live="polite">
  <p>文件上传成功</p>
</div>

<script src="index.js"></script>

```

```css
.upload-success {
  background-color: #4caf50;
  color: #fff;
  font-family: system-ui, sans-serif;
  font-weight: 500;
  padding: 1em 1.5em;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 0.4s ease, transform 0.4s ease;
}

.upload-success.visible {
  opacity: 1;
  transform: translateY(0);
}

.upload-success.fade-out {
  opacity: 0;
  transform: translateY(-10px);
}

```

```js
document.addEventListener("DOMContentLoaded", () => {
  const success = document.querySelector(".upload-success");

  setTimeout(() => {
    success.classList.add("visible");
  }, 100);

  setTimeout(() => {
    success.classList.add("fade-out");
  }, 8000);

  success.addEventListener("transitionend", () => {
    if (success.classList.contains("fade-out")) {
      success.remove();
    }
  });
});

```

:::

`aria-live` 的最低优先级值是 `off`，这意味着除非内容在当前具有键盘焦点的元素中，否则不会宣布更新。实际上，这个值几乎从不使用，因为用例非常狭窄，并且它在屏幕阅读器中的一致性实现（如果有的话）很差。如果你需要实时区域，计划对除了需要 `assertive` 的关键消息外的所有内容使用 `polite`。

还需要注意的是，如果更新信息包含在具有 `alert`、`log`、`marquee`、`status` 或 `timer` ARIA 角色的元素中，则不需要 `aria-live` 属性，因为这些角色已经有默认的 `aria-live` 值。但可以通过在元素上显式设置 `aria-live` 来更改默认值。

选择正确的 `aria-live` 值取决于更新信息的优先级。

如果更新是紧急的，你应该使用 `assertive` 立即通知用户。但你应该只在更新真正紧急时使用它，因为突然的中断可能会使用户迷失方向并影响用户体验。

如果更新可以等到当前任务完成，你应该使用 `polite` 代替。

`aria-live` 属性让辅助技术知道网页上的内容何时在动态变化。这帮助残疾用户了解重要公告和更新。

通过适当使用 `aria-live`，你可以确保用户根据其优先级了解这些更新。

# --questions--

## --text--

`aria-live` 属性的主要目的是什么？

## --answers--

定义元素的视觉外观。

### --feedback--

想想 `aria-live` 如何帮助辅助技术理解内容。

---

提高网站性能。

### --feedback--

想想 `aria-live` 如何帮助辅助技术理解内容。

---

指示元素的内容正在动态变化。

---

增强浏览器兼容性。

### --feedback--

想想 `aria-live` 如何帮助辅助技术理解内容。

## --video-solution--

3

## --text--

以下哪个值可以用于 `aria-live` 属性？

## --answers--

`true`, `false`, `off`。

### --feedback--

想想宣布动态内容更改的不同紧急级别。

---

`visible`, `hidden`, `off`。

### --feedback--

想想宣布动态内容更改的不同紧急级别。

---

`assertive`, `polite`, `off`。

---

`open`, `closed`, `off`。

### --feedback--

想想宣布动态内容更改的不同紧急级别。

## --video-solution--

3

## --text--

`aria-live` 属性的 `polite` 和 `assertive` 值有什么区别？

## --answers--

`polite` 立即宣布更新，而 `assertive` 在焦点在另一个元素上时宣布更新。

### --feedback--

想想宣布动态内容的紧急级别。

---

`polite` 在当前任务完成后宣布更新，而 `assertive` 立即宣布更新。

---

`polite` 和 `assertive` 之间没有区别。

### --feedback--

想想宣布动态内容的紧急级别。

---

`polite` 用于重要更新，而 `assertive` 用于不太紧急的更新。

### --feedback--

想想宣布动态内容的紧急级别。

## --video-solution--

2