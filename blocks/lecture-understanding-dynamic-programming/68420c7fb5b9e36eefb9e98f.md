---
id: 68420c7fb5b9e36eefb9e98f
title: 什么是动态规划，有哪些常见算法？
challengeType: 19
dashedName: what-is-dynamic-programming-and-what-are-some-common-algorithms
---

# --description--

动态规划是一种算法技术，通过将复杂问题分解为更简单的子问题并存储结果来避免重复计算，从而解决复杂问题。这种方法将通常需要指数时间的问题转化为可以在多项式时间内解决的问题。

## 动态规划的核心原理

动态规划在问题中存在两个关键条件时起作用。

- **重叠子问题**：在解决较大问题时，相同的较小问题会多次出现。我们不是重复计算这些子问题，而是存储它们的解决方案。

- **最优子结构**：问题的最优解包含其子问题的最优解。这意味着我们可以通过组合较小部分的最优解来构建最佳解决方案。

让我们使用经典的"爬楼梯"问题来检验这些概念。

## 天真递归的问题

考虑爬楼梯问题：你正在爬一个有`n`级台阶的楼梯，每次可以爬1级或2级台阶。有多少种不同的方式可以到达顶部？

```python
def climb_stairs_recursive(n):
    """递归方法"""
    if n <= 2:
        return n  # 基本情况：1级台阶有1种方式，2级台阶有2种方式
    # 要到达第n级台阶，我们可以从第(n-1)级或第(n-2)级台阶来
    return climb_stairs_recursive(n-1) + climb_stairs_recursive(n-2)
```

由于大量的重复计算，这种实现具有指数时间复杂度。当计算`climb_stairs(5)`时，会发生以下情况：

- `climb_stairs(5)`调用`climb_stairs(4)`和`climb_stairs(3)`

- `climb_stairs(4)`调用`climb_stairs(3)`和`climb_stairs(2)`

- 现在`climb_stairs(3)`被计算了**两次**

- `climb_stairs(3)`调用`climb_stairs(2)`和`climb_stairs(1)`

- `climb_stairs(2)`总共被计算了**3次**

对于仅仅`n=5`，我们进行了9次函数调用，而实际上只需要5次唯一计算。随着`n`的增长，这种冗余会呈指数级爆炸增长 - `climb_stairs(30)`需要超过10亿次函数调用！时间复杂度变为`O(2^n)`，使得对于较大的`n`值来说效率低下且不实用。

## 动态规划解决方案

动态规划通过两种主要方法消除这种重复计算：

### 记忆化（自顶向下方法）

记忆化存储昂贵函数调用的结果，并在相同输入再次出现时返回缓存的结果：

```python
def climb_stairs_memo(n, memo={}):
    """使用记忆化的动态规划"""
    # 检查我们是否已经计算过这个值
    if n in memo:
        return memo[n]  # 返回缓存结果 - O(1)查找！

    # 基本情况
    if n <= 2:
        return n

    # 计算一次并存储在memo中供将来使用
    memo[n] = climb_stairs_memo(n-1, memo) + climb_stairs_memo(n-2, memo)
    return memo[n]
```

记忆化之所以效率更高，是因为从`1`到`n`的每个唯一值只计算一次。当我们再次需要`climb_stairs(3)`时，不是重新计算它（这会触发更多递归调用），而是简单地在我们的memo字典中以`O(1)`时间查找它。

让我们通过自顶向下方法跟踪`climb_stairs(5)`的执行，看看记忆化如何消除重复工作：

```md
调用: climb_stairs_memo(5)
  memo = {} (空)

  调用: climb_stairs_memo(4) 
    memo = {} (空)

    调用: climb_stairs_memo(3)
      memo = {} (空)

      调用: climb_stairs_memo(2) → 返回 2 (基本情况)
      调用: climb_stairs_memo(1) → 返回 1 (基本情况)

      结果: 2 + 1 = 3
      memo = {3: 3} (已存储！)

    调用: climb_stairs_memo(2) → 返回 2 (基本情况)

    结果: 3 + 2 = 5
    memo = {3: 3, 4: 5} (已存储！)

  调用: climb_stairs_memo(3) → 返回 3 (来自MEMO - 无递归！)

  结果: 5 + 3 = 8
  memo = {3: 3, 4: 5, 5: 8}
```

**效率比较**

- **天真正归**: 进行9次函数调用并重复计算

- **记忆化**: 只进行5次唯一计算，然后重用存储的结果

- **时间复杂度**: 从`O(2^n)`减少到`O(n)`，因为我们只进行`n`次唯一计算

- **空间复杂度**: `O(n)`用于memo存储和调用栈

- **实际影响**: `climb_stairs(30)`从10多亿次调用减少到仅30次调用！

### 制表法（自底向上方法）

制表法从底层开始构建解决方案，用子问题的解决方案填充表格：

```python
def climb_stairs_tabulation(n):
    """使用制表法的动态规划"""
    if n <= 2:
        return n

    # 创建数组来存储从0到n的所有步骤的结果
    dp = [0] * (n + 1)
    dp[1] = 1  # 到达第1级台阶有1种方式
    dp[2] = 2  # 到达第2级台阶有2种方式

    # 迭代地构建解决方案
    for i in range(3, n + 1):
        # 到达第i级台阶的方式 = 到达(i-1)的方式 + 到达(i-2)的方式
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]
```

制表法通过从最小的子问题向上迭代地构建解决方案，完全消除了递归。

让我们看看自底向上方法的实际操作，看看我们如何系统地构建解决方案。以下是`climb_stairs(5)`的迭代构建过程：

```md
初始状态:
dp = [0, 1, 2, 0, 0, 0]
     [0, 1, 2, 3, 4, 5] ← 索引(台阶数)

逐步构建:

i = 3:
  dp[3] = dp[2] + dp[1] = 2 + 1 = 3
  dp = [0, 1, 2, 3, 0, 0]

i = 4:
  dp[4] = dp[3] + dp[2] = 3 + 2 = 5
  dp = [0, 1, 2, 3, 5, 0]

i = 5:
  dp[5] = dp[4] + dp[3] = 5 + 3 = 8
  dp = [0, 1, 2, 3, 5, 8]

最终结果: dp[5] = 8
```

**制表法的关键优势**

- **无递归开销**: 与记忆化不同，没有递归调用栈。

- **可预测的执行**: 我们按预定顺序计算值(1, 2, 3, 4, 5...)。

- **缓存友好**: 顺序数组访问优化了内存使用。

- **易于优化**: 可以将空间复杂度减少到`O(1)`，因为我们只需要最后两个值。

```python
def climb_stairs_optimized(n):
    if n <= 2:
        return n

    prev2, prev1 = 1, 2  # 只存储最后两个值
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2, prev1 = prev1, current
    return prev1
```

**效率比较**

- **天真正归**: `n=5`时9次函数调用，指数级增长。

- **制表法**: `n=5`时3次简单加法，线性增长。

- **时间复杂度**: `O(n)`而不是`O(2^n)`。

- **空间复杂度**: 数组为`O(n)`，优化后为`O(1)`。

- **可预测的性能**: 对于大的输入不会出现栈溢出的风险。

两种方法都将时间复杂度从指数级`O(2^n)`减少到线性`O(n)`，这是一个巨大的改进，使得在毫秒内解决问题与等待数年解决更大输入之间的区别。

## 实际应用

动态规划在计算机科学及其他领域有广泛的应用：

- **路线优化**: GPS系统使用动态规划算法来查找位置之间的最短路径。

- **文本处理**: 拼写检查器和自动完成功能经常依赖动态规划来计算单词之间的编辑距离。

- **金融建模**: 投资策略和投资组合优化经常使用动态规划技术。

- **资源分配**: 背包问题及其变体出现在调度、预算和资源管理中。

## 实际示例：硬币找零问题

硬币找零问题是经典的编码挑战，当使用动态规划解决时，展示了DP的两个关键原理：最优子结构和重叠子问题。

硬币找零问题问："制作目标金额所需的最少硬币数量是多少？"

以下是使用动态规划的一种解决方案：

```python
def min_coins(amount, coins):
    """找到制作给定金额所需的最少硬币数量"""
    # 用"无穷大"初始化dp数组 - 表示无法制作
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # 基本情况：金额0需要0个硬币

    # 对于从1到目标金额的每个金额
    for i in range(1, amount + 1):
        # 尝试每种硬币面额
        for coin in coins:
            if coin <= i:  # 只有当硬币不超过当前金额时才能使用
                # 更新最小值：当前最小值 vs (剩余金额的硬币数 + 1)
                dp[i] = min(dp[i], dp[i - coin] + 1)

    # 如果可能返回结果，否则返回-1
    return dp[amount] if dp[amount] != float('inf') else -1

# 示例用法:
# coins = [1, 3, 4], amount = 6
# dp[6] = min(dp[5]+1, dp[3]+1, dp[2]+1) = min(3+1, 1+1, 2+1) = 2
# 结果: 2个硬币 (3 + 3)
```

以下是动态规划硬币找零算法如何为`coins = [1, 3, 4]`, `amount = 6`逐步工作：

```md
初始状态:
dp = [0, ∞, ∞, ∞, ∞, ∞, ∞]
     [0, 1, 2, 3, 4, 5, 6] ← 金额

构建解决方案:

对于金额 = 1:
  尝试硬币 1: dp[1] = min(∞, dp[0] + 1) = min(∞, 0 + 1) = 1
  dp = [0, 1, ∞, ∞, ∞, ∞, ∞]

对于金额 = 2:
  尝试硬币 1: dp[2] = min(∞, dp[1] + 1) = min(∞, 1 + 1) = 2
  dp = [0, 1, 2, ∞, ∞, ∞, ∞]

对于金额 = 3:
  尝试硬币 1: dp[3] = min(∞, dp[2] + 1) = min(∞, 2 + 1) = 3
  尝试硬币 3: dp[3] = min(3, dp[0] + 1) = min(3, 0 + 1) = 1
  dp = [0, 1, 2, 1, ∞, ∞, ∞]

对于金额 = 4:
  尝试硬币 1: dp[4] = min(∞, dp[3] + 1) = min(∞, 1 + 1) = 2
  尝试硬币 3: dp[4] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  尝试硬币 4: dp[4] = min(2, dp[0] + 1) = min(2, 0 + 1) = 1
  dp = [0, 1, 2, 1, 1, ∞, ∞]

对于金额 = 5:
  尝试硬币 1: dp[5] = min(∞, dp[4] + 1) = min(∞, 1 + 1) = 2
  尝试硬币 3: dp[5] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  尝试硬币 4: dp[5] = min(2, dp[1] + 1) = min(2, 1 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, ∞]

对于金额 = 6:
  尝试硬币 1: dp[6] = min(∞, dp[5] + 1) = min(∞, 2 + 1) = 3
  尝试硬币 3: dp[6] = min(3, dp[3] + 1) = min(3, 1 + 1) = 2
  尝试硬币 4: dp[6] = min(2, dp[2] + 1) = min(2, 2 + 1) = 2
  dp = [0, 1, 2, 1, 1, 2, 2]

最终结果: dp[6] = 2 (用硬币 3 + 3 实现)
```

这个解决方案展示了动态规划的两个关键原理。它具有重叠子问题，因为找到金额6的最少硬币需要知道金额5、3和2的解决方案。在计算其他金额时会出现这些相同的子问题。它具有最优子结构，因为任何金额的最优解决方案都包含较小金额的最优解决方案。如果我们知道金额3的最少硬币是1，那么制作金额6的一种方法是使用该解决方案再加上一个价值3的硬币。

没有DP，我们需要尝试硬币的每种可能组合 - 指数级的可能性。使用DP，我们系统地构建解决方案：

- **时间复杂度**: `O(金额 × 硬币数量)`而不是指数级。

- **空间复杂度**: `O(金额)`用于`dp`数组。

- **无重复工作**: 每个子问题(找到每个金额的最少硬币)只解决一次。

- **可重用结果**: 一旦我们知道金额3的最少硬币，我们就在所有能从中受益的较大金额中使用这个知识。

## 何时使用动态规划

动态规划在以下情况下有效：

- 问题可以分解为重叠子问题。

- 问题表现出最优子结构。

- 天真的递归解决方案会涉及重复计算。

- 你需要以空间复杂度为代价来优化时间复杂度。

常见的动态规划模式包括优化问题(寻找最小/最大值)、计数问题(实现某事的方式数量)和可以分解为较小决策的决策问题。

动态规划通过系统地存储和重用子问题的解决方案，将复杂问题转化为可管理的问题。理解这种技术为高效解决各种计算挑战打开了大门。

# --questions--

## --text--

动态规划适用的两个关键条件是什么？

## --answers--

快速执行和低内存使用。

### --feedback--

想想什么使问题适合动态规划优化。

---

重叠子问题和最优子结构。

---

递归调用和迭代循环。

### --feedback--

想想什么使问题适合动态规划优化。

---

记忆化和制表法。

### --feedback--

想想什么使问题适合动态规划优化。

## --video-solution--

2

## --text--

动态规划中记忆化和制表法方法的主要区别是什么？

## --answers--

记忆化比制表法使用更多内存。

### --feedback--

考虑每种方法构建解决方案的方向。

---

制表法总是比记忆化更快。

### --feedback--

考虑每种方法构建解决方案的方向。

---

记忆化是自顶向下，而制表法是自底向上。

---

记忆化只适用于递归函数。

### --feedback--

考虑每种方法构建解决方案的方向。

## --video-solution--

3

## --text--

在天真的递归爬楼梯实现中，时间复杂度是什么，为什么它效率低下？

## --answers--

`O(n)`因为它只计算每个步骤一次。

### --feedback--

想想在递归树中相同的楼梯计数被计算了多少次。

---

`O(n²)`因为它使用嵌套循环。

### --feedback--

想想在递归树中相同的楼梯计数被计算了多少次。

---

`O(2^n)`因为它多次重新计算相同的子问题。

---

`O(log n)`因为它将问题一分为二。

### --feedback--

想想在递归树中相同的楼梯计数被计算了多少次。

## --video-solution--

3