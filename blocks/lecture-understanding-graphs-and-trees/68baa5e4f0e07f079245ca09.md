---
id: 68baa5e4f0e07f079245ca09
title: 矩阵和邻接表是如何工作的？
challengeType: 19
dashedName: how-do-matrices-and-adjacency-lists-work
---

# --description--

图是非常强大的数据结构，由一组节点(也称为顶点)和连接它们的边组成。

在代码中实现图有两种常见方法：

* 邻接矩阵

* 邻接列表

让我们更深入地了解这些方法，并讨论它们的优势和局限性。

## 邻接矩阵

我们从邻接矩阵开始。

邻接矩阵是一个二维列表，其中行和列代表图的顶点。

矩阵中的值代表节点之间的边或连接。

例如，如果你有一个存储在名为`matrix`的变量中的矩阵，存储在`matrix[i][j]`中的值，其中`i`是行，`j`是列，代表节点`i`和节点`j`之间的边或连接。

这些值可能有不同的含义，取决于图是有权图还是无权图：

* 如果图是无权的，值为`1`意味着这些节点之间有边连接，而值为`0`意味着它们之间没有边。

* 如果图是有权的，该值将代表连接节点的边的权重。

使用邻接矩阵的一个巨大优势是检查两个节点之间是否有边需要常数时间`O(1)`。这是因为程序只需要在二维列表中找到那个特定值。

然而，这种查找边的效率是有代价的。邻接矩阵有很大的二次空间需求`O(V²)`，其中`V`是图中节点的数量。

这对于稀疏图(只有少数边的图)来说是低效的。为什么？因为如果图是稀疏的，你将在矩阵中存储许多0来表示节点之间缺乏边，而这些0仍然会占用内存空间。

邻接矩阵在查找节点的邻居方面也是低效的，因为程序必须遍历整行或整列来找到代表边的0和1。在最坏的情况下，这个过程可能需要O(V)时间，其中V是图中节点的数量。

让我们看看这个特定图的邻接矩阵示例：

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="一个有四个节点标记为A、B、C和D的图。节点A连接到B、C和D。节点B连接到A和D。节点C连接到A。节点D连接到A和B。" />

在邻接矩阵中：

* 每一行代表一个节点。第一行代表节点A，第二行代表节点B，以此类推。

* 每一列也代表一个节点。

* 矩阵中的每个值代表每对节点之间是否有边。值为0意味着这些节点之间没有边连接，而值为1意味着有边。

对角线上的值代表每个节点是否有自环，即连接节点本身的边。在我们的例子中，它们都是0，因为图没有任何自环。

这是邻接矩阵的可视化表示，向你展示行和列如何代表相应的节点。

例如，第一行是`[0, 1, 1, 1]`，因为节点A有边连接到节点B、C和D：

```markdown
#      A  B  C  D
# A   [0, 1, 1, 1],
# B   [1, 0, 0, 1],
# C   [1, 0, 0, 0],
# D   [1, 1, 0, 0]
```

这是相同的邻接矩阵，但在Python代码中实现：

```python
adjacency_matrix = [
    [0, 1, 1, 1],  # A的邻居是B、C和D
    [1, 0, 0, 1],  # B的邻居是A和D
    [1, 0, 0, 0],  # C的唯一邻居是A
    [1, 1, 0, 0]   # D的邻居是A和B
]
```

## 邻接列表

表示图的另一种常见方法是使用邻接列表。

邻接列表是一个数组或字典，存储每个节点的所有邻居。

有两种方法可以实现邻接列表：

* 作为数组，其中每个索引代表一个节点，存储在该索引处的列表包含其邻居。

* 作为字典，其中每个键代表一个节点，与该键关联的值(一个列表)包含其邻居。

在空间需求方面，邻接列表比邻接矩阵更高效。它们具有`O(V + E)`的空间复杂度，其中`V`是顶点(节点)的数量，`E`是边的数量。

查找所有邻居节点也很高效，因为此操作只需要访问与节点关联的列表。

然而，也有一个权衡。

邻接列表在确定两个节点之间是否有边方面不如邻接矩阵高效。

在最坏的情况下，搜索过程可能需要`O(V)`时间，因为如果节点连接到图中的所有其他节点，它可能必须搜索一个很长的邻居列表。

这是该图的邻接列表示例：

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-matrices-and-adjacency-lists-work-1.png" alt="一个有四个节点标记为A、B、C和D的图。节点A连接到B、C和D。节点B连接到A和D。节点C连接到A。节点D连接到A和B。这是与之前相同的图像。" />

这个邻接列表实现为字典。字典中的每个键代表一个节点，与该键关联的值是包含相应节点所有邻居的列表：

```python
adjacency_list = {
    'A': ['B', 'C', 'D'],
    'B': ['A', 'D'],
    'C': ['A'],
    'D': ['A', 'B']
}
```

或者，我们可以将其实现为二维列表，其中每个索引代表一个节点。例如，索引0代表节点A，索引1代表节点B，以此类推：

```python
adjacency_list = [
    ['B', 'C', 'D'],  # A的邻居(索引0)
    ['A', 'D'],       # B的邻居(索引1)
    ['A'],            # C的邻居(索引2)
    ['A', 'B']        # D的邻居(索引3)
]
```

请注意，即使这个二维列表可能看起来与邻接矩阵相似，它们是相当不同的。

* 邻接矩阵存储0、1或其他代表图中边或边权重的值。

* 邻接列表存储每个节点的所有邻居的实际列表。

这是你应该熟悉的一个非常重要的区别。

邻接矩阵和邻接列表对于实现图都是非常重要的。在它们之间选择取决于图的大小以及你需要如何使用数据。邻接矩阵对有许多边的密集图很有帮助，而邻接列表通常是现实世界场景中的首选，因为在这些场景中稀疏图更常见。

# --questions--

## --text--

在以下哪种情况下，邻接矩阵是表示图的最有效选择？

## --answers--

一个有数十亿人且每人连接很少的社交网络。

### --feedback--

想想矩阵使用多少内存以及这如何根据连接数而变化。

---

一个只有五个连接的计算机网络。

### --feedback--

想想矩阵使用多少内存以及这如何根据连接数而变化。

---

一个密集图，其中每个节点都连接到大多数其他节点。

---

一个主要操作是查找特定节点的所有邻居的图。

### --feedback--

想想矩阵使用多少内存以及这如何根据连接数而变化。

## --video-solution--

3

## --text--

什么时候使用邻接列表比邻接矩阵更高效？

## --answers--

当图是密集的且有许多边时。

### --feedback--

想想当图连接不太紧密时，邻接列表如何节省内存。

---

当你需要非常快速地检查两个节点之间是否存在边时。

### --feedback--

想想当图连接不太紧密时，邻接列表如何节省内存。

---

当图有大量顶点和许多连接时。

### --feedback--

想想当图连接不太紧密时，邻接列表如何节省内存。

---

当图是稀疏的，有大量顶点和少量边时。

## --video-solution--

4

## --text--

与邻接列表相比，以下哪种操作在邻接矩阵中更快？

## --answers--

查找单个节点的所有邻居。

### --feedback--

想想你如何在网格和基于列表的结构中执行这些操作。

---

检查两个特定节点之间是否存在直接边。

---

遍历图中的所有节点。

### --feedback--

想想你如何在网格和基于列表的结构中执行这些操作。

---

向图中添加新节点。

### --feedback--

想想你如何在网格和基于列表的结构中执行这些操作。

## --video-solution--

2