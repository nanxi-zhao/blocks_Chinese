---
id: 68baa5e4f0e07f079245ca0b
title: 优先队列和堆是如何工作的？
challengeType: 19
dashedName: how-do-priority-queues-and-heaps-work
---

# --description--

**优先队列**是一种抽象数据类型(ADT)，其工作方式与队列或堆栈类似，但有一个关键区别。

正如你可能已经知道的，标准队列遵循FIFO(先进先出)方法，其中第一个添加到队列中的元素是第一个从队列中移除的元素。

堆栈遵循LIFO(后进先出)方法，其中最后一个添加到堆栈中的元素是第一个从堆栈中移除的元素。

队列和堆栈只考虑元素的插入顺序。

然而，优先队列考虑元素的"优先级"。优先级用于确定应该下一个移除哪个元素。

通常，优先级最高的元素首先被移除，但一些实现也可能选择首先移除优先级最低的元素。这将取决于你程序的要求。

优先队列对于实际应用非常有帮助，比如找到两个位置之间的最短路径、在操作系统中调度任务、模拟交通、压缩数据和管理网络。

在实践中，优先队列通常使用堆数据结构来实现。

**堆**是一种具有非常特定属性(称为**堆属性**)的树数据结构。此属性根据堆的类型确定每个节点与其子节点之间的关系。

有两种主要类型的堆：

* 最大堆

* 最小堆

在**最大堆**中，每个节点的值大于或等于其子节点的值。

在这个例子中，你可以看到一个具有节点8、7、5、2和1的树结构。注意节点7大于节点2和节点1，遵循堆属性。这对所有其他节点也是如此。

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-1.png" alt="最大堆树结构，显示根节点值为8，8的子节点为7和5，7的子节点为2和1，演示每个父节点都大于其子节点。" />

相比之下，在**最小堆**中，每个节点的值小于或等于其子节点的值。

在这个例子中，我们有值为4、7、9、12和15的节点。例如，节点7小于节点12和节点15，遵循堆属性。这对所有其他节点也是如此。

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-priority-queues-and-heaps-work-2.png" alt="最小堆树结构，显示根节点值为4，4的子节点为7和9，7的子节点为12和15，演示每个父节点都小于其子节点。" />

堆属性很关键，因为它确保最大(或最小)元素(取决于堆的类型)始终保持在顶部，这使得移除变得非常容易。

在实践中，堆通常实现为数组，以高效访问父节点和子节点。

使用数组简化了访问这些值或"节点"的逻辑，因为在幕后，如果堆保持完整二叉树的结构，数组实现只需要基于索引的简单数学运算来找到元素在内存中的位置。

Python有一个内置的`heapq`模块，你可以用来处理最小堆的实现。

它通过直接在Python列表上操作来工作，遵循特定步骤，将元素视为列表是堆一样，保持堆属性。

要使用此模块，你只需要导入它：

```python
import heapq
```

然后，你需要定义一个空列表。这将是堆的底层数据结构：

```python
my_heap = []
```

要向堆中添加元素，你可以调用`heappush()`，传递堆的名称和你想要添加的元素作为参数。这将自动将元素添加到列表中应该在的位置，以保持堆属性：

```python
heapq.heappush(my_heap, 9)
```

要获取优先级最低的元素(在这种情况下，是最小值)，你可以调用`heappop()`：

```python
heapq.heappop(my_heap)
```

`heappushpop()`将两个操作合并为一个调用。

这比分别按顺序调用它们更高效，特别是当堆很大时，因为它只执行一次"堆化"操作来重新排列列表作为堆：

```python
heapq.heappushpop(my_heap, 15)
```

如果你已经有一个列表并且想要将其转换为堆，你可以调用`heapify()`，传递堆作为参数：

```python
heapq.heapify(my_heap)
```

但是目前，我们是按它们的值对元素进行排序，对吧？

如果我们想按它们的"优先级"排序呢？

你可以通过存储具有此结构的元组来实现：`(priority, element)`。

由于元组从左到右逐元素比较，优先级将首先被比较，并且决策将基于它们。

请注意，在这种情况下，较低的值代表较高的优先级。这意味着优先级为1的元组将比优先级为3的元组具有**更高**的优先级：

```python
my_heap = []

heapq.heappush(my_heap, (3, "A"))
heapq.heappush(my_heap, (2, "B"))
heapq.heappush(my_heap, (1, "C"))
```

如果你需要具有相同优先级的元素按插入顺序被移除，你可以考虑在元组中包含一个唯一计数器作为第二个元素来打破平局，像这样`(priority, counter, element)`。

现在让我们谈谈堆的效率。

插入和从堆中提取最小或最大值(取决于堆的类型)的平均和最坏情况时间复杂度是对数的，`O(log n)`，因为所需的交换次数通常与堆的高度成比例，即log(n)。

"查看"操作的平均和最坏情况时间复杂度是常数时间，O(1)。查看涉及获取最小或最大值(取决于堆的类型)而不移除它。

"堆化"操作，即从无序列表构建堆，在平均和最坏情况下具有线性时间复杂度，O(n)。

同样，搜索和删除任意元素的平均和最坏情况时间复杂度都是O(n)，因为它们可能需要遍历整个堆。

它们需要多少空间？

堆的空间复杂度是线性的，O(n)，其中`n`是它包含的元素数量。它只需要存储元素和列表对象本身的少量额外开销。

优先队列和堆在计算机科学中非常重要。它们让你快速找到并使用列表中最重要的元素。这种效率对于执行关键现实世界任务的许多计算机程序至关重要，比如在地图上找到最快的路线。

# --questions--

## --text--

区分优先队列与标准队列或堆栈的主要特征是什么？

## --answers--

它允许通过索引访问元素。

### --feedback--

想想决定下一个移除哪个元素的主要因素。

---

它总是按插入顺序处理元素。

### --feedback--

想想决定下一个移除哪个元素的主要因素。

---

它根据分配的优先级检索元素。

---

它只存储相同数据类型的元素。

### --feedback--

想想决定下一个移除哪个元素的主要因素。

## --video-solution--

3

## --text--

以下哪项是优先队列会有帮助的常见现实世界应用？

## --answers--

在操作系统中调度任务，其中一些任务更紧急。

---

管理播放列表，其中歌曲按固定顺序播放。

### --feedback--

想想一些项目更重要且需要首先处理的场景。

---

存储杂货项目列表。

### --feedback--

想想一些项目更重要且需要首先处理的场景。

---

按字母顺序跟踪客户姓名。

### --feedback--

想想一些项目更重要且需要首先处理的场景。

## --video-solution--

1

## --text--

尽管堆在概念上被设想为树，但为什么在实践中通常将堆实现为数组的主要原因是什么？

## --answers--

数组总是比任何其他数据结构都快。

### --feedback--

想想堆的树状结构如何能高效地映射到线性数据结构。

---

数组使用数学公式简化了访问父节点和子节点的逻辑。

---

数组允许直接随机访问任何元素，这是堆的核心操作。

### --feedback--

想想堆的树状结构如何能高效地映射到线性数据结构。

---

数组是唯一能保证堆属性的数据结构。

### --feedback--

想想堆的树状结构如何能高效地映射到线性数据结构。

## --video-solution--

2