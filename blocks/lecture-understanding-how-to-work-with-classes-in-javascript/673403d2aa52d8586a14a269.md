---
id: 673403d2aa52d8586a14a269
title: 什么是类继承，它是如何工作的？
challengeType: 19
dashedName: what-is-class-inheritance-and-how-does-it-work
---

# --description--

让我们来学习继承以及它在JavaScript中是如何工作的。

在编程中，继承允许你定义从其他类继承属性和方法的类。

例如，[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)是[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的一种类型，所以你可以定义一个[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类，包含所有类型车辆共有的最一般属性和方法，然后定义一个[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类，继承[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的属性和方法。

这种"是一种"的关系是继承的特征。在这个例子中，[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)是[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的一种更专门的形式。

有两个主要概念你需要了解才能开始使用继承：父类和子类。

父类是作为其他类蓝图的类。它定义了被其他类继承的属性和方法。

子类是继承另一个类属性和方法的类。子类还可以通过添加新属性和方法来扩展其父类的功能。

在我们之前的例子中，[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)将是[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的父类，而[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类将是[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的子类。

一个父类可以有多个子类。

在JavaScript中，我们使用[extends](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)关键字来实现继承。这个关键字表示一个类是另一个类的子类。

在这个例子中，我们只有类定义的前几行，你可以看到[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类扩展了[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类，所以[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)继承自[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)。

```js
class Vehicle {
  // Implementation of Vehicle...
}

class Car extends Vehicle {
  // Implementation of Car...
}
```

假设[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类有两个属性：[brand](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L49-L49)和[year](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L50-L50)。你可以在更新的代码中看到这一点。

[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)有一个名为[honk](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L55-L57)的方法。但是，注意[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类没有自己的构造函数。让我们看看它是否继承了这些属性。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  honk() {
    console.log("Honk! Honk!");
  }
}
```

要定义[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的实例，你需要传递两个参数：[brand](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L49-L49)和[year](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L50-L50)。在这种情况下，品牌是`MasterPuti Motors`，年份是`2019`。

```js
let myCar = new Car("MasterPuti Motors", 2019);
```

如果你尝试使用点符号访问这些属性并调用方法：

```js
console.log(myCar.brand);
console.log(myCar.year);
myCar.honk();
```

输出如下：

```js
MasterPuti Motors
2019
Honk! Honk!
```

确实，输出是正确的，所以这些属性和方法在[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)实例中被定义，你通过从[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类继承这些属性，为自己节省了大量重复代码。

在这个例子中，子类没有任何额外的属性。这就是为什么类没有构造函数，只有一个方法。

如果你确实需要添加额外的属性，你需要定义一个构造函数。

让我们看一个例子。

```js
class Vehicle {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}

class Car extends Vehicle {
  constructor(brand, year, numDoors) {
    super(brand, year);
    this.numDoors = numDoors;
  }
}
```

这次，我们将在[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)子类中添加一个[numDoors](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L103-L103)属性。

你可以看到现在这个类在更新的代码中有构造函数。在构造函数中，有一个对[super()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)的调用，传递参数[brand](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L49-L49)和[year](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L50-L50)。

[super()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)调用超类的构造函数，所以通过使用[super(brand, year)](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)，你实际上是在子类中定义超类的属性。这是你可以使用的另一种术语-超类是父类，子类是子类。

然后，[this.numDoors = numDoors](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L103-L103)这行定义了一个属于[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的新属性，门的数量（[numDoors](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L103-L103)）。

这是扩展[Vehicle](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的一种方式，添加了一个专属于[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)实例的属性。

这是一个可扩展性的例子，是继承的基本优势之一。

现在，如果你创建[Car](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的实例，你会看到它有三个属性：[brand](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L49-L49)、[year](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L50-L50)和[numDoors](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403d2aa52d8586a14a269.md#L103-L103)。在创建实例时，你还需要传递必要的参数。

```js
let myCar = new Car("MasterPuti Motors", 2019, 4);
```

如果你用[console.log()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/console.d.ts#L39-L39)打印这些属性的值：

```js
console.log(myCar.brand);
console.log(myCar.year);
console.log(myCar.numDoors);
```

这是输出：

```js
MasterPuti Motors
2019
4
```

继承的主要优势是代码可重用性、模块化、可扩展性和改进的代码结构。

通过实现层次结构，你可以在子类中重用为父类编写的代码，避免重复。

继承还通过在层次结构中将复杂系统分解为更简单的组件来促进模块化。

此外，能够扩展父类的功能使得适应变化的需求并在开发过程中稍后添加新功能变得更加容易。

最后，层次结构可以使你的代码更容易理解和维护。

这些是继承的基础知识。通过理解继承的工作原理，你可以设计结构良好、可维护和可扩展的面向对象程序。

# --questions--

## --text--

面向对象编程中继承的主要目的是什么？

## --answers--

创建新对象。

### --feedback--

想想继承如何帮助代码重用和组织。

---

为类定义方法。

### --feedback--

想想继承如何帮助代码重用和组织。

---

重用代码并在类之间创建层次关系。

---

封装对象内的数据。

### --feedback--

想想继承如何帮助代码重用和组织。

## --video-solution--

3

## --text--

在JavaScript中用于从父类继承的关键字是什么？

## --answers--

[inherit](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想建立继承关系的关键字。

---

[extends](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

---

[super](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想建立继承关系的关键字。

---

[prototype](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想建立继承关系的关键字。

## --video-solution--

2

## --text--

父类和子类之间有什么区别？

## --answers--

父类是子类的专门版本。

### --feedback--

想想类之间的层次关系。

---

子类是父类的专门版本。

---

父类和子类之间没有区别。

### --feedback--

想想类之间的层次关系。

---

父类总是比子类大。

### --feedback--

想想类之间的层次关系。

## --video-solution--

2