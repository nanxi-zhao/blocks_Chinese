---
id: 68420be9af9d89620af7944a
title: 什么是面向对象编程，封装是如何工作的？
challengeType: 19
dashedName: what-is-object-oriented-programming-and-how-does-encapsulation-work
---

# --description--

面向对象编程，也称为OOP，是一种编程风格，开发人员将代码中的所有内容都视为现实世界中的对象。

类就像创建对象的蓝图。从类创建的每个对象都有定义数据的属性和定义对象行为的方法。

在之前的课程中，你学习了如何创建类。以下是语法的提醒：

```py
class ClassName:
   def __init__(self, parameters):
       attribute = value

   def method_name(self):
       # method logic
```

以下是使用[__init__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)特殊方法初始化品牌和颜色属性的类示例，每当使用该类创建对象时都会初始化这些属性：

```py
class Car:
   def __init__(self, brand, color):
       self.brand = brand
       self.color = color

# 从Car类创建两个对象
car1 = Car('Toyota', 'red')
car2 = Car('Lambo', 'green')

print('Car 1 Brand:', car1.brand) # Car 1 Brand: Toyota
print('Car 1 Color:', car1.color) # Car 1 Color: red

print('Car 2 Brand:', car2.brand) # Car 2 Brand: Lambo
print('Car 2 Color:', car2.color) # Car 2 Color: green
```

面向对象编程有四个关键原则，帮助你有效地组织和管理代码。它们是封装、继承、多态和抽象。

本课程的其余部分将重点介绍封装是如何工作的。

封装是将对象的属性和方法捆绑到一个单一单元（类）中的过程。

通过封装，你可以将对象的内部状态隐藏在一组简单的公共方法和属性后面，这些方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制数据如何变化以及谁可以看到它。

假设你想跟踪钱包余额。你希望允许人们向钱包存钱或从钱包取钱，但没有人应该直接篡改余额。

在这种情况下，你可以将[deposit()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)和[withdraw()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)设为公共方法，并将余额隐藏在[_balance](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68420be9af9d89620af7944a.md#L59-L59)属性下：

```py
class Wallet:
   def __init__(self, balance):
       self._balance = balance # 按约定供内部使用

   def deposit(self, amount):
       if amount > 0:
           self._balance += amount # 安全地增加余额

   def withdraw(self, amount):
       if 0 < amount <= self._balance:
           self._balance -= amount # 安全地减少余额
```

按照约定，用单下划线作为前缀的属性和方法意味着它们是供内部使用的。没有人应该从类外部直接访问它们，因为这违背了封装的原则，可能导致错误。

虽然单下划线前缀只是一个约定，但用双下划线作为前缀的属性和方法实际上可以防止它们从类外部被访问，使这些属性和方法变为私有。

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # 私有属性

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # 安全地增加余额

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # 安全地减少余额

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

要获取[__balance](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68420be9af9d89620af7944a.md#L77-L77)的当前值，你可以定义一个get_balance方法。例如：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount

   def get_balance(self):
       return self.__balance


acct_one = Wallet(100)
acct_one.deposit(50)
print(acct_one.get_balance()) # 150

acct_two = Wallet(450)
acct_two.withdraw(28)
print(acct_two.get_balance()) # 422

acct_two.deposit(150)
print(acct_two.get_balance()) # 572
```

你还可以定义一个私有的[__validate](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68420be9af9d89620af7944a.md#L129-L131)方法来检查每个存款或取款金额是否为正数：

```py
class Wallet:
   def __init__(self):
       self.__balance = 0

   def __validate(self, amount):
       if amount < 0:
           raise ValueError('Amount must be positive')

   def deposit(self, amount):
       self.__validate(amount)
       self.__balance += amount

   def withdraw(self, amount):
       self.__validate(amount)
       if amount > self.__balance:
           raise ValueError('Insufficient funds')
       self.__balance -= amount

   def get_balance(self):
       return self.__balance

acct_one = Wallet()
acct_one.deposit(4) # ValueError('Amount must be positive')
print(acct_one.get_balance()) # 0

acct_one.deposit(50)
print(acct_one.get_balance()) # 50
acct_one.withdraw(-8) # ValueError('Amount must be positive')
acct_one.withdraw(58) # ValueError('Insufficient funds')
```

如你所见，[__validate](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68420be9af9d89620af7944a.md#L129-L131)方法是私有的，在[deposit()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)和[withdraw()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)公共方法中在幕后运行，以确保金额始终有效。

在即将到来的课程中，你将了解更多关于用双下划线作为前缀的属性是如何工作的。

总之，封装将内部数据锁定在清晰的公共方法后面。这就是你保护类免受篡改并将验证集中在一个地方的方式。你可以自由地更新或扩展代码，知道外部代码只接触你暴露的接口。

# --questions--

## --text--

面向对象编程(OOP)的四个关键原则是什么？

## --answers--

封装、继承、多态、抽象

### --feedback--

注意定义OOP中数据和行为如何组织的原则。

---

变量、函数、循环、条件

### --feedback--

注意定义OOP中数据和行为如何组织的原则。

---

类、对象、方法、属性

### --feedback--

注意定义OOP中数据和行为如何组织的原则。

---

公共、私有、受保护、静态

### --feedback--

注意定义OOP中数据和行为如何组织的原则。

## --video-solution--

1

## --text--

为什么直接访问用单下划线作为前缀的属性/方法是不好的做法？

## --answers--

因为如果你尝试这样做，Python会引发语法错误。

### --feedback--

想想封装是如何保护对象内部状态的。

---

因为它违反了封装，允许不受控制的数据访问。

### --feedback--

想想封装是如何保护对象内部状态的。

---

因为私有属性比公共属性访问速度慢。

### --feedback--

想想封装是如何保护对象内部状态的。

---

因为它们只能从子类访问。

### --feedback--

因为它们只能从子类访问。

## --video-solution--

2

## --text--

表示私有属性或方法的方式是什么？

## --answers--

用单下划线作为前缀

### --feedback--

注意用于为私有属性或方法命名前缀的符号。

---

使用前后双下划线

### --feedback--

注意用于为私有属性或方法命名前缀的符号。

---

用双下划线作为前缀

### --feedback--

注意用于为私有属性或方法命名前缀的符号。

---

使用private关键字

### --feedback--

注意用于为私有属性或方法命名前缀的符号。

## --video-solution--

3