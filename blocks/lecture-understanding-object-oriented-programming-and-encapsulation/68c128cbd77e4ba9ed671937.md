---
id: 68c128cbd77e4ba9ed671937
title: 什么是Getter和Setter
challengeType: 19
dashedName: what-are-getters-and-setters
---

# --description--

Getter和Setter是让你控制如何访问和修改类属性的方法。使用Getter你可以检索值，使用Setter你可以设置值。

这些操作是通过所谓的属性来完成的。它们是连接Getter和Setter的东西，允许访问数据。

属性的行为像属性，但在幕后像方法一样工作。可以把它们想象成你像方法一样定义的数据，但像属性一样工作。这意味着你可以使用点符号而不是括号来访问属性。

属性的主要作用是在你使用它们获取、设置或删除值时在幕后运行额外的逻辑。这使得它们成为你想访问或操作对象内数据时的完美选择。

那么为什么要使用属性而不是方法呢？这主要是关于可读性和约定。它们使你的代码更清晰、更易读。

当你使用方法时，你总是必须用括号调用它。但是使用属性时，你可以像访问普通属性一样使用点符号来访问它。这使得你的代码看起来很简单，即使它在幕后做额外的工作。

例如，你可能想要计算一个值或在保存新值之前检查新值是否有效。你可以使用类似属性的方式来做到这一点，而不是为此调用方法。

要创建属性，你需要定义一个方法并在其上方放置@property装饰器。这告诉Python将该方法视为属性。

这让我们转向Getter。以下是使用@property装饰器创建Getter的方法：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # 一个获取半径的Getter
        return self._radius

    @property
    def area(self):  # 一个计算面积的Getter
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

这个例子获取了圆的半径和面积。

注意我们如何在类内部使用[_radius](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c128cbd77e4ba9ed671937.md#L31-L31)而不是radius。下划线是Python中常见的约定，表示属性是私有的。换句话说，它表示这是供内部使用的，不应该从类外部直接访问。

要创建一个Setter来设置半径，例如，你必须定义另一个同名方法并在其上方使用[@<property_name>.setter](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # 一个获取半径的Getter
        return self._radius

    @radius.setter
    def radius(self, value):  # 一个设置半径的Setter
        if value <= 0:
            raise ValueError('Radius must be positive')
        self._radius = value

my_circle = Circle(3)
print('Initial radius:', my_circle.radius) # Initial radius: 3

my_circle.radius = 8
print('After modifying the radius:', my_circle.radius) # After modifying the radius: 8
```

在这个例子中，半径Setter不仅仅是为圆设置半径，它还在运行一个验证，确保半径不是负数。

一旦你定义了Getter和Setter，Python会在你使用正常属性语法时自动在幕后调用它们：

```py
my_circle.radius # 这将调用Getter
my_circle.radius = 4 # 这将调用Setter
```

注意，在Setter内部，你在分配新值时不能使用与属性相同的名称。这是因为[self.radius = value](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c128cbd77e4ba9ed671937.md#L71-L71)会在Setter方法本身内调用Setter，导致无限递归和[RecursionError](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L131-L131)。所以你必须始终使用下划线前缀的形式[self._radius = value](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c128cbd77e4ba9ed671937.md#L66-L66)。

就像你可以通过Getter控制如何访问属性，通过Setter控制如何修改属性一样，你也可以通过Deleter控制如何删除属性。

Deleter在你对属性使用del语句时运行自定义逻辑。要创建一个，你使用[@<property_name>.deleter](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)装饰器：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    # Getter
    @property
    def radius(self):
        return self._radius

    # Setter
    @radius.setter
    def radius(self, value):
        if value <= 0:
            raise ValueError("Radius must be positive")
        self._radius = value

    # Deleter
    @radius.deleter
    def radius(self):
        print("Deleting radius...")
        del self._radius
```

以下是Deleter的使用方法：

```py
# 创建一个带半径的圆形对象
my_circle = Circle(33)
print("Initial radius:", my_circle.radius)  # 33

# 删除半径
# 这会调用Deleter
del my_circle.radius # Deleting radius...
print("Radius deleted!") # Radius deleted!

# 删除后尝试访问半径
try:
    print(my_circle.radius)
except AttributeError as e:
    print("Error:", e) # Error: 'Circle' object has no attribute '_radius'
```

从中得到的要点是：

- Getter让你检索值，甚至即时计算值。
- Setter让你通过在赋值前运行检查来安全地修改值。
- 属性是将这些Getter和Setter连接在一起的东西，这样你就可以在仍然使用点符号的同时编写逻辑。
- Deleter让你定义删除属性时发生的事情。

# --questions--

## --text--

什么让你在获取或设置属性值时在幕后运行逻辑？

## --answers--

导入外部模块。

### --feedback--

想想在读取和写入数据时允许验证或计算的方法。

---

类继承。

### --feedback--

想想在读取和写入数据时允许验证或计算的方法。

---

属性

### --feedback--

想想在读取和写入数据时允许验证或计算的方法。

---

直接属性访问。

### --feedback--

想想在读取和写入数据时允许验证或计算的方法。

## --video-solution--

3

## --text--

什么将Getter和Setter连接在一起，让你在保持点符号访问的同时执行逻辑？

## --answers--

属性

### --feedback--

想想一个让你像使用简单点语法的属性一样使用方法的特性。

---

装饰器

### --feedback--

想想一个让你像使用简单点语法的属性一样使用方法的特性。

---

类继承

### --feedback--

想想一个让你像使用简单点语法的属性一样使用方法的特性。

---

直接方法调用

### --feedback--

想想一个让你像使用简单点语法的属性一样使用方法的特性。

## --video-solution--

1

## --text--

创建属性的Getter和Setter使用哪两个装饰器？

## --answers--

[@getter](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)和[@setter](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想允许方法调用使用简单点符号而无需括号的装饰器。

---

[@attr.get](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)和[@attr.set](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想允许方法调用使用简单点符号而无需括号的装饰器。

---

[@compute](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)和[@assign](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想允许方法调用使用简单点符号而无需括号的装饰器。

---

[@property](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)和[@<property_name>.setter](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)

### --feedback--

想想允许方法调用使用简单点符号而无需括号的装饰器。

## --video-solution--

4