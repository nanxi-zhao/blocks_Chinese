---
id: 68c3bc4ddb7b469fb7d17c28
title: 什么是多态，它是如何促进代码重用的？
challengeType: 19
dashedName: what-is-polymorphism-and-how-does-it-promote-code-reuse
---

# --description--

多态是我们将要讨论的面向对象编程(OOP)的下一个关键概念。

通过多态，你可以访问一个接口，在其中可以与许多相同类型的对象进行交互。

让我们更深入地了解多态以及它如何让你重用代码。

多态允许不同类中的方法共享相同的名称但执行不同的任务。你可以在不同的对象上调用相同的方法名，每个对象都以自己的方式响应。

以下是多态的基本示例：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # 适用于A、B或C
```

以下是使用不同动物声音来描述多态的示例：

```py
class Cat:
   def speak(self):
       return "A cat meow"

class Bird:
   def speak(self):
       return "A bird tweet"

class Monkey:
   def speak(self):
       return "A monkey ooh ooh aah aah ooh ooh aah aah"

def animal_sound(animal):
   print(animal.speak())

animal_sound(Cat())
animal_sound(Bird())
animal_sound(Monkey())
```

在这个例子中，[animal_sound()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68c3bc4ddb7b469fb7d17c28.md#L48-L49)是一个接受任何具有[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)方法的对象的函数。

当你传入[Cat](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)、[Bird](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)或[Monkey](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)时，它会调用对象的[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)方法并打印结果。因为每个类都以不同的方式定义[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)，所以你从同一个函数得到不同的输出。这就是多态的实际应用。

这里是另一个例子，这次使用实例和属性：

```py
class Twitter:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"🐦 Tweet: '{self.content}' (280 chars max)"

class Instagram:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"📸 Instagram Post: '{self.content}' + ✨ filters"

class LinkedIn:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"💼 LinkedIn Article: '{self.content}' (Professional Mode)"

def start(social_media):
   print(social_media.post())  # 在任何对象上调用.post()

# 实例
tweet = Twitter('Just learned Python polymorphism!')
photo = Instagram('Sunset vibes 🌅')
article = LinkedIn('Why OOP matters in 2024')

# 多态调用 - 相同函数，不同输出
start(tweet) # 🐦 Tweet: 'Just learned Python polymorphism!' (280 chars max)
start(photo) # 📸 Instagram Post: 'Sunset vibes 🌅' + ✨ filters
start(article) # 💼 LinkedIn Article: 'Why OOP matters in 2024' (Professional Mode)
```

还有一种称为**基于继承的多态**的多态。

在基于继承的多态中，父类定义一个方法，多个子类以自己的方式重写该方法。然后你可以在任何子对象上调用相同的方法，它会根据它是哪个子类而以不同的方式行为。

以下是一个例子：

```py
class Animal:
   def speak(self):
       return 'Some generic sound'

class Cat(Animal):
   def speak(self):
       return 'A cat meow'

class Dog(Animal):
   def speak(self):
       return 'A dog barks woof woof'

class Monkey(Animal):
   def speak(self):
       return 'A monkey ooh ooh aah aah ooh ooh aah aah'

print(Cat().speak()) # A cat meow
print(Dog().speak()) # A dog barks woof woof
print(Monkey().speak()) # A monkey ooh ooh aah aah ooh ooh aah aah
print(Animal().speak()) # Some generic sound
```

你可以看到，父[Animal](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的每个子类都重写[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)方法以提供自己的实现。所以当你在每个子类的实例上调用[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)方法时，它会返回与该动物相关的特定声音。

你还可以更进一步，在列表中进行调用，然后遍历列表以显示每个[speak()](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)方法返回的内容：

```py
animals = [Cat(), Dog(), Monkey()]

for animal in animals:
   print(animal.speak())

# 输出:
# A cat meow
# A dog barks woof woof
# A monkey ooh ooh aah aah ooh ooh aah aah
```

# --questions--

## --text--

面向对象编程中的多态是什么？

## --answers--

当一个类不能有相同名称的方法时。

### --feedback--

想想"多态"这个词意味着同一动作的"多种形式"。

---

当不同类可以使用相同的方法名但以不同方式实现时。

### --feedback--

想想"多态"这个词意味着同一动作的"多种形式"。

---

当方法在所有类中必须是唯一的时候。

### --feedback--

想想"多态"这个词意味着同一动作的"多种形式"。

---

当子类删除父类的方法时。

### --feedback--

想想"多态"这个词意味着同一动作的"多种形式"。

## --video-solution--

2

## --text--

在基于继承的多态中，子类必须做什么才能提供父类中定义的方法的自己的实现？

## --answers--

通过重新定义具有相同名称的方法来重写该方法。

### --feedback--

想想子类如何在保持相同签名的同时重新定义方法。

---

将方法声明为[@static](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)。

### --feedback--

想想子类如何在保持相同签名的同时重新定义方法。

---

首先删除父方法。

### --feedback--

想想子类如何在保持相同签名的同时重新定义方法。

---

使用[@polymorphic](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)装饰器。

### --feedback--

想想子类如何在保持相同签名的同时重新定义方法。

## --video-solution--

1

## --text--

基于继承的多态的关键好处是什么？

## --answers--

它强制所有子类实现相同的行为。

### --feedback--

注意多态如何让你在不同的子类上调用相同的方法。

---

它阻止子类修改父方法。

### --feedback--

注意多态如何让你在不同的子类上调用相同的方法。

---

它允许在不同的子对象上调用相同的方法名，每个对象执行自己的版本。

### --feedback--

注意多态如何让你在不同的子类上调用相同的方法。

---

它将所有子方法合并到父类中。

### --feedback--

注意多态如何让你在不同的子类上调用相同的方法。

## --video-solution--

3