---
id: 68c3bc80f67363a31791fe1c
title: 什么是抽象，它是如何帮助保持复杂系统有序的？
challengeType: 19
dashedName: what-is-abstraction-and-how-does-it-help-keep-complex-systems-organized
---

# --description--

现在我们已经了解了封装、继承和多态，让我们讨论面向对象编程的下一个关键概念——抽象。

抽象是隐藏复杂实现细节并只显示对象或系统基本特征的过程。可以将其视为关注某事物做什么而不是它如何做。

抽象不仅限于Python。它是一个编程概念，可以在许多支持面向对象编程的语言中实现。

为了说明抽象，想象你正在开车。当你坐在驾驶座上时，你与方向盘、换挡杆以及油门和刹车踏板等基本部件交互。你不需要知道发动机如何工作的复杂细节、变速器如何换挡或制动系统背后的物理原理，因为所有这些都是复杂的实现细节。

这就是抽象在起作用！它为你提供了一个与复杂系统交互的简化接口。

再次以汽车为例，简化接口是方向盘、刹车和油门，而复杂系统是汽车本身。

至于Python如何实现抽象，它是通过[abc](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)模块实现的。

该模块提供了[ABC](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类（代表"抽象基类"）和[@abstractmethod](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)装饰器。

[ABC](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)是 meant to be inherited from的类，但你不能直接从中创建对象。它是定义其子类必须实现的方法和属性的公共接口的类。

另一方面，抽象方法是使用[@abstractmethod](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)装饰器在抽象基类(ABC)中声明的方法。它可能没有实现或只有基本的默认实现。但是，任何子类都必须重写它才能被认为是具体的和可实例化的，即使提供了默认实现。

以下是Python中抽象类的基本语法：

```py
from abc import ABC, abstractmethod

# 定义一个抽象基类
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# 实现抽象方法的具体子类
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassOne')

# 另一个具体子类
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('Implementation in ConcreteClassTwo')
```

以下是一个基本示例：

```py
from abc import ABC, abstractmethod

class Animal(ABC): # 继承自抽象基类
   @abstractmethod # 抽象方法装饰器
   def make_sound(self):  # 子类必须重写的方法
       pass

# 将重写抽象方法的具体类
class Dog(Animal):
   def make_sound(self):
       print('Woof!')

# 另一个将重写抽象方法的具体类
class Cat(Animal):
   def make_sound(self):
       print('Meow!')

# 另一个将重写抽象方法的具体类
class Monkey(Animal):
   def make_sound(self):
       print('Ooh ooh aah aah!')

# 创建每个具体类的实例
animals = [Dog(), Cat(), Monkey()]

# 遍历实例以调用make_sound方法
for animal in animals:
   animal.make_sound()

# 输出:
# Woof!
# Meow!
# Ooh ooh aah aah!
```

在这个例子中：

- 我们从[abc](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)模块导入[ABC](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类和[abstractmethod](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)。
- 然后我们创建一个继承自[ABC](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的[Animal](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类，并在其中创建一个抽象方法[make_sound](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L59-L60)，[Animal](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)的每个子类都必须重写该方法。
- 我们创建具体类[Dog](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)、[Cat](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)和[Monkey](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)，它们必须重写[make_sound](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L59-L60)抽象方法。
- 我们实例化具体类并调用它们的[make_sound](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L59-L60)方法，以展示它们如何以自己的方式实现[make_sound](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L59-L60)抽象方法。

记住你不能创建Animal类的实例。以下是如果你尝试这样做的结果：

```py
dog = Animal() 
# TypeError: Can't instantiate abstract class Animal 
# without an implementation for abstract method 'make_sound'
```

同样的规则适用于不提供抽象方法实现的子类。即使你定义了Animal的子类，你也无法实例化它，直到它重写make_sound。以下是一个显示这一点的示例：

```py
class Bird(Animal):
    pass

bird = Bird()
# TypeError: Can't instantiate abstract class Bird 
# without an implementation for abstract method 'make_sound'
```

这里是另一个示例，这次使用可以传递给具体方法实例的实例属性：

```py
from abc import ABC, abstractmethod

# 任何可以说话的玩具的蓝图
class TalkingToy(ABC):
   def __init__(self, name):
       self.name = name
   @abstractmethod
   def speak(self):
       pass

class RobotToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says beep boop! I am a robot!')

class TeddyBearToy(TalkingToy):
   def speak(self):
       print(f"{self.name} says hug me! I'm cuddly!")

class DinosaurToy(TalkingToy):
   def speak(self):
       print(f'{self.name} says ROOOOAR!')

# 创建玩具
rusty = RobotToy('Rusty')
fluffy = TeddyBearToy('Fluffy')
rex = DinosaurToy('Rex')

toys = [rusty, fluffy, rex]
for toy in toys:
   toy.speak()

# 输出:
# Rusty says beep boop! I am a robot!
# Fluffy says hug me! I'm cuddly!
# Rex says ROOOOAR!
```

在这个例子中：

- 我们有一个抽象基类[TalkingToy](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)，它定义了任何可以说话的玩具的蓝图。
- 子类[RobotToy](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)、[TeddyBearToy](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)和[DinosaurToy](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)以自己的方式实现[speak](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L126-L127)方法。
- 当我们创建这些子类的实例并调用[speak](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-object-oriented-programming-and-encapsulation/68c3bc80f67363a31791fe1c.md#L126-L127)方法时，每个玩具都以自己独特的方式说话。

总之，Python中的抽象通过增加可重用性来简化复杂系统。

你已经看到如何在多个子类中重用抽象类的单个方法，同时强制每个子类提供其特定行为。

这种方法使你的代码保持组织性、灵活性和易于维护，特别是当你的应用程序增长时。

# --questions--

## --text--

面向对象编程中抽象的主要目标是什么？

## --answers--

向用户暴露所有内部实现细节。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

将多个类合并为一个。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

防止方法在子类中被重写。

### --feedback--

想想抽象如何简化与复杂系统的交互。

---

隐藏复杂逻辑并只显示基本特征

### --feedback--

想想抽象如何简化与复杂系统的交互。

## --video-solution--

4

## --text--

Python如何通过其[ABC](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)模块实现抽象？

## --answers--

通过允许直接实例化抽象类。

### --feedback--

ABC模块强制子类实现方法。

---

通过使用装饰器和继承来定义子类必须实现的抽象方法。

### --feedback--

ABC模块强制子类实现方法。

---

通过自动隐藏所有带双下划线的方法。

### --feedback--

ABC模块强制子类实现方法。

---

通过将类转换为函数。

### --feedback--

ABC模块强制子类实现方法。

## --video-solution--

2

## --text--

在汽车抽象类比中，什么代表简化接口和复杂系统？

## --answers--

接口是发动机活塞，复杂系统是方向盘。

### --feedback--

想想接口是你直接交互的东西，而复杂系统是它如何工作。

---

接口是方向盘、刹车和油门，复杂系统是发动机、变速器和制动物理原理。

### --feedback--

想想接口是你直接交互的东西，而复杂系统是它如何工作。

---

接口是汽车手册，复杂系统是仪表板控制。

### --feedback--

想想接口是你直接交互的东西，而复杂系统是它如何工作。

---

接口是燃料类型，复杂系统是轮胎。

### --feedback--

想想接口是你直接交互的东西，而复杂系统是它如何工作。

## --video-solution--

2