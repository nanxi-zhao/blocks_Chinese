---
id: 68ca71c3f0ee7ece4ea1e286
title: 什么是名称改编（Name Mangling），它是如何工作的？
challengeType: 19
dashedName: what-is-name-mangling-and-how-does-it-work
---

# --description--

在之前的课程中，你学习了在属性前加上单下划线和双下划线的知识。

让我们回顾一下它们之间的区别：单下划线是一种约定，表示该属性是供类内部使用的，不应从类外部直接访问。而双下划线则防止该属性从类外部被直接访问。

下面是一个演示两者如何工作的示例：

```py
class Example:
    def __init__(self):
        self._internal = '我可以从类外部访问，但不应该这样做'
        self.__private = '你不能从类外部直接访问我'

obj = Example()

print(obj._internal) # 我可以从类外部访问，但不应该这样做
print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'
```

在属性前加上双下划线会触发 Python 的名称改编过程，Python 会在内部将该属性重命名，在前面加上下划线和类名作为前缀，将 `__attribute` 转换为 `_ClassName__attribute`。

要查看这一过程的实际效果，你可以创建一个类的实例，并使用该实例的 `__dict__` 特殊属性，它是一个包含对象属性的字典：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    '我可以从类外部访问，但不应该这样做',
    '我不能从类外部直接访问'
)

print(example1.__dict__)
```

结果将是：

```py
{
  '_internal': '我可以从类外部访问，但不应该这样做',
  '_Example__private': '我不能从类外部直接访问'
}
```

如你所见，`__private` 属性被存储为 `_Example__private`。这意味着你可以通过这种方式从类外部访问该属性：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    '我可以从类外部访问，但不应该这样做',
    '我不能从类外部直接访问'
)
example2 = Example(
    '我不应该从类外部访问',
    '但我可以通过名称改编从类外部访问'
)

print(example1._Example__private) # 我不能从类外部直接访问
print(example2._Example__private) # 但我可以通过名称改编从类外部访问
```

那么，Python 为什么要进行名称改编呢？

名称改编的主要目的是防止在使用继承时意外覆盖属性和方法。下面是一个能清楚说明这一点的示例：

```py
class Parent:
    def __init__(self):
        self.__data = '父类数据'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = '子类数据'

c = Child()
print(c.__dict__) # {'_Parent__data': '父类数据', '_Child__data': '子类数据'}
```

你可以看到，`Parent` 类和继承自它的 `Child` 类都有各自独立的 `_class__data` 属性。这要归功于名称改编。否则，`Child` 会意外地覆盖父类的数据。

下面是如果不允许 Python 进行名称改编会发生什么，也就是说，如果你不在两个类中的属性前加上双下划线：

```py
class Parent:
   def __init__(self):
       self.data = '父类数据'

class Child(Parent):
   def __init__(self):
       super().__init__()
       self.data = '子类数据'

c = Child()
print(c.__dict__)  # {'data': '子类数据'}
```

那么，在单下划线（`_`）和双下划线（`__`）之间，你应该使用哪一个来作为属性前缀呢？这取决于具体情况。如果一个属性仅用于类内部使用，坚持使用单下划线即可。

但如果你正在处理一个将被继承的类，你应该使用双下划线，这样父类的属性就不会被覆盖。

# --questions--

## --text--

单下划线和双下划线之间有什么区别？

## --answers--

单下划线和双下划线在 Python 中的处理方式相同。

### --feedback--

关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单下划线使属性完全私有，而双下划线使它们受保护。

### --feedback--

关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单下划线防止直接访问，而双下划线允许直接访问。

### --feedback--

关注 Python 如何处理以 `_` 和 `__` 开头的属性。

---

单下划线只是一种约定，而双下划线触发名称改编。

### --feedback--

关注 Python 如何处理以 `_` 和 `__` 开头的属性。

## --video-solution--

4

## --text--

什么是名称改编？

## --answers--

一个将所有属性转换为方法以便于访问的过程。

### --feedback--

想想 Python 如何在内部重命名双下划线属性。

---

一个删除带单下划线属性以保持它们隐藏的过程。

### --feedback--

想想 Python 如何在内部重命名双下划线属性。

---

一个将 `__attribute` 转换为 `_ClassName__attribute` 以避免在子类中意外覆盖的过程。

### --feedback--

想想 Python 如何在内部重命名双下划线属性。

---

一个加密私有数据以使其无法从类外部访问的过程。

### --feedback--

想想 Python 如何在内部重命名双下划线属性。

## --video-solution--

3

## --text--

当父类和子类中的属性不以双下划线作为前缀时会发生什么？

## --answers--

两个类都保留自己独立的属性副本，不会相互干扰。

### --feedback--

想想当两个类都使用相同属性名而不使用 `__` 时，`print(c.__dict__)` 会显示什么。

---

子类完全覆盖父类属性，父类的数据丢失。

### --feedback--

想想当两个类都使用相同属性名而不使用 `__` 时，`print(c.__dict__)` 会显示什么。

---

父类属性变为只读，子类无法更改。

### --feedback--

想想当两个类都使用相同属性名而不使用 `__` 时，`print(c.__dict__)` 会显示什么。

---

Python 会引发错误，因为属性必须始终以双下划线作为前缀。

### --feedback--

想想当两个类都使用相同属性名而不使用 `__` 时，`print(c.__dict__)` 会显示什么。

## --video-solution--

2