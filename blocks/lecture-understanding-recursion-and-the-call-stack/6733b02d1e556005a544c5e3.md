---
id: 6733b02d1e556005a544c5e3
title: 什么是递归，它是如何工作的？
challengeType: 19
dashedName: what-is-recursion-and-how-does-it-work
---

# --description--

让我们来学习递归在JavaScript中是如何工作的。

递归是一个复杂的功能，它允许你重复调用一个函数直到达到基础情况。与传统的循环不同，递归允许你处理具有未知深度的内容，比如深度嵌套的对象/数组，或者文件树。但你也可以将它用于更基本的任务，比如从给定数字开始倒数。

让我们构建一个函数来准确实现这一点。我们将把函数称为[recursiveCountdown]，它需要接受一个数字。让它把这个数字打印到控制台：

```js
const recursiveCountdown = (number) => {
  console.log(number);
};
```

现在如果我们调用它并传递数字5，我们会在终端看到数字被打印出来。但是没有其他事情发生——数字5肯定不是倒计时。

在我们开始构建函数的递归部分之前，我们需要先建立基础情况。如果你没有建立基础情况，你的代码会一直运行直到超出内存分配并崩溃。

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    console.log(number);
  };

recursiveCountdown(5);
```

对于我们的基础情况，我们希望倒计时在数字小于1时停止。当我们达到基础情况时，我们可以返回以跳出函数执行。

现在我们已经安全地准备好了基础情况，可以设置递归了。使函数递归的关键点是它在执行中调用自身。在这种情况下，我们希望在打印数字后调用函数。但是为了倒计时，我们的新数字需要少一：

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    console.log(number);
    recursiveCountdown(number - 1);
  };

recursiveCountdown(5); // 
```

这会将数字5、4、3、2和1记录到控制台。

我们确实得到了这五个数字！但是如果我们想要正向计数呢？我们可以交换日志和递归调用的顺序，而不是编写一个全新的函数：

```js
const recursiveCountdown = (number) => {
    if (number < 1) {
        return;
    }
    recursiveCountdown(number - 1);
    console.log(number);
  };

recursiveCountdown(5);
```

这会将数字1、2、3、4和5记录到控制台。

但是为什么这样做呢？要理解这一点，你需要了解调用栈。调用栈是JavaScript跟踪和解析函数调用的方式。栈的功能类似于后进先出的队列。为了更好地理解这一点，让我们在函数中添加一些日志：

```js
const recursiveCountdown = (number) => {
    console.log(`Function execution started for number: ${number}`);
    if (number < 1) {
        console.log(`Base case reached, begin resolving stack`);
        return;
    }
    console.log(`Calling recursiveCountdown with number: ${number - 1}`);
    recursiveCountdown(number - 1);
    console.log(`Function execution completed for number: ${number}`);
  };

recursiveCountdown(5);
```

我们在这里添加了四个关键语句。第一个日志在函数调用开始执行时运行。第三个日志在递归函数被调用之前运行。第四个日志在函数执行结束后运行。结果是：

```md
Function execution started for number: 5
Calling recursiveCountdown with number: 4
Function execution started for number: 4
Calling recursiveCountdown with number: 3
Function execution started for number: 3
Calling recursiveCountdown with number: 2
Function execution started for number: 2
Calling recursiveCountdown with number: 1
Function execution started for number: 1
Calling recursiveCountdown with number: 0
Function execution started for number: 0
Base case reached, begin resolving stack
Function execution completed for number: 1
Function execution completed for number: 2
Function execution completed for number: 3
Function execution completed for number: 4
Function execution completed for number: 5
```

但是这是怎么发生的呢？这就是调用栈发挥作用的地方。当我们调用[recursiveCountdown(5)]时，该函数调用被添加到调用栈中。

当该函数调用到达需要调用[recursiveCountdown(4)]的点时，它必须停止并等待结果。同时，我们的[recursiveCountdown(4)]被添加到调用栈中，位于[recursiveCountdown(5)]之上。

当该函数调用到达需要调用[recursiveCountdown(3)]的点时，它必须停止并等待结果。同时，我们的[recursiveCountdown(3)]被添加到调用栈中，位于[recursiveCountdown(4)]之上。

当该函数调用到达需要调用[recursiveCountdown(2)]的点时，它必须停止并等待结果。同时，我们的[recursiveCountdown(2)]被添加到调用栈中，位于[recursiveCountdown(3)]之上。

当该函数调用到达需要调用[recursiveCountdown(1)]的点时，它必须停止并等待结果。同时，我们的[recursiveCountdown(1)]被添加到调用栈中，位于[recursiveCountdown(2)]之上。

最后，当该函数调用到达需要调用[recursiveCountdown(0)]的点时，它必须停止并等待结果。同时，我们的[recursiveCountdown(0)]被添加到调用栈中，位于[recursiveCountdown(1)]之上。

但是[recursiveCountdown(0)]不会调用另一个函数——它达到了我们的基础情况，在那里提前返回。因为该函数的执行已经结束，所以该函数调用可以被认为是"已解决的"。当调用被解决时，它会从栈中移除。

现在我们的[recursiveCountdown(1)]不再等待那个调用——它位于栈顶并可以继续执行。

[recursiveCountdown(1)]解决，从栈中移除，并允许[recursiveCountdown(2)]继续执行。

[recursiveCountdown(2)]解决，从栈中移除，并允许[recursiveCountdown(3)]继续执行。

[recursiveCountdown(3)]解决，从栈中移除，并允许[recursiveCountdown(4)]继续执行。

[recursiveCountdown(4)]解决，从栈中移除，并允许[recursiveCountdown(5)]继续执行。

而[recursiveCountdown(5)]解决并从栈中移除。我们的调用栈现在是空的，所以递归完成了！

这是JavaScript中递归工作原理的基本概述。这是一个复杂的概念，你应该多玩一些代码和日志语句，直到你对调用栈的行为感到舒适为止。

为了增加一些趣味性，我们谈到了如果没有基础情况，当代码耗尽内存时会崩溃。这是因为递归不断在调用栈中堆积越来越多的函数调用，直到栈溢出。就像那个受欢迎的编程社区的名字一样。

# --questions--

## --text--

递归函数中基础情况的主要目的是什么？

## --answers--

启动递归调用。

### --feedback--

课程中提到了如果没有建立基础情况会发生什么。

---

防止无限递归和栈溢出。

---

提高函数性能。

### --feedback--

课程中提到了如果没有建立基础情况会发生什么。

---

处理错误条件。

### --feedback--

课程中提到了如果没有建立基础情况会发生什么。

## --video-solution--

2

## --text--

在递归的上下文中，调用栈是用来做什么的？

## --answers--

存储局部变量。

### --feedback--

课程解释了在递归过程中调用栈如何管理函数调用。

---

跟踪和解析函数调用。

---

优化递归函数。

### --feedback--

课程解释了在递归过程中调用栈如何管理函数调用。

---

处理异步操作。

### --feedback--

课程解释了在递归过程中调用栈如何管理函数调用。

## --video-solution--

2

## --text--

当递归函数调用达到其基础情况时会发生什么？

## --answers--

开始新的递归循环。

### --feedback--

想想当函数碰到停止递归的条件时的行为。

---

抛出错误。

### --feedback--

想想当函数碰到停止递归的条件时的行为。

---

返回并允许前一个调用继续执行。

---

无限地继续调用自身。

### --feedback--

想想当函数碰到停止递归的条件时的行为。

## --video-solution--

3