---
id: 67d2ff1996e4ae9e67170502
title: 什么是单元测试？
challengeType: 19
dashedName: what-is-unit-testing
---

# --description--

在设计应用程序时，你经常会有一系列小函数，每个函数只负责一件事。这被称为"单一职责原则"。当你有一系列小函数时，最好测试这些函数以确保一切按预期工作。在本节课中，我们将看看如何使用流行的Jest测试框架创建单元测试。

在这个例子中，我们要创建一个负责返回新格式化字符串的函数：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

这个`getFormattedWord`函数有一个名为`str`的参数，首先会检查`str`是否为空。如果是，则返回空字符串。否则，返回一个新字符串，其中第一个字母大写。我们导出这个函数，以便在测试文件中使用它。

在单独的`getFormattedWord.test.js`文件中，我们可以编写一些测试来验证函数是否在做它应该做的事情。

在`getFormattedWord.test.js`文件的顶部，我们需要首先像这样导入函数：

```js
import { getFormattedWord } from "./getFormattedWord.js";
```

然后我们需要使用`npm i jest`安装Jest包。然后我们可以添加一个测试，检查由小写字符组成的单词`hello`是否正确格式化为`Hello`，以大写`H`开头：

```js
test('capitalizes the first letter of a word', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

`expect`函数用于测试一个值。它与匹配器结合使用，匹配器是一个检查值是否按预期行为的函数。在这种情况下，匹配器是`toBe()`。Jest有各种各样的匹配器，可以帮助你测试真实性、字符串、数字等。

运行测试的一种方法是在`package.json`文件中添加npm脚本。这里是Jest框架的示例脚本：

```js
"scripts": {
  "test": "jest"
},
```

然后只需在终端中运行`npm run test`来运行测试。如果测试通过，你应该在终端中看到类似这样的内容：

```sh
PASS ./getFormattedWord.test.js
  ✓ capitalizes the first letter of a word (1 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        0.103 s, estimated 1 s
Ran all test suites.
```

要看看失败的测试是什么样子，我们可以通过将函数更新为以下内容来故意破坏测试：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return "This is incorrect";
}
```

现在当你运行`npm run test`命令时，会出现错误消息，因为测试期望得到不同的结果：

```sh
FAIL ./getFormattedWord.test.js
  ✕ capitalizes the first letter of a word (1 ms)

  ● capitalizes the first letter of a word

  expect(received).toBe(expected) // Object.is equality

  Expected: "Hello"
  Received: "This is incorrect"

    2 |
    3 | test('capitalizes the first letter of a word', () => {
    4 |   expect(getFormattedWord('hello')).toBe('Hello');
                                            ^
    5 | });
    6 |

    at Object.toBe (getFormattedWord.test.js:4:37)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.121 s, estimated 1 s
Ran all test suites.
```

现在我们可以将函数更新回原来的版本：

```js
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

添加另一个测试来检查没有向`getFormattedWord`提供参数的情况：

```js
test("returns an empty string when no argument is provided", () => {
  expect(getFormattedWord()).toBe("");
});
```

还有其他测试可以使事情更加健壮，但前几个测试是单元测试的良好入门。

在测试JavaScript应用程序时，一些常见的测试框架包括Jest、Mocha和Vitest。

单元测试很重要，因为它会帮助你在程序中发现更多bug，并确保一切按预期工作。它还可以作为应用程序的一种文档形式，因为它旨在表示代码的预期行为。

# --questions--

## --text--

以下哪项指的是函数只应负责一件事的原则？

## --answers--

单一职责原则

---

多重职责原则

### --feedback--

回到课程开头讨论这一点的地方。

---

单一请求原则

### --feedback--

Refer back to the very beginning of the lesson where this was discussed.

---

多重响应原则

### --feedback--

Refer back to the very beginning of the lesson where this was discussed.

## --video-solution--

1

## --text--

以下哪项不是JavaScript生态系统中常用的测试框架？

## --answers--

JUnit

---

Jest

### --feedback--

Refer back to the end of the lesson where this was discussed.

---

Vitest

### --feedback--

Refer back to the end of the lesson where this was discussed.

---

Mocha

### --feedback--

Refer back to the end of the lesson where this was discussed.

## --video-solution--

1

## --text--

你可以在`package.json`文件中添加什么来在终端中运行测试？

## --answers--

```json
"test": {
  "test": "run test"
},
```

### --feedback--

记住你可以在`package.json`文件中创建自定义脚本。

---

```json
"scriptings": {
  "jest"
},
```

### --feedback--

记住你可以在`package.json`文件中创建自定义脚本。

---

```json
"run": {
  "test"
},
```

### --feedback--

Remember that you can create custom scripts in your `package.json` file.

---

```json
"scripts": {
  "test": "jest"
}
```

## --video-solution--

4
