---
id: 67338e93b75977a344cf6d40
title: 事件冒泡和事件委托是如何工作的？
challengeType: 19
dashedName: how-do-event-bubbling-and-event-delegation-work
---

# --description--

事件冒泡，或称为传播，指的是事件在触发时如何"冒泡"到父对象。例如，考虑以下代码：

```html
<p>
  <span>点击我~!</span>
</p>
```

这里的 `p` 元素被认为是 `span` 元素的父元素。

当你按照指示点击 `span` 元素时，`span` 元素成为 `click` 事件的目标。然而，该事件也会冒泡到父元素——`p` 元素可以根据需要接收和消费该事件。

但这实际上意味着什么呢？你可以在 `p` 元素上附加一个事件监听器：

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  console.log(event.target);
});
```

然后，当你点击 `span` 元素时，你会看到控制台中记录了文本 `Click me~!`。

事件传播到父元素 `p`，它在事件监听器中消费该事件以显示事件的目标。

请注意，目标仍然是 `span` 元素。这是因为 `span` 元素接收了初始点击。

为了确保事情的运作方式，让我们扩展代码：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P 监听器: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span 监听器: ");
  console.log(event.target);
});
```

为了让你了解事件如何冒泡，点击 `span` 元素后在控制台中看到的内容如下：

```html
"Span 监听器: "
<span>点击我~!</span>
"P 监听器: "
<span>点击我~!</span>
```

现在让我们看看当我们使用 `stopPropagation()` 阻止事件传播时会发生什么。我们将在 `span` 的事件监听器中调用它：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {
  console.log("P 监听器: ");
  console.log(event.target);
});
span.addEventListener("click", (event) => {
  console.log("Span 监听器: ");
  console.log(event.target);
  event.stopPropagation();
});
```

然后再次点击我们的 `span`：

```html
"Span 监听器: "
<span>点击我~!</span>
```

这次，我们没有看到 `p` 监听器触发。事件从未在 `p` 元素上触发，因为我们在处理子 `span` 元素时告诉它停止传播。

事件委托可以被认为是相反的概念。它是捕获事件并将其委托给另一个元素的过程。

回到我们的代码，让我们更新它，使点击 `span` 元素将其变为红色：

```js
const p = document.querySelector("p");
const span = document.querySelector("span");
p.addEventListener("click", (event) => {});
span.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

但是如果你有二十个 `span` 元素呢？或者你可能使用 JavaScript 动态创建更多的 `span` 元素？

你不必为每个 `span` 元素附加事件监听器，而实际上可以对 `p` 元素使用监听器来处理所有这些元素。换句话说，你可以将 `span` 点击的处理委托给父元素 `p`。

我们的代码现在可能看起来像这样：

```js
const p = document.querySelector("p");
p.addEventListener("click", (event) => {
  event.target.style.color = "red";
});
```

请注意，我们不再在 `span` 元素上附加任何监听器。你已正确地将事件处理委托给 `p` 元素。但它有效吗？

让我们生成一些额外的 `span` 元素来看看：

```html
<p>
  <span>点击我~!</span>
  <span>点击我~!</span>
  <span>点击我~!</span>
  <span>点击我~!</span>
</p>
```

现在，每次我们点击一个 `span` 时，该元素的文本将变为红色。

就这样，通过单个事件监听器，我们已正确地允许 `click` 事件从 `span` 元素冒泡到父 `p` 元素，并将该 `click` 事件的逻辑委托给 `p` 元素。

事件传播和委托可能是一个复杂的主题，特别是当你深入到像表格这样的重嵌套元素时。我们鼓励你进一步探索并试验我们在这里编写的一些代码。

# --questions--

## --text--

JavaScript 中的事件冒泡是什么？

## --answers--

创建新事件的过程。

### --feedback--

想想课程如何描述事件传播的"方向"。

---

事件从子元素向父元素传播的方式。

---

阻止事件默认行为的方法。

### --feedback--

想想课程如何描述事件传播的"方向"。

---

将多个事件监听器附加到单个元素的过程。

### --feedback--

想想课程如何描述事件传播的"方向"。

## --video-solution--

2

## --text--

`stopPropagation()` 方法的目的是什么？

## --answers--

阻止事件的默认行为。

### --feedback--

课程演示了此方法对事件冒泡的影响。

---

从元素中删除所有事件监听器。

### --feedback--

课程演示了此方法对事件冒泡的影响。

---

阻止事件冒泡到父元素。

---

将事件处理委托给子元素。

### --feedback--

课程演示了此方法对事件冒泡的影响。

## --video-solution--

3

## --text--

使用事件委托的主要优势是什么？

## --answers--

允许事件从子元素冒泡到父元素。

### --feedback--

考虑具有多个 `span` 元素的示例以及事件处理是如何简化的。

---

阻止事件的默认行为。

### --feedback--

考虑具有多个 `span` 元素的示例以及事件处理是如何简化的。

---

减少处理多个元素所需的事件监听器数量。

---

自动停止事件传播。

### --feedback--

考虑具有多个 `span` 元素的示例以及事件处理是如何简化的。

## --video-solution--

3