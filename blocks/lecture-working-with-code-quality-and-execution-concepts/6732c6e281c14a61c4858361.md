---
id: 6732c6e281c14a61c4858361
title: 什么是闭包，它们是如何工作的？
challengeType: 19
dashedName: what-are-closures-and-how-do-they-work
---

# --interactive--

闭包是 JavaScript 中最强大且经常被误解的特性之一。从本质上讲，闭包是一个函数，它可以访问其外部封闭词法作用域中的变量，即使外部函数已经返回。这听起来可能很复杂，但它是 JavaScript 中许多高级编程模式的基础概念。

为了理解闭包，让我们从一个例子开始：

:::interactive_editor

```js
function outerFunction(x) {
    let y = 10;
    function innerFunction(){
        console.log(x + y);
    }
    return innerFunction;
}

let closure = outerFunction(5);
console.log(closure()); // 15
```

:::

在这个例子中，`outerFunction` 接受一个参数 `x` 并定义了一个局部变量 `y`。然后它定义了一个 `innerFunction`，使用了 `x` 和 `y`。最后它返回 `innerFunction`。当我们调用 `outerFunction(5)` 时，它返回 `innerFunction`，我们将其赋值给变量 `closure`。当我们稍后调用 `closure()` 时，它仍然可以访问 `outerFunction` 中的 `x` 和 `y`，即使 `outerFunction` 已经执行完毕。这就是闭包的本质。

内部函数维护对其外部词法环境的引用，保留对该环境中变量的访问，即使外部函数已完成。

闭包在创建私有变量和函数时特别有用。考虑这个例子：

:::interactive_editor

```js
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

:::

在这种情况下，`createCounter` 返回一个函数，该函数递增并返回一个 `count` 变量。`count` 变量不能从 `createCounter` 外部直接访问，但返回的函数（我们的闭包）可以访问它。每次我们调用 `counter()` 时，它都会递增并返回 `count`。

闭包还可以从其外部作用域捕获多个变量。例如：

:::interactive_editor

```js
function multiply(x) {
    return function (y) {
        return x * y;
    };
}

let double = multiply(2);
console.log(double(5)); // 10
```

:::

这里内部函数捕获了 `multiply` 中的 `x` 参数。当我们通过调用 `multiply(2)` 创建 `double` 时，它返回一个函数，该函数总是将其参数乘以 `2`。

关于闭包需要注意的一点是，它们按引用而不是按值捕获变量。这意味着如果捕获的变量的值发生变化，闭包将看到新值。例如：

:::interactive_editor

```js
function createIncrementer() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

let increment = createIncrementer();
increment(); // 1
increment(); // 2
```

:::

每次我们调用 `increment` 时，它都在处理同一个 `count` 变量，而不是其初始值的副本。闭包是 JavaScript 中的强大工具。当你继续使用 JavaScript 时，你会发现理解和有效使用闭包可以大大提高你编写干净、高效和强大代码的能力。

# --questions--

## --text--

以下代码的输出是什么？

```js
function outer(x) {
    return function(y) {
        return x + y;
    };
}

let add5 = outer(5);
console.log(add5(3));
```

## --answers--

`5`

### --feedback--

考虑内部函数在 outer 中如何捕获 `x` 参数。

---

`3`

### --feedback--

考虑内部函数在 outer 中如何捕获 `x` 参数。

---

`8`

---

`undefined`

### --feedback--

考虑内部函数在 outer 中如何捕获 `x` 参数。

## --video-solution--

3

## --text--

以下代码演示了什么概念？

```js
function createGreeter(greeting) {
    return function(name) {
        console.log(greeting + ", " + name);
    };
}

let sayHello = createGreeter("Hello");
sayHello("Alice");
```

## --answers--

提升。

### --feedback--

想想返回的函数如何保留对 `greeting` 参数的访问。

---

闭包。

---

递归。

### --feedback--

想想返回的函数如何保留对 `greeting` 参数的访问。

---

原型继承。

### --feedback--

想想返回的函数如何保留对 `greeting` 参数的访问。

## --video-solution--

2

## --text--

以下代码的输出是什么？

```js
function counter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let increment = counter();
console.log(increment());
console.log(increment());
console.log(increment());
```

## --answers--

```js
1
1
1
```

### --feedback--

考虑 counter 中的内部函数如何在多次调用中保持对 count 变量的访问。

---

```js
1
2
3
```

---

```js
0
1
2
```

### --feedback--

考虑 counter 中的内部函数如何在多次调用中保持对 count 变量的访问。

---

```js
undefined
undefined
undefined
```

### --feedback--

考虑 counter 中的内部函数如何在多次调用中保持对 count 变量的访问。

## --video-solution--

2