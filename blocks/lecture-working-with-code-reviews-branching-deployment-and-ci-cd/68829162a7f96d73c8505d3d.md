---
id: 68829162a7f96d73c8505d3d
title: 什么是合并冲突，如何解决它们？
challengeType: 19
dashedName: what-are-merge-conflicts-and-how-can-you-resolve-them
---

# --description--

如果你在有经验的开发者周围，无论是在在线社区还是面对面，你可能听说过"可怕的合并冲突"。但它们到底是什么？

好吧，当你使用我们之前课程中讨论的适当分支策略时，你可能同时在两个不同的分支上处理两个不同的功能。或者也许你正在处理某件事，而同事正在另一个分支上工作。无论如何，你有两个独立的更改在进行。但有时，这两个分支都会编辑同一个文件。如果另一个分支先合并到 `main`，你的分支更改就会落后。

大多数情况下，这可以通过将 `main` 合并回你的功能分支来解决。但当来自另一个分支的更改与你的分支冲突时，Git 在合并过程中无法判断你想要保留哪些更改。这被称为"合并冲突"。

但你如何解决它呢？对于较小和较简单的冲突，GitHub 会给你一个 Web UI 来修复它。如果存在冲突，PR 底部会出现一个"解决冲突"按钮。如果你点击它，你会看到带有冲突的文件，其中包括你的代码和冲突的代码。Git 会在你的代码和冲突代码周围添加"合并冲突标记"来帮助识别问题。它看起来像这样：

```sh
1 <<<<<<< feat/conflict
2 Here's some code from my first PR :)
3 =======
4 Here's some code that was merged to main that conflicts with the code on my PR
5 >>>>>>> main
```

开始标记是 `<<<<<<< feat/conflict`，表示当前分支更改的开始。然后我们看到 `Here's some code from my first PR :)`。之后是 `=======` 标记，表示我们更改的结束和 `main` 分支更改的开始。我们可以看到 `main` 上的更改是 `Here's some code that was merged to main that conflicts with the code on my PR` 这一行。之后是结束标记 `>>>>>> main` 来显示冲突的结束。

但我们如何修复它呢？你需要决定在合并冲突中要保留哪些更改。如果你想保留两个更改，你可以只删除冲突标记并保持更改不变。或者，如果你只想保留一个分支的更改，你会删除冲突标记和你不希望保留的分支的更改（那些你不想保留的更改）。最后，如果你不喜欢任何更改，你可以从开始标记到结束标记（包括在内）删除所有内容。

让我们删除 `main` 分支的更改，但保留我们的。现在我们有：

```sh
1 Here's some code from my first PR :)
```

点击"标记为已解决"按钮，告诉 GitHub 你对解决方案满意。如果还有其他文件，GitHub 会切换到下一个文件。但由于这是我们的唯一冲突文件，你会看到一个"提交合并"按钮出现。点击该按钮，GitHub 会为你创建一个合并提交。你将被带回拉取请求，你会看到你的新合并提交和已解决的冲突。我们已经准备好了！

但如果你不能在 GitHub 上直接编辑冲突，因为它们太复杂怎么办？

好吧，如果你的分支提交很少，或者只有几个提交修改了该文件，你可以将 `main` 合并到你的分支：

```sh
git checkout feat/conflict
git fetch origin
git merge origin/main
```

当 Git 处理这个合并时，你会得到需要手动解决的冲突。Git 会通知你哪些文件需要修复。当我们在编辑器中打开有冲突的文件时，我们会得到相同的冲突标记，以及多亏了 VSCode 的一些有用的 UI 添加。继续以同样的方式修复文件中的冲突。但这次，我们需要手动创建提交。这与创建任何其他提交相同：

```sh
git add .
git commit -m "chore: resolve conflicts"
```

运行这些命令后，我们可以看到 Git 已经接受了我们的解决方案。

有时，当你有很多提交或冲突时，变基可能会有帮助。变基不是合并更改，而是获取你分支上的所有提交并将它们重新应用，使它们在 `main` 上的最新更改之后出现。用 Git 术语来说，这有效地将你的分支基础"重置"为 `main` 上的最新提交。

为了试验这个，我们需要一个新分支：

```sh
git checkout main
git pull
git checkout -b feat/rebase
```

让我们继续为我们的分支生成一堆提交，这样我们就可以练习变基：

```sh
echo "change one" > README.md
git add .
git commit -m "change one"
echo "change two" > README.md
git add .
git commit -m "change two"
echo "change three" > README.md
git add .
git commit -m "change three"
```

现在，让我们在 `main` 上进行另一个更改以创建冲突：

```sh
git checkout main
echo "change four" > README.md
git add .
git commit -m "change four"
```

并检出我们的变基分支：

```sh
git checkout feat/rebase
```

接下来，运行 `git rebase -i main`。它会将我们的分支变基到 `main` 分支的当前状态。`-i` 标志告诉 Git 以交互模式执行变基。你会看到你的提交旁边有单词 `pick`。`pick` 告诉 Git 按原样使用提交进行变基。保存并关闭文件，我们会得到一个错误消息，告诉我们存在冲突。

我们的 `change one` 提交与 `change four` 提交冲突，我们需要解决这个问题。在编辑器中打开文件，你会看到与之前冲突相同的 UI。让我们保留我们的 `change one` 更改。然后，你需要运行 `git add .` 来添加更改，并运行 `git rebase --continue` 来告诉 Git 我们准备继续变基。由于我们已经解决了第一个提交中的冲突，Git 可以自动处理变基其余提交。

现在，作为最后的清理，让我们将三个更改提交压缩成一个单独的提交以获得更干净的历史。再次运行 `git rebase -i main` 以进入编辑器。然后，将第一个命令保持为 `pick`，但将接下来的两个更改为 `squash`。你可能会再次遇到相同的冲突。如果遇到，请以与之前相同的方式解决它。一旦你解决了并继续变基（或者如果你没有冲突就立即解决），你会看到一个新的提交消息编辑器弹出。这个消息将是你新的提交，包含我们压缩的三个提交的更改。让我们将其命名为 `change three complete`。保存并关闭编辑器，Git 将完成变基。

如果我们现在检查你的提交历史，我们可以看到我们现在有单个 `change three complete` 提交，它正确地基于 `change four` 提交。这意味着你已经成功完成了带有压缩提交的变基！现在你有了成为合并冲突冠军所需的工具！

# --questions--

## --text--

Git 添加的合并冲突标记是什么，用于帮助识别冲突更改？

## --answers--

`<<< current branch`, `=== separator`, `>>> other branch`

### --feedback--

想想 Git 用来标记冲突开始、中间和结束的特定语法。

---

`[[ current branch`, `|| separator`, `]] other branch`

### --feedback--

想想 Git 用来标记冲突开始、中间和结束的特定语法。

---

`<<<<<<< current branch`, `======= separator`, `>>>>>>> other branch`

---

`--- current branch`, `+++ separator`, `--- other branch`

### --feedback--

想想 Git 用来标记冲突开始、中间和结束的特定语法。

## --video-solution--

3

## --text--

在本地仓库中手动解决合并冲突后，你需要运行什么命令来完成合并？

## --answers--

`git push origin main` 和 `git rebase -i origin/main`

### --feedback--

修复冲突后，你需要像任何其他提交一样暂存和提交已解决的更改。

---

`git add` 和 `git commit`

---

`git merge --abort` 和 `git commit`

### --feedback--

修复冲突后，你需要像任何其他提交一样暂存和提交已解决的更改。

---

`git reset --hard` 和 `git push -f`

### --feedback--

修复冲突后，你需要像任何其他提交一样暂存和提交已解决的更改。

## --video-solution--

2

## --text--

在处理分支冲突时，合并和变基的主要区别是什么？

## --answers--

合并创建一个新提交，而变基重写历史以将你的提交放在另一个分支的提交之后。

---

变基比合并更快。

### --feedback--

考虑每个操作如何影响提交历史。

---

合并只能在 GitHub 上完成，变基必须在本地完成。

### --feedback--

考虑每个操作如何影响提交历史。

---

没有区别，它们是相同的操作。

### --feedback--

考虑每个操作如何影响提交历史。

## --video-solution--

1