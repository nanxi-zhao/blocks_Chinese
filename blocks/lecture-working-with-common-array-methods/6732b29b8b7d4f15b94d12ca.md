---
id: 6732b29b8b7d4f15b94d12ca
title: 什么是数组的浅拷贝，有哪些方法可以创建这些拷贝？
challengeType: 19
dashedName: what-is-a-shallow-copy-of-an-array-and-what-are-some-ways-to-create-these-copies
---

# --interactive--

数组的浅拷贝是一个包含与原始数组相同项目的全新数组。如果数组只包含数字或字符串等原始值，新数组就是完全独立的。但如果数组内部包含其他数组，原始数组和拷贝数组都会引用相同的内部数组。这意味着如果你更改了共享的内部数组中的某些内容，你会在两个数组中都看到这个变化。

当你需要修改顶层结构（如添加、删除或重新排序元素）而不想修改原始数组或内部数组时，浅拷贝非常有用。

有几种创建数组浅拷贝的方法，我们将探讨一些最常见的方法：[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)、[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)和展开运算符。

让我们从[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)方法开始。这个方法通过合并两个或多个数组来创建一个新数组。当与单个数组一起使用时，它实际上会创建一个浅拷贝。这是一个示例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [].concat(originalArray);

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在这个示例中，我们使用[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)方法将一个空数组与[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L21-L21)连接。这将创建一个[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L21-L21)的浅拷贝新数组。

[copyArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)包含与[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L21-L21)相同的元素，但它是不同的数组对象，这就是严格相等检查（[===](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L25-L25)）返回[false](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/67329f64e0ef5c5b7388158d.md#L19-L19)的原因。

创建浅拷贝的另一种方法是[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)方法。当不带参数调用时，[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)返回整个数组的浅拷贝。以下是它的工作原理：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = originalArray.slice();

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

在这种情况下，[originalArray.slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)创建一个[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L39-L39)的浅拷贝新数组。同样，[copyArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)包含相同的元素，但它是不同的数组对象。

展开运算符（...），在ES6中引入，提供了另一种简洁的创建数组浅拷贝的方法。这是一个示例：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

console.log(copyArray); // [1, 2, 3]
console.log(copyArray === originalArray); // false
```

:::

展开运算符（...）将[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L55-L55)的元素展开到一个新数组中，有效地创建了一个浅拷贝。需要注意的是，所有这些方法都会创建新的数组对象，这意味着你可以修改拷贝而不影响原始数组。例如：

:::interactive_editor

```js
const originalArray = [1, 2, 3];
const copyArray = [...originalArray];

copyArray.push(4);
console.log(originalArray); // [1, 2, 3]
console.log(copyArray);     // [1, 2, 3, 4]
```

:::

在这个示例中，向[copyArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L70-L70)添加元素不会影响[originalArray](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L69-L69)。

总之，可以使用[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)、[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)或展开运算符等方法轻松创建数组的浅拷贝。这些方法对于创建可以独立于原始数组进行操作的新数组非常有用。

# --questions--

## --text--

以下代码的输出结果是什么？

```js
const arr1 = [1, 2, 3];
const arr2 = arr1.slice();
arr2.push(4);
console.log(arr1, arr2);
```

## --answers--

[1, 2, 3] [1, 2, 3, 4]

---

[1, 2, 3, 4] [1, 2, 3, 4]

### --feedback--

[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)方法创建数组的浅拷贝。

---

[1, 2, 3] [1, 2, 3]

### --feedback--

[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)方法创建数组的浅拷贝。

---

这将抛出一个错误。

### --feedback--

[slice()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L40-L40)方法创建数组的浅拷贝。

## --video-solution--

1

## --text--

以下代码的输出结果是什么？

```js
const fruits = ["apple", "banana", "orange"];
const fruitsCopy = [...fruits];
console.log(fruitsCopy.length);
```

## --answers--

[0](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L140-L140)

### --feedback--

展开运算符（...）创建整个数组的浅拷贝。

---

[2](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L148-L148)

### --feedback--

展开运算符（...）创建整个数组的浅拷贝。

---

[3](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L156-L156)

---

[undefined](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b28eeadda1158cdbff7b.md#L97-L97)

### --feedback--

展开运算符（...）创建整个数组的浅拷贝。

## --video-solution--

3

## --text--

以下代码的输出结果是什么？

```js
const arr1 = [1, 2, 3];
const arr2 = [].concat(arr1);
console.log(arr1 === arr2);
```

## --answers--

[true](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b28eeadda1158cdbff7b.md#L18-L18)

### --feedback--

[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)方法会创建一个新数组，即使它与空数组连接。

---

[false](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b28eeadda1158cdbff7b.md#L19-L19)

---

[undefined](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b28eeadda1158cdbff7b.md#L97-L97)

### --feedback--

[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)方法会创建一个新数组，即使它与空数组连接。

---

这将抛出一个错误。

### --feedback--

[concat()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-array-methods/6732b29b8b7d4f15b94d12ca.md#L22-L22)方法会创建一个新数组，即使它与空数组连接。

## --video-solution--

2