---
id: 67d2f51ff2c927713caa24fa
title: useCallback钩子和React.memo是如何工作的？
challengeType: 19
dashedName: how-do-the-usecallback-hook-and-react-memo-work
---

# --description--

在上一课中，你学习了记忆化以及`useMemo`钩子是如何工作的。

在本课中，你将学习`useCallback`钩子和`React.memo`是如何工作的。

在上一课中，我们还提到`useCallback`用于记忆化函数引用。

对于`React.memo`，它让你记忆化一个组件，以防止在其prop未改变时进行不必要的重新渲染。

这是`useCallback`钩子的基本语法：

```js
const handleClick = useCallback(() => {
  // 代码写在这里
}, [dependency]);
```

这是`React.memo`的基本语法：

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
  return (
    <>
      {/* 展示内容 */}
    </>
  )
});
```

让我们看一个`useCallback`钩子的示例：

```jsx
import { useState, useEffect } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prevCount) => prevCount + 1);
  };

  useEffect(() => {
    console.log("useEffect运行");
  }, [handleClick]);

  return (
    <div>
      <p>计数: {count}</p>
      <button onClick={handleClick}>增加</button>
    </div>
  );
}

export default Counter;
```

在组件中，每当`handleClick`改变时效果都会运行，因为`handleClick`函数在每次渲染时都被重新创建。

为了解决这个问题，你需要告诉React将`handleClick`函数视为跨渲染的相同内容，通过使用`useCallback`钩子对其进行记忆化，这样它就不会被重新创建：

```jsx
import { useState, useEffect, useCallback } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  // 使用useCallback记忆化handleClick函数
  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  useEffect(() => {
    console.log("useEffect运行");
  }, [handleClick]);

  return (
    <div>
      <p>计数: {count}</p>
      <button onClick={handleClick}>增加</button>
    </div>
  );
}

export default Counter;
```

现在`handleClick`函数不会在每次渲染时被重新创建。

为了向你展示`React.memo`（或`memo`）高阶函数和`useCallback`钩子如何协同工作，这里有一个`Counter`组件，它有一个需要`useCallback`的`handleClick`函数，但目前没有使用它：

```jsx
import { useState, useEffect, useCallback } from "react";
import CounterChild from "./CounterChild";

function Counter() {
  const [count, setCount] = useState(0);
  const [timer, setTimer] = useState(new Date().toLocaleTimeString());

  const handleClick = () => {
    setCount(count + 1);
  };

  useEffect(() => {
    const interval = setInterval(() => {
      setTimer(new Date().toLocaleTimeString());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h1>时间: {timer}</h1>
      <p>计数: {count}</p>
      <button onClick={handleClick}>增加</button>
      <CounterChild onClick={handleClick} />
    </div>
  );
}

export default Counter;
```

这个函数还有一个每秒更新的计时器状态。这使得组件在`timer`改变时重新渲染，使`handleClick`函数在每次渲染时被重新创建。

这就是为什么`handleClick`需要用`useCallback`进行记忆化。

这是`CounterChild`组件：

```jsx
const CounterChild = ({ onClick }) => {
  console.log("CounterChild组件已渲染");
  return <button onClick={onClick}>从子组件增加</button>;
};

export default CounterChild;
```

这个`CounterChild`组件接受一个`onClick` prop，让你也能从它增加计数器。

由于`CounterChild`组件是`Counter`组件的子组件，当`Counter`由于计时器改变而重新渲染时，它也会渲染。因此，`CounterChild`也需要被记忆化。

没有记忆化的情况下，由于组件由于计时器每秒更新而重新渲染，`CounterChild`组件也会被重新渲染。

为了防止这种情况，你需要使用`React.memo`对`CounterChild`组件进行记忆化：

```jsx
import React from "react";

const CounterChild = React.memo(({ onClick }) => {
  console.log("CounterChild组件已渲染");
  return <button onClick={onClick}>从子组件增加</button>;
});

export default CounterChild;
```

即使使用`React.memo`对`CounterChild`进行记忆化，事情仍然不能最优地工作。

这是因为`handleClick`函数在每次渲染时都被重新创建，所以它也需要用`useCallback`进行记忆化，以告诉React你需要函数在跨渲染时保持不变：

```js
const handleClick = useCallback(() => {
  setCount((prevCount) => prevCount + 1);
}, [count]);
```

现在，组件只在`count`状态改变时重新渲染。

# --questions--

## --text--

`useCallback`钩子记忆化什么？

## --answers--

计算值。

### --feedback--

它有助于防止在每次渲染时创建新的函数实例。

---

函数引用。

---

组件渲染。

### --feedback--

它有助于防止在每次渲染时创建新的函数实例。

---

状态更新。

### --feedback--

它有助于防止在每次渲染时创建新的函数实例。

## --video-solution--

2

## --text--

以下哪项是`useCallback`钩子的正确语法？

## --answers--

```js
const handleClick = useCallback(() => { /* 代码 */ });
```

### --feedback--

第二个参数应该是一个依赖项数组。

---

```js
const handleClick = useCallback(() => { /* 代码 */ }, dependency);
```

### --feedback--

第二个参数应该是一个依赖项数组。

---

```jsx
const handleClick = useCallback(() => { /* 代码 */ }, [dependency]);
```

---

```js
const handleClick = useCallback(() => { dependency }, {});
```

### --feedback--

第二个参数应该是一个依赖项数组。

## --video-solution--

3

## --text--

`React.memo`记忆化什么？

## --answers--

函数引用。

### --feedback--

当props保持不变时，它防止重新渲染。

---

组件状态。

### --feedback--

当props保持不变时，它防止重新渲染。

---

基于未改变的props的组件渲染。

---

DOM元素。

### --feedback--

当props保持不变时，它防止重新渲染。

## --video-solution--

3