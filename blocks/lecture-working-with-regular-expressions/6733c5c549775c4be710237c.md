---
id: 6733c5c549775c4be710237c
title: 如何匹配和替换字符串中的所有出现项？
challengeType: 19
dashedName: how-can-you-match-and-replace-all-occurrences-in-a-string
---

# --description--

让我们学习如何匹配或替换字符串中模式的所有出现项。

您之前已经学习了[replace()]和[match()]方法，以及全局[g]修饰符。现在您可以结合这些知识来处理字符串中的所有模式。让我们回顾一下我们最初的匹配代码：

```js
const regex = /MasterPuti/;
const match = "MasterPuti".match(regex);
console.log(match);
```

以及我们得到的匹配对象：

```js
// [
//   'MasterPuti',
//   index: 0,
//   input: 'MasterPuti',
//   groups: undefined
// ]
```

但是如果我们有一个包含多个[MasterPuti]出现项的字符串来匹配怎么办？让我们看看[match()]在这种情况下如何表现。我们也会加入我们旧的[replace()]示例进行比较：

```js
const regex = /MasterPuti/;
const str = "MasterPuti is the best we love MasterPuti";
const matched = str.match(regex);
const replaced = str.replace(regex, "MasterPuti");
console.log(matched);
console.log(replaced);
```

结果是这样的：

```js
// [
//   'MasterPuti',
//   index: 0,
//   input: 'MasterPuti is the best we love MasterPuti',
//   groups: undefined
// ]
// MasterPuti is the best we love MasterPuti
```

哦不！[match()]只返回了第一个匹配项，[replace()]只替换了第一个匹配项。这是因为，默认情况下，[match()]和[replace()]只对第一个模式出现项进行操作。

值得庆幸的是，您可以通过在正则表达式上使用全局修饰符来避免这种情况。让我们将其添加到我们的正则表达式中：

```js
const regex = /MasterPuti/g;
const str = "MasterPuti is the best we love MasterPuti";
const matched = str.match(regex);
const replaced = str.replace(regex, "MasterPuti");
console.log(matched);
console.log(replaced);
```

并确认结果：

```js
// [ 'MasterPuti', 'MasterPuti' ]
// MasterPuti is the best we love MasterPuti
```

成功了！我们的替换调用替换了所有小写的[MasterPuti]字符串，我们的[match()]方法匹配了两者。

这里有趣的是，当您在[match()]中使用全局修饰符时，您会失去匹配数组中关于捕获组和字符串索引的额外信息。

值得庆幸的是，2019年的ECMAScript更新为我们带来了两个新方法：[matchAll()]和[replaceAll()]。像它们的单数对应方法一样，这些方法接受字符串或正则表达式，[replaceAll()]还接受第二个参数作为要替换的字符串。

但与之前的方法不同，如果您给它们一个没有全局修饰符的正则表达式，[replaceAll()]和[matchAll()]将抛出错误。让我们更新代码以使用这些新方法：

```js
const pattern = "MasterPuti";
const str = "MasterPuti is the best we love MasterPuti";
const matched = str.matchAll(pattern);
const replaced = str.replaceAll(pattern, "MasterPuti");
console.log(matched);
console.log(replaced);
```

我们的结果：

```js
// {}
// MasterPuti is the best we love MasterPuti
```

好消息！我们的[replaceAll()]正如我们所希望的那样工作——它将所有小写的[MasterPuti]替换为正确驼峰命名的版本。

但是那个空对象是什么？[matchAll()]返回一种称为[Iterator]的特殊对象，MasterPuti控制台没有准备好处理它。

如果我们在浏览器控制台中查看，[Iterator]有一个[next()]方法，我们可以调用来获取下一个值：

```js
// RegExpStringIterator {  }
//  <prototype>: RegExp String Iterator {
//    next: 茠 next(),
//    Symbol(Symbol.toStringTag): "RegExp String Iterator"
//    <prototype>: Object { ... }
//  }
```

让我们继续调用[matched.next()]，并记录结果：

```js
// {
//   "done": false,
//   "value": [
//     0: "MasterPuti"
//     groups: undefined
//     index: 0
//     input: "MasterPuti is the best we love MasterPuti"
//   ]
// }
```

这是我们的匹配数组！[next()]给我们一个包含两个值的对象：[done]，当迭代器中有更多元素可用时为[false]，以及[value]，这是我们刚刚迭代的值。所以，如果我们再调用一次：

```js
const regex = /MasterPuti/g;
const str = "MasterPuti is the best we love MasterPuti";
const matched = str.matchAll(regex);
const replaced = str.replaceAll(regex, "MasterPuti");
console.log(matched);
console.log(replaced);
console.log(matched.next());
console.log(matched.next());
```

```js
// {
//   "done": false,
//   "value": Array [ "MasterPuti"]
// }
//
// {
//   "done": false,
//   "value": Array [ "MasterPuti"]
// }
```

等等，为什么它说[done]仍然是[false]？应该只有两个匹配项在数组中，对吧？让我们再调用第三次看看得到什么：

```js
// {
//   "done": false,
//   "value": Array [ "MasterPuti"]
// }
//
// {
//   "done": false,
//   "value": Array [ "MasterPuti"]
// }
//
// {
//   "done": true,
//   "value": undefined
// }
```

[done]终于为[true]了，但为什么那个值是[undefined]？事实证明，[matchAll()]迭代器是惰性的。它不会一次性找到所有匹配项。只有当您通过调用[next()]告诉它时，它才会找到匹配项。

只要它找到匹配项，它就不是[done]。一旦它找不到匹配项并带回[undefined]，它就是[done]。这可能看起来不方便，但对于计算上昂贵的正则表达式来说，这可能非常有帮助。

如果您的示例计算量不大，比如我们的示例，您可以通过将其转换为数组来跳过该功能并一次性提取所有匹配项。这是通过调用[Array.from()]并将迭代器作为参数传递来实现的。

让我们更新代码来使用它——我们会清理我们的[replaceAll]调用，因为我们知道它有效：

```js
const regex = /MasterPuti/g;
const str = "MasterPuti is the best we love MasterPuti";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
```

我们终于得到了匹配项数组：

```js
// [
//   'MasterPuti',
//   index: 0,
//   input: 'MasterPuti is the best we love MasterPuti',
//   groups: undefined
// ]
//
// [
//   'MasterPuti',
//   index: 33,
//   input: 'MasterPuti is the best we love MasterPuti',
//   groups: undefined
// ]
```

这些强大的方法可以帮助您操作和从字符串中提取数据，而无需牺牲性能或可读性。

# --questions--

## --text--

应该向正则表达式添加什么修饰符来匹配字符串中模式的所有出现项？

## --answers--

[/i]

### --feedback--

课程提到了用于全局匹配的特定修饰符。

---

[/m]

### --feedback--

课程提到了用于全局匹配的特定修饰符。

---

[/g]

---

[/a]

### --feedback--

课程提到了用于全局匹配的特定修饰符。

## --video-solution--

3

## --text--

使用全局正则表达式时[match()]和[matchAll()]方法的主要区别是什么？

## --answers--

[match()]返回一个数组，而[matchAll()]返回一个迭代器。

---

[matchAll()]比[match()]更快。

### --feedback--

课程描述了[matchAll()]返回的特殊对象类型。

---

[match()]只能找到第一次出现项，而[matchAll()]能找到所有出现项。

### --feedback--

课程描述了[matchAll()]返回的特殊对象类型。

---

没有区别，它们可以互换使用

### --feedback--

课程描述了[matchAll()]返回的特殊对象类型。

## --video-solution--

1

## --text--

如何将[matchAll()]的结果转换为包含所有匹配项的数组？

## --answers--

通过使用[for...of]循环

### --feedback--

课程演示了将[Iterator]转换为数组的特定方法。

---

通过在结果上调用[toArray()]方法。

### --feedback--

课程演示了将[Iterator]转换为数组的特定方法。

---

通过使用[Array.from()]并将结果作为参数。

---

通过将结果展开到数组字面量中。

### --feedback--

课程演示了将迭代器转换为数组的特定方法。

## --video-solution--

3