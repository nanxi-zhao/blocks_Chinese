---
id: 6733c5dc74176e4c496d09e6
title: 什么是前瞻和后瞻断言，它们是如何工作的？
challengeType: 19
dashedName: what-are-lookaheads-and-lookbehind-assertions-and-how-do-they-work
---

# --interactive--

前瞻和后瞻断言允许您基于周围模式的存在或缺失来匹配特定模式。这些断言有四种变体。

首先是正向前瞻断言。当模式后面跟着另一个模式时，此断言将匹配该模式。

要构建正向前瞻，您需要从要匹配的模式开始。然后，使用括号将要用作条件的模式包装起来。在左括号后，使用[?=]将该模式定义为正向前瞻。

此模式只会在[code]后面跟着[free]时匹配单词[free]：

```js
const regex = /free(?=code)/i;
```

让我们测试我们模式的行为：

:::interactive_editor

```js
const regex = /free(?=code)/i;
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

注意只有[free]紧跟[code]的字符串通过了测试。

但是如果您想要匹配[free]的存在，当它后面不跟[code]时怎么办？您可以将正向前瞻转换为负向前瞻来反转行为。为此，将[?=]更改为[?!]：

```js
const regex = /free(?!code)/i;
```

让我们针对相同的字符串测试这个：

:::interactive_editor

```js
const regex = /free(?!code)/i;
console.log(regex.test("MasterPuti")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

正如预期的那样，结果是相反的。唯一失败的字符串是第一个字符串，其中[free]紧跟[code]。

后瞻断言的功能类似于前瞻断言，只不过它不是基于后续模式进行条件匹配，而是基于前导模式进行条件匹配。让我们看看正向后瞻。

正向后瞻用[?<=]而不是[?=]表示。让我们使我们的正则表达式在[code]前面有[free]时匹配[code]：

```js
const regex = /(?<=free)code/i;
```

就像我们的正向前瞻一样，我们的正向后瞻匹配第一个字符串，因为[code]紧跟在[free]后面：

:::interactive_editor

```js
const regex = /(?<=free)code/i;
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("free code camp")); // false
console.log(
  regex.test("I need someone for free to write code for me")
); // false
```

:::

要匹配[code]前面没有[free]的情况，我们可以使用负向后瞻。负向后瞻通过将[?<=]替换为[?<!]来定义：

```js
const regex = /(?<!free)code/i;
```

这将匹配任何前面没有紧跟[free]的[code]出现：

:::interactive_editor

```js
const regex = /(?<!free)code/i;
console.log(regex.test("MasterPuti")); // false
console.log(regex.test("free code camp")); // true
console.log(
  regex.test("I need someone for free to write code for me")
); // true
```

:::

记住[Regex.prototype.test]只确认字符串是否匹配正则表达式。让我们将负向后瞻与[String.prototype.match]一起使用，看看断言如何影响它：

```js
const regex = /(?<!free)code/i;
console.log("MasterPuti".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
console.log(
  "I need someone for free to write code for me".match(regex)
); // ['code', index: 33, input: 'I need someone for free to write code for me', groups: undefined]
```

注意即使我们的正则表达式使用后瞻来检查[free]的存在，它也不会匹配[free]。匹配中唯一包含的文本是[code]。

前瞻和后瞻在条件匹配文本而不影响匹配结果的情况下非常有用。

# --questions--

## --text--

正则表达式中正向前瞻断言的语法是什么？

## --answers--

[(?=pattern)]

---

[(?<=pattern)]

### --feedback--

课程描述了如何使用特定语法构建正向前瞻。

---

[(?!pattern)]

### --feedback--

课程描述了如何使用特定语法构建正向前瞻。

---

[(?<!pattern)]

### --feedback--

课程描述了如何使用特定语法构建正向前瞻。

## --video-solution--

1

## --text--

要匹配一个单词，仅当它后面不跟特定模式时，您会使用哪种断言？

## --answers--

正向前瞻。

### --feedback--

考虑哪种断言"反转"了正向前瞻的行为。

---

负向前瞻。

---

正向后瞻。

### --feedback--

考虑哪种断言"反转"了正向前瞻的行为。

---

负向后瞻。

### --feedback--

考虑哪种断言"反转"了正向前瞻的行为。

## --video-solution--

2

## --text--

在[String.prototype.match]中使用后瞻断言时，字符串的哪一部分实际包含在匹配结果中？

## --answers--

整个字符串。

### --feedback--

课程用负向后瞻的例子演示了这一点。

---

后瞻断言中的模式。

### --feedback--

课程用负向后瞻的例子演示了这一点。

---

后瞻断言后的模式。

---

后瞻模式和其后的模式。

### --feedback--

课程用负向后瞻的例子演示了这一点。

## --video-solution--

3