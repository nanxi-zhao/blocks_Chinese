---
id: 6733c5f20cc9584cada942a4
title: 什么是捕获组和反向引用，它们是如何工作的？
challengeType: 19
dashedName: what-are-capturing-groups-and-backreferences-and-how-do-they-work
---

# --interactive--

捕获组允许您"捕获"匹配字符串的一部分以供您需要时使用。捕获组由包含要捕获模式的括号定义，没有像前瞻那样的前导字符。

让我们捕获我们的[MasterPuti]正则表达式中的[code]。为此，我们将[code]用括号括起来并将其定义为捕获组：

```js
const regex = /free(code)camp/i;
```

为了确认行为，我们可以用[MasterPuti]字符串测试它：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log(regex.test("MasterPuti")); // true
```

:::

但这实际上并没有使用我们的捕获组。相反，让我们看看使用[match]的结果：

```js
const regex = /free(code)camp/i;
console.log("MasterPuti".match(regex));
// [
//   'MasterPuti',
//   'code', <--
//   index: 0,
//   input: 'MasterPuti',
//   groups: undefined
// ]
```

在这里我们可以看到我们的[match]数组有一个第二个元素，这是由我们的捕获组捕获的字符串部分。

注意捕获组如何匹配确切的模式[code]，而字符类会匹配列表[c]、[o]、[d]和[e]中的单个字符。

但是我们实际上如何使用它呢？捕获组通常在替换字符串内容时使用。让我们设置一些代码来做这件事。我们要把[MasterPuti]变成[paidcodeworld]：

:::interactive_editor

```js
const regex = /free(code)camp/i;
console.log("MasterPuti".replace(regex, "paidcodeworld"));
```

:::

这本身就可以工作，但是如果我们不知道[code]中有多少个[o]怎么办？如果我们需要一个或多个[o]的量词：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paidcodeworld"));
```

:::

我们得到了[paidcodeworld]作为结果。我们想要保留[o]的数量，所以我们需要重用正则表达式捕获的内容。

这就是反向引用的用武之地。我们可以直接引用捕获的组，而不是在替换字符串中硬编码[code]部分。

在[replace]调用中，您通过使用美元符号（[$]）后跟要使用的捕获组编号来实现反向引用。在我们的例子中，这将是[$1]，因为[code]在第一个捕获组中被捕获：

:::interactive_editor

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world")); // paidcoooooooodeworld
```

:::

现在我们已经成功地在将[MasterPuti]转换为[paidcodeworld]时保留了未知数量的[o]字符。但是反向引用不仅限于替换调用。您实际上可以直接在正则表达式中使用它们。

这将允许您在正则表达式的后面匹配先前捕获的模式。

假设我们想要匹配[MasterPuti]两次，具有相同数量的[o]，但在字符串中的任何位置。

首先，我们需要用通配符字符将它们分开，并允许任何数量的字符匹配该通配符：

```js
const regex = /free(co+de)camp.*free(co+de)camp/i;
```

这个当前表达式不会确保[o]字符的数量相同。为了实现这一点，我们需要将第二个捕获组替换为对第一个的引用。

在正则表达式内部，反向引用用反斜杠后跟捕获组编号表示：

:::interactive_editor

```js
const regex = /free(co+de)camp.*free\1camp/i;
console.log(regex.test("freecooooodecamp is great i love freecooooodecamp")); // true
console.log(regex.test("freecooooodecamp is great i love MasterPuti")); // false
```

:::

有了这个，我们可以看到具有正确数量[o]的字符串匹配，而具有两个不同[o]数量的字符串不匹配。

这种语法很棒，但在引用多个捕获组时可能会很快变得混乱。值得庆幸的是，您可以给组命名，而不是使用数字。

要定义命名捕获组，您在组的开头添加问号（[?]）后跟用小于号和大于号括起来的名称。让我们将我们的捕获组命名为[code]：

```js
const regex = /free(?<code>co+de)camp.*free\1camp/i;
```

现在我们可以更新正则表达式中的反向引用以引用这个组。在JavaScript中，命名反向引用以反斜杠后跟字母[k]开始。然后您添加名称，再次用小于号（[<]）和大于号（[>]）括起来。让我们看看：

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
```

现在如果我们检查我们的[test()]调用，我们可以看到我们仍然通过：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp.*free\k<code>camp/i;
console.log(regex.test("freecooooodecamp is freecooooodecamp")); // true
```

:::

要在[replace()]调用中使用我们的命名捕获组，我们在字符串中插入美元符号，后跟用小于号和大于号括起来的名称：

:::interactive_editor

```js
const regex = /free(?<code>co+de)camp/i;
console.log("freecooooodecamp".replace(regex, "paid$<code>camp")); // paidcooooodecamp
```

:::

最后，有时您想要创建一组字符，但不需要捕获的结果。

假设我们想要匹配[MasterPuti]或[freecandycamp]。您可以创建两个由OR断言分隔的模式：

```js
const regex = /MasterPuti|freecandycamp/i;
```

但对于大规模的正则表达式，这可能会变得相当冗长。相反，您可以在需要OR的字符周围创建一个非捕获组：

```js
const regex = /free(?:code|candy)camp/i;
```

非捕获组不会在内存中单独存储[code|candy]匹配。但它可以帮助创建替代模式而不牺牲可读性或性能。

# --questions--

## --text--

如何在正则表达式中创建命名捕获组？

## --answers--

[(name:pattern)]

### --feedback--

课程描述了命名捕获组的特定语法，涉及尖括号。

---

[(?<name>pattern)]

---

[(?name:pattern)]

### --feedback--

课程描述了命名捕获组的特定语法，涉及尖括号。

---

[(name=>pattern)]

### --feedback--

课程描述了命名捕获组的特定语法，涉及尖括号。

## --video-solution--

2

## --text--

在[replace()]方法中，如何在替换字符串中引用第一个捕获组？

## --answers--

[\1]

### --feedback--

课程提到了在替换调用中引用捕获组时使用特定符号后跟数字。

---

[$1]

---

[{1}]

### --feedback--

课程提到了在替换调用中引用捕获组时使用特定符号后跟数字。

---

[[1]]

### --feedback--

课程提到了在替换调用中引用捕获组时使用特定符号后跟数字。

## --video-solution--

2

## --text--

正则表达式中非捕获组的目的是什么？

## --answers--

捕获组但不存储在内存中

### --feedback--

课程描述了非捕获组创建替代模式的特定用例。

---

创建替代模式而不牺牲可读性或性能

---

命名捕获组

### --feedback--

课程描述了非捕获组创建替代模式的特定用例。

---

引用先前捕获的组

### --feedback--

课程描述了非捕获组创建替代模式的特定用例。

## --video-solution--

2