---
id: 6881705cd9860639e98d639d
title: 什么是N+1问题？
challengeType: 19
dashedName: what-is-the-n-plus-1-problem
---

# --description--

N+1问题是在数据库驱动的应用程序中常见的性能瓶颈。如果您曾经在使用应用程序时遇到过很长的加载时间，很可能与N+1问题有关。当许多小查询按顺序执行以获取您请求的数据时，就会出现此问题。

但是为什么要按顺序执行许多查询呢？您可能这样做是为了查询记录列表以及有关这些记录的附加信息。您将执行一个初始查询来获取记录列表，然后为这些记录中的每一个执行一个附加查询，以获取有关它们的附加信息。

即使您直觉上认为执行许多小而简单的查询比执行一个大而复杂的查询更有效，通常情况并非如此。您执行的查询越多，整个过程花费的时间就越长，因为您需要将每个查询发送到服务器，在数据库中查找数据，然后接收服务器为该查询发送的数据。这可能对您的应用程序产生非常显著的性能影响。

为了向您展示一个实际示例，假设您正在为食品配送服务开发应用程序，并运行查询以获取数据库中的前50个订单。首先，您将从[orders]表中获得一个包含这些订单的列表，如下所示：

```sql
order_id | product   | quantity | customer_id
1        | pizza     | 2        | 3422
2        | salad     | 1        | 1255
3        | ice cream | 4        | 2344
4        | donuts    | 10       | 3455
.        | .         | .        | .
.        | .         | .        | .
.        | .         | .        | .
```

但是如果您还需要获取提交这些订单的客户数据怎么办？这些信息将存储在不同的[customers]表中。

解决此问题的一种方法是首先获取订单列表，然后为每个订单运行一个查询以获取客户的详细信息。为了获取订单列表，您可以运行如下查询，以获取[orders]表中的前50条记录：

```sql
SELECT * FROM orders LIMIT 50;
```

这就是N+1中1的来源。这是给您记录列表的初始查询。然后，您需要为这些记录中的每一个执行另一个查询，以获取提交订单的客户的详细信息。为此，您可能在异步函数中编写一个循环来处理订单和客户。[getCustomerData()]函数将执行SQL查询以获取下特定订单的客户数据。它将按顺序为每个下订单执行此操作：

```js
for (const order of orders) {
  const customerId = order.customer_id;
  const customerData = await getCustomerData(customerId);
  // 处理客户的详细数据。
}
```

这就是N+1中N的来源。N表示将执行的查询数量，以获取每条记录的附加数据。

这种方法可能看起来简单直观，但您可能会惊讶地发现这正是您不应该做的事情。您应该避免在循环中进行查询，因为执行多个小查询比执行单个较大的查询来获取所有数据要花费更长的时间。

您应该尝试使用SQL提供的工具来尽可能减少查询数量。在这种情况下，我们可以使用[JOIN]操作来连接[orders]和[customers]表。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name AS customer_name,
  customers.email AS customer_email,
  customers.address AS customer_address
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50)
```

通过[JOIN]操作，我们可以用一个查询检索数据库中前50个订单的数据，包括客户的数据、他们的姓名、电子邮件和地址。这可能看起来更复杂，但实际上这样更有效。

现在您知道了N+1问题涉及什么，因此您可以识别并预防它，以高效地与数据库交互。

# --questions--

## --text--

在SQL上下文中，N+1问题的主要特征是什么？

## --answers--

单个查询中返回过多数据。

### --feedback--

考虑通常涉及的查询数量以及第一个查询之后触发附加查询的内容。

---

执行一个初始查询，后跟N个相关数据的附加查询。

---

数据库索引的低效使用。

### --feedback--

考虑通常涉及的查询数量以及第一个查询之后触发附加查询的内容。

---

由并发数据库事务引起的冲突。

### --feedback--

考虑通常涉及的查询数量以及第一个查询之后触发附加查询的内容。

## --video-solution--

2

## --text--

N+1问题的主要性能影响是什么？

## --answers--

由于复杂连接导致的数据库服务器CPU使用率增加。

### --feedback--

考虑与应用程序和数据库之间通信相关的开销。

---

由于相关数据中的不一致导致的数据完整性降低。

### --feedback--

考虑与应用程序和数据库之间通信相关的开销。

---

由于大型结果集导致的应用程序服务器内存消耗增加。

### --feedback--

考虑与应用程序和数据库之间通信相关的开销。

---

数据库往返次数增加，导致加载时间增加。

## --video-solution--

4

## --text--

减少检索相关数据时数据库查询数量并避免N+1问题的策略包括：

## --answers--

增加数据库连接池大小。

### --feedback--

考虑如何将主数据及其相关信息的检索合并到单个数据库交互中。

---

优化单个SQL查询以提高速度。

### --feedback--

考虑如何将主数据及其相关信息的检索合并到单个数据库交互中。

---

在初始查询中使用JOIN子句获取相关数据。

---

实现客户端数据过滤和排序。

### --feedback--

考虑如何将主数据及其相关信息的检索合并到单个数据库交互中。

## --video-solution--

3