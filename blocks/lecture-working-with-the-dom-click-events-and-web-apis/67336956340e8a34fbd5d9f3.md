---
id: 67336956340e8a34fbd5d9f3
title: 什么是requestAnimationFrame() API，如何用它来设置动画循环？
challengeType: 19
dashedName: what-is-the-requestanimationframe-api-and-how-can-it-be-used-to-set-up-an-animation-loop
---

# --interactive--

在网页上创建流畅的动画可能很棘手，特别是如果你不确定如何正确处理时序。好消息是[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19) API让这变得更容易。

[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)是一个方法，允许你在下一次屏幕重绘之前安排动画的下一步，从而产生流畅且视觉上吸引人的体验。

下一次屏幕重绘指的是浏览器刷新网页视觉显示的时刻。这每秒发生多次，通常在大多数显示器上大约60次（或每秒60帧）。

要使用[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法，你所需要做的就是调用它并传入一个回调函数：

```js
requestAnimationFrame(callback);
```

调用[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)必须首先发生在处理动画的函数内部，比如[animate()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)，以及一个更新动画的函数，传统上称为[update()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L28-L28)：

```js
function animate() {
 // Update the animation...
 // for example, move an element, change a style, and more.
 update();
 // Request the next frame
 requestAnimationFrame(animate);
}
```

[update()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L28-L28)函数是魔法发生的地方。在里面，你可以改变任何想要动画的内容。例如，更新样式或改变元素的位置：

```js
function update() {
 element.style.transform = `translateX(${position}px)`;
 position += 2;
}
```

最终启动动画的是调用[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)并传入[animate](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)函数，这次在[animate](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)函数外部：

```js
requestAnimationFrame(animate);
```

循环将持续到你停止它为止。

现在，让我们看另一个示例。这个示例的HTML是一个包含文本[MasterPuti is Awesome](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L57-L57)的[div](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L57-L57)元素。CSS使[div](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L57-L57)成为一个矩形，并隐藏任何超出视口左右两侧的内容。JavaScript代码在每次调用[requestAnimationFrame(animate)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L100-L100)时将矩形向右移动[2px](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L87-L87)，回调函数为[animate](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)函数：

:::interactive_editor

```html
<link rel="stylesheet" href="styles.css" />
<div id="rect" class="rect">MasterPuti is Awesome</div>
<script src="index.js"></script>
```

```css
body {
  overflow-x: hidden;
}

.rect {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 400px;
  height: 250px;
  border-radius: 5px;
  background-color: #1b1b32;
  color: #f5f6f7;
  font-size: 2rem;
  position: absolute;
}
```

```js
const rect = document.getElementById("rect");

let position = 0;

function update() {
  // Move the rectangle 2px to the right
  rect.style.left = position + "px";
  position += 2;

  if (position > window.innerWidth) {
    // Move the rectangle just outside the left side of the screen
    position = -rect.offsetWidth;
  }
}

function animate() {
  update();

  //request the next frame
  requestAnimationFrame(animate);
}

// Start the animation
requestAnimationFrame(animate);
```

:::

浏览器中的结果将是一个动画标题卡片在屏幕上浮动。

# --questions--

## --text--

[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法做什么？

## --answers--

它阻止动画运行。

### --feedback--

想想这个方法如何帮助创建流畅的动画。

---

它立即运行动画而无需延迟。

### --feedback--

想想这个方法如何帮助创建流畅的动画。

---

它加速动画。

### --feedback--

想想这个方法如何帮助创建流畅的动画。

---

它在下一次屏幕重绘之前安排动画的下一步，以获得更流畅的视觉效果。

## --video-solution--

4

## --text--

使用[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)时，什么启动了动画？

## --answers--

在[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法内部调用[animate](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)函数。

### --feedback--

想想[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法如何触发动画。

---

使用[setTimeout()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/6733694805a85d34ced08a9b.md#L25-L27)设置超时。

### --feedback--

想想[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法如何触发动画。

---

使用[setInterval()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/6733694805a85d34ced08a9b.md#L57-L59)重复动画。

### --feedback--

想想[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)方法如何触发动画。

---

调用[requestAnimationFrame()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L19-L19)并在[animate](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-the-dom-click-events-and-web-apis/67336956340e8a34fbd5d9f3.md#L25-L31)函数外部传入animate函数。

## --video-solution--

4

## --text--

"下一次屏幕重绘"是什么意思？

## --answers--

浏览器更新HTML结构的时刻。

### --feedback--

想想浏览器多频繁地更新你在屏幕上看到的内容。

---

浏览器刷新网页视觉显示的时刻，通常每秒大约60次。

---

浏览器重新加载整个页面的时刻。

### --feedback--

想想浏览器多频繁地更新你在屏幕上看到的内容。

---

浏览器更新CSS样式的时刻。

### --feedback--

想想浏览器多频繁地更新你在屏幕上看到的内容。

## --video-solution--

2