---
id: 67f41341453c2247fb2828f7
title: 数据结构测验
challengeType: 8
dashedName: quiz-data-structures
---

# --description--

要通过测验，你必须正确回答以下 20 道题中的至少 18 题。

# --quizzes--

## --quiz--

### --question--

#### --text--

在算法分析中，大O符号描述的是什么？

#### --distractors--

特定计算机的精确运行时间（秒）。

---

运行期间执行的代码行百分比。

---

代码对其他开发者的可读性。

#### --answer--

时间和空间如何随着输入大小增长（上界）。

### --question--

#### --text--

开始算法挑战时，最好的第一步是什么？

#### --distractors--

立即开始编码以获得动力。

---

在理解问题之前优化性能。

---

仅在完成解决方案后编写单元测试。

#### --answer--

通过示例和边界情况明确问题和约束条件。

### --question--

#### --text--

动态数组和静态数组之间的关键区别是什么？

#### --distractors--

动态数组存储不同类型的值；静态数组不能。

---

静态数组允许重复值；动态数组不允许。

---

动态数组在每次操作中都比静态数组快。

#### --answer--

动态数组可以通过调整大小来增长或缩小；静态数组有固定大小。

### --question--

#### --text--

在动态数组末尾追加元素的摊销时间复杂度是多少？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

`O(1)` 摊销。

### --question--

#### --text--

为什么通过索引访问单链表中的第k个元素需要`O(n)`时间？

#### --distractors--

在任何访问之前必须调整列表大小。

---

索引被哈希并在表中查找。

---

节点连续存储，因此需要移动。

#### --answer--

你必须从头节点逐个遍历到第k个节点。

### --question--

#### --text--

双向链表具有单链表没有的哪个特性？

#### --distractors--

Random access to any index in `O(1)` time.

---

内置数组缓冲区以加快迭代。

---

自动将列表长度维护为常量。

#### --answer--

指向下一个和前一个节点的指针，支持向后遍历。

### --question--

#### --text--

以下哪项最能描述栈？

#### --distractors--

先进先出（`FIFO`），在前端删除。

---

一种可以在`O(1)`时间内删除任何元素的结构。

---

具有常数时间随机访问的循环缓冲区。

#### --answer--

后进先出（`LIFO`），在顶部进行`push`和`pop`操作。

### --question--

#### --text--

哪个操作可以删除队列前端的元素？

#### --distractors--

`push`

---

`pop`

---

`peek`

#### --answer--

`dequeue`

### --question--

#### --text--

在哈希映射中按键查找值的典型平均时间复杂度是多少？

#### --distractors--

`O(n)`，因为所有键都必须按顺序扫描。

---

`O(log n)`，由于桶内的二分查找。

---

`O(n log n)`，因为键在插入期间被排序。

#### --answer--

在良好的哈希函数和低负载因子下平均为`O(1)`。

### --question--

#### --text--

集合数据结构提供哪种保证？

#### --distractors--

元素默认按排序顺序存储。

---

允许重复值并将其保存在一起。

---

元素按其插入位置进行索引。

#### --answer--

它只存储唯一元素（无重复）。

### --question--

#### --text--

在动态数组中，在索引i处插入元素的最坏情况时间复杂度是多少（不在末尾）？

#### --distractors--

`O(1)`

---

`O(log n)`

---

`O(1)` 摊销

#### --answer--

`O(n)`

### --question--

#### --text--

在单链表的头部插入新节点的时间复杂度是多少？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(n log n)`

#### --answer--

`O(1)`

### --question--

#### --text--

哪个操作返回栈顶元素而不删除它？

#### --distractors--

`push`

---

`pop`

---

在底部插入。

#### --answer--

`peek`

### --question--

#### --text--

以下哪项最能描述队列？

#### --distractors--

后进先出（`LIFO`），在顶部删除。

---

Random access to any index in `O(1)` time.

---

元素总是自动保持排序顺序。

#### --answer--

先进先出（`FIFO`），在后端进行`enqueue`，在前端进行`dequeue`。

### --question--

#### --text--

什么是哈希映射中的哈希冲突？

#### --distractors--

当一个键按设计映射到多个不同的值时。

---

当两个相同的键存储在不同的桶中时。

---

当映射耗尽内存且必须调整大小时。

#### --answer--

当两个不同的键产生相同的哈希索引时。

### --question--

#### --text--

为什么哈希映射在增长时会调整大小（重新哈希）？

#### --distractors--

为了按升序排序键以加快迭代。

---

压缩值并减少内存碎片。

---

为了避免触发语言的垃圾收集器。

#### --answer--

保持负载因子低，使平均操作保持`O(1)`。

### --question--

#### --text--

关于集合的哪个陈述是正确的？

#### --distractors--

集合按定义保留插入顺序。

---

集合允许重复元素并保持计数。

---

集合成员测试平均为`O(n log n)`。

#### --answer--

成员测试通常平均为`O(1)`。

### --question--

#### --text--

当n变大时，哪个时间复杂度比`O(n log n)`增长更快？

#### --distractors--

`O(n)`

---

`O(log n)`

---

`O(1)`

#### --answer--

`O(n^2)`

### --question--

#### --text--

在实现暴力解决方案后，一个好的下一步是什么？

#### --distractors--

在测量之前微优化常数因子。

---

丢弃测试并从头开始重写解决方案。

---

避免考虑边界情况以保持代码简单。

#### --answer--

分析其时间和空间复杂度，并优化已识别的瓶颈。

### --question--

#### --text--

空间复杂度衡量什么？

#### --distractors--

程序使用多少个CPU核心。

---

程序的代码行数长度。

---

程序编译需要多长时间。

#### --answer--

内存使用量如何相对于输入大小增长。

