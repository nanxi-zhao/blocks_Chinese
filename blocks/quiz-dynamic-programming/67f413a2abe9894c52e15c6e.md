---
id: 67f413a2abe9894c52e15c6e
title: 动态规划测验
challengeType: 8
dashedName: quiz-dynamic-programming
---

# --description--

要通过测验，你必须正确回答以下 10 道题中的至少 9 题。

# --quizzes--

## --quiz--

### --question--

#### --text--

对于一个问题，动态规划成为有效的解决方案必须具备哪两个基本属性？

#### --distractors--

快速执行时间和最小内存使用

---

递归能力和迭代循环

---

顺序处理和并行计算

#### --answer--

重叠子问题和最优子结构

### --question--

#### --text--

动态规划中，记忆化和制表法两种方法的主要区别是什么？

#### --distractors--

记忆化使用哈希表而制表法使用数组，使其更高效

---

记忆化比制表法更快但使用更多内存和CPU周期

---

记忆化只能解决比制表法更简单的问题

#### --answer--

记忆化是一种使用递归的自顶向下方法，而制表法是一种使用迭代的自底向上方法

### --question--

#### --text--

为什么动态规划问题的朴素递归解法通常具有指数时间复杂度？

#### --distractors--

因为它们使用指数级的内存量来存储变量

---

因为它们需要在指数时间内对数据进行排序

---

因为它们必须检查输入的所有可能排列

#### --answer--

因为每次递归调用都会多次分支，导致相同的子问题被反复重新计算

### --question--

#### --text--

在动态规划的背景下，最优子结构是什么意思？

#### --distractors--

算法必须使用最有效的可用数据结构

---

解决方案必须同时最小化时间和空间复杂度

---

问题必须有唯一、单一的最优解

#### --answer--

最优解可以从其子问题的最优解构建而来

### --question--

#### --text--

在实现记忆化时，当函数被调用且参数已经被计算过时会发生什么？

#### --distractors--

函数重新计算结果以确保准确性

---

函数对旧结果和新结果求平均以获得更好的精度

---

抛出错误，因为不允许重复计算

#### --answer--

立即返回缓存的结果而无需重新计算

### --question--

#### --text--

使用制表法而不是记忆化的一个关键优势是什么？

#### --distractors--

制表法总是比记忆化需要更少的内存

---

制表法可以解决更广泛的问题类别

---

制表法总是更容易实现和理解

#### --answer--

制表法避免了递归开销并提供了可预测的顺序执行

### --question--

#### --text--

在自底向上的动态规划解决方案中，为什么要首先初始化基本情况？

#### --distractors--

为了有效地分配数据结构的内存

---

为了防止算法中的无限循环

---

为了改善算法的时间复杂度

#### --answer--

为了提供构建所有较大子问题的基础值

### --question--

#### --text--

动态规划如何转换具有重叠子问题特性的问题的时间复杂度？

#### --distractors--

通过有效地分割问题，从多项式变为对数

---

通过优化循环结构，从二次变为线性

---

通过使用哈希表，从线性变为常数

#### --answer--

通过存储和重用子问题解决方案，从指数变为多项式

### --question--

#### --text--

动态规划通常做出什么权衡来实现更好的时间复杂度？

#### --distractors--

牺牲代码可读性以获得更快的执行速度

---

需要更复杂的算法，难以维护

---

限制可以解决的问题规模

#### --answer--

使用额外的空间来存储中间结果

### --question--

#### --text--

在什么情况下动态规划不是合适的算法方法？

#### --distractors--

当问题需要找到最优解时

---

当问题可以分解为更小的子问题时

---

当时空复杂度必须最小化时

#### --answer--

当子问题是独立的且不重叠时