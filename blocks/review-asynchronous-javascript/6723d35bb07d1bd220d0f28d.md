---
id: 6723d35bb07d1bd220d0f28d
title: 异步JavaScript复习
challengeType: 31
dashedName: review-asynchronous-javascript
---

# --description--

- **同步JavaScript** 按顺序执行，等待前一个操作完成后再移动到下一个操作。
- **异步JavaScript** 允许多个操作在后台执行，而不会阻塞主线程。
- **线程** 是可以独立于主程序流执行的指令序列。
- **回调函数** 是作为参数传递给其他函数的函数，并在操作完成或作为事件结果时执行。

## JavaScript引擎和JavaScript运行时

- **JavaScript引擎** 是在Web浏览器中执行JavaScript代码的程序。它就像一个转换器，接收你的代码，将其转换为计算机可以理解并相应工作的指令。
- V8是Google开发的JavaScript引擎的一个示例。
- **JavaScript运行时** 是执行JavaScript代码的环境。它包括处理和执行代码的JavaScript引擎，以及Web浏览器或Node.js等附加功能。

## Fetch API

- Fetch API允许Web应用程序发出网络请求，通常用于从服务器检索或发送数据。它提供了一个[fetch()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法，你可以使用它来发出这些请求。
- 你可以使用Fetch API检索文本、图像、音频、JSON和其他类型的数据。

## Fetch API的HTTP方法

Fetch API支持各种HTTP方法与服务器交互。最常见的方法是：

- **GET**：用于从服务器检索数据。默认情况下，Fetch API使用[GET](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法来检索数据。

```js
fetch('https://api.example.com/data')
```

要使用获取的数据，必须使用[.json()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法将其转换为JSON格式：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
```

在此代码中，来自Fetch API的响应是一个承诺，[.then](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)处理程序将响应转换为JSON格式。

- **POST**：用于向服务器发送数据。[POST](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法用于在服务器上创建新资源。

```js
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
})
```

在此示例中，我们正在发送一个[POST](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)请求来创建一个新用户。我们已将方法指定为[POST](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)，设置了适当的标头，并包含了我们要发送的数据体。数据体需要是字符串，因此我们使用[JSON.stringify()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)将对象转换为JSON字符串。

- **PUT**：用于更新服务器上的数据。[PUT](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法用于更新服务器上的现有资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    name: 'John Smith',
    email: 'john@example.com'
  })
})
```

在此示例中，我们正在更新URL末尾指定的ID [45](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)。我们在代码中使用了[PUT](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法，并指定了将用于更新识别数据的数据体。

- **DELETE**：用于删除服务器上的数据。[DELETE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法用于删除服务器上的资源。

```js
fetch('https://api.example.com/users/45', {
  method: 'DELETE'
})
```

在此示例中，我们正在发送一个[DELETE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)请求来删除ID为[45](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)的用户。

## Promise和Promise链

- **Promises** 是表示异步操作最终完成或失败及其结果值的对象。Promise的值只有在[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)操作完成时才知道。
- 这里是一个创建简单Promise的示例：

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received successfully');
  }, 2000);
});
```

- [.then()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法在Promise中用于指定Promise完成时应该发生什么，而[.catch()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)用于处理发生的任何错误。
- 这里是一个使用[.then()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)和[.catch()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)与Promise的示例：

```js
promise
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error(error);
  });
```

在上面的示例中，[.then()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法用于记录从Promise接收到的数据，而[.catch()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法用于记录发生的任何错误。

- **Promise链**：Promises的强大功能之一是我们可以将多个异步操作链接在一起。每个[.then()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)可以返回一个新的Promise，允许你一个接一个地执行一系列异步操作。
- 这里是一个Promise链的示例：

```js
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
    return fetch('https://api.example.com/other-data');
  })
  .then(response => response.json())
  .then(otherData => {
    console.log(otherData);
  })
  .catch(error => {
    console.error(error);
  });
```

在上面的示例中，我们首先从一个URL获取数据，然后基于第一个响应从另一个URL获取数据，最后记录接收到的第二个数据。

[catch](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法将处理过程中发生的任何错误。这意味着你不需要在每个步骤中添加错误处理，这可以大大简化你的代码。

## 使用[async/await](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)处理Promise

Async/await使编写和阅读异步代码更容易，它建立在Promises之上。

- **async**：[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)关键字用于定义异步函数。[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数返回一个Promise，该Promise使用[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数返回的值进行解析。
- **await**：[await](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)关键字在[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数内部使用，以暂停函数的执行直到Promise被解析。它只能在[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数内部使用。
- 这里是一个使用[async/await](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)的示例：

```js
async function delayedGreeting(name) {
  console.log("A Messenger entered the chat...");
  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log(`Hello, ${name}!`);
}

delayedGreeting("Alice");
console.log("First Printed Message!");
```

在上面的示例中，[delayedGreeting](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数是一个[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)函数，在打印问候消息之前暂停2秒。[await](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)关键字用于暂停函数执行直到[Promise](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)被解析。

- [async/await](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)的最大优势之一是通过[try/catch](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)块进行错误处理。这是一个示例：

```js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

在上面的示例中，[try](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)块包含可能抛出错误的代码，而[catch](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)块处理发生的错误。这使得错误处理更加直接和可读。

## [async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性

- [async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性告诉浏览器在继续解析HTML文档的同时异步下载脚本文件。
- 脚本下载完成后，HTML解析会暂停，执行脚本，然后恢复HTML解析。
- 你应该对执行顺序不重要的独立脚本使用[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)

## [defer](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性

- [defer](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性也异步下载脚本，但它会推迟脚本的执行，直到HTML文档完全解析后才执行。
- [defer](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)脚本按照它们在HTML文档中出现的顺序维护执行顺序。

- 需要注意的是，[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)和[defer](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性对于内联脚本都会被忽略，只对[外部](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)脚本文件有效。

- 当[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)和[defer](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性都存在时，[async](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)属性优先。

## 地理定位API

- 地理定位API为网站提供了请求用户位置的方法。

- 下面的示例演示了API的[getCurrentPosition()](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)方法，该方法用于获取用户的当前位置。

```js
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("Latitude: " + position.coords.latitude);
    console.log("Longitude: " + position.coords.longitude);
  },
  (error) => {
    console.log("Error: " + error.message);
  }
);
```

在此代码中，我们正在调用[getCurrentPosition](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)并传递一个函数，该函数将在成功获取位置时被调用。

[position](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)对象包含各种信息，但这里我们只选择了纬度和经度。

如果获取[position](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L103-L103)时出现问题，则错误将被记录到控制台。

- 尊重用户隐私并仅在必要时请求其位置非常重要。

# --assignment--

复习异步JavaScript的主题和概念。