---
id: 6724e2dbf723fe1c8883cc69
title: 前端库复习
challengeType: 31
dashedName: review-front-end-libraries
---

# --description--

## JavaScript 库和框架

- JavaScript 库和框架通过提供预构建的代码来快速解决常见问题并加快开发速度。
- 库通常更专注于为特定任务提供解决方案，如操作 DOM、处理事件或管理 AJAX 请求。
- JavaScript 库的一些示例是 jQuery 和 React。
- 另一方面，框架为构建应用程序提供了更明确的结构。它们通常带有一套开发人员需要遵循的规则和约定。
- 框架的示例包括 Angular 和 React 的元框架 Next.js。
- **单页应用程序**（SPAs）是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序，而无需重新加载整个页面。
- SPA 使用 JavaScript 来管理应用程序的状态并渲染内容。这通常通过提供构建复杂用户界面的强大工具的框架来完成。
- SPA 的一些问题包括：
  - 屏幕阅读器在处理动态更新的内容时遇到困难。
  - 当用户在应用程序内导航时，URL 不会改变，这可能使书签、回溯或分享特定页面变得困难。
  - 如果应用程序很大，初始加载时间可能很慢，因为所有资源都需要预先加载。

## React

- React 是一个流行的用于构建用户界面和 Web 应用程序的 JavaScript 库。
- React 的核心概念是创建可重用的 UI 组件，这些组件可以在数据更改时独立更新和渲染。
- React 允许开发人员描述 UI 应该如何基于应用程序状态看起来。当数据或状态发生变化时，React 会更新和渲染正确的组件。

## React 组件

- 组件是 React 应用程序的构建块，允许开发人员将复杂的用户界面分解为更小、可管理的部分。
- UI 使用 JSX 描述，这是一种 JavaScript 语法扩展，允许开发人员在 JavaScript 中编写类似 HTML 的代码。
- 组件基本上是返回 UI 片段的 JS 函数或类。

这是一个渲染问候消息的简单 React 组件示例：

```jsx
function Greeting() {
  const name = 'Anna';
  return <h1>欢迎，{name}！</h1>;
}
```

要使用该组件，你可以简单地调用：

```jsx
  <Greeting />
```

## 导入和导出 React 组件

- React 组件可以从一个文件导出并在另一个文件中导入。
- 假设你在名为 `City.js` 的文件中有一个名为 `City` 的组件。你可以使用 `export` 关键字导出该组件：

```jsx
// City.js
function City() {
  return <p>纽约</p>;
}

export default City;
```

- 要将 `City` 组件导入到另一个文件中，你可以使用 `import` 关键字：

```jsx
// App.js
import City from './City';

function App() {
  return (
    <div>
      <h1>我最喜欢的城市是：</h1>
      <City />
    </div>
  );
}
```

- `default` 关键字用于表示它是从 `City.js` 文件导出的默认导出。

- 你也可以选择在与组件定义相同的行上导出组件，如下所示：

```jsx
export default function City() {
  return <p>纽约</p>;
}
```

## 使用 Vite 设置 React 项目

- 项目设置工具和 CLI 提供了一种快速简便的方法来启动新项目，让开发人员专注于编写代码而不是处理配置。
- Vite 是一个流行的项目设置工具，可以与 React 一起使用。
- 要使用 Vite 创建新项目，你可以在终端中使用以下命令：

```bash
npm create vite@latest my-react-app -- --template react
```

此命令使用 Vite 的 React 模板创建一个名为 `my-react-app` 的新 React 项目。在项目目录中，你会看到一个 `package.json` 文件，其中列出了项目依赖项和命令。

- 要运行项目，请导航到项目目录并运行以下命令：

```bash
cd my-react-app # 项目目录路径
npm install # 安装 package.json 文件中列出的依赖项
```

- 安装依赖项后，你应该会在项目中看到一个名为 `node_modules` 的新文件夹。

- `node_modules` 文件夹是存储项目所需的所有包和库的地方。

- 要运行你的项目，请使用以下命令：

```bash
npm run dev
```

- 之后，打开浏览器并导航到 `http://localhost:5173` 查看你的 React 应用程序运行。

- 要实际查看启动模板的代码，你可以进入项目中的 `src` 文件夹，你应该会看到 `App.jsx` 文件。

## 在 React 组件中传递 props

- 在 React 中，props（属性的简称）是一种将数据从父组件传递给子组件的方式。这种机制对于创建可重用和动态的 UI 元素是必需的。
- props 可以是任何 JavaScript 值。要将 props 从父组件传递给子组件，你需要在父组件的 JSX 中将 props 作为属性添加。这是一个简单示例：

```jsx
// 父组件
function Parent() {
  const name = 'Anna';
  return <Child name={name} />;
}

// 子组件
function Child(props) {
  return <h1>你好，{props.name}！</h1>;
}
```

你可以使用扩展运算符 `(...)` 传递多个 props，在将它们转换为对象之后。这是一个示例：

```jsx
// 父组件
function Parent() {
  const person = {
    name: 'Anna',
    age: 25,
    city: '纽约'
  };
  return <Child {...person} />;
}
```

在此代码中，扩展运算符 `{...person}` 将 person 对象转换为传递给 Child 组件的各个 props。

## React 中的条件渲染

- React 中的条件渲染允许你创建动态用户界面。它用于根据应用程序中的某些条件或状态显示不同的内容。
- 有几种在 React 中条件渲染内容的方法。一种常见的方法是使用三元运算符。这是一个示例：

```jsx
function Greeting({ isLoggedIn }) {
  return (
    <div>
      {isLoggedIn ? <h1>欢迎回来！</h1> : <h1>请登录</h1>}
    </div>
  );
}
```

- 另一种条件渲染内容的方法是使用逻辑 AND（`&&`）运算符。当你只想在满足某个条件时渲染内容时，这很有用。这是一个示例：

```jsx
function Greeting({ user }) {
  return (
    <div>
      {user && <h1>欢迎，{user.name}！</h1>}
    </div>
  );
}
```

在上面的代码中，只有当 user 对象为真值时，`h1` 元素才会被渲染。

你也可以直接使用 `if` 语句这种方式：

``js
function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return <h1>欢迎回来！</h1>;
  }
  return <h1>请登录</h1>;
}
```

## 在 React 中渲染列表

- 在 React 中渲染列表是在构建用户界面时的常见任务。
- 列表可以使用 JS 数组 `map()` 方法迭代项目数组并返回新的 JSX 元素数组来渲染。
- 例如，如果你有一个要渲染为列表的名称数组，你可以执行以下操作：

```jsx
function NameList({ names }) {
  return (
    <ul>
      {names.map((name, index) => (
        <li key={`${name}-${index}`}>{name}</li>
      ))}
    </ul>
  );
}
```

- 始终记得为每个列表项提供唯一键，以帮助 React 管理更新和渲染角色。有了这些技术，你可以创建灵活、高效和动态的列表到你的 React 应用程序中。

## React 中的内联样式

- React 中的内联样式允许你使用 JavaScript 对象直接将 CSS 样式应用于 JSX 元素。
- 要在 React 中应用内联样式，你可以在 JSX 元素上使用 style 属性。style 属性接受一个对象，其中键是驼峰命名的 CSS 属性，值是相应的值。这是一个示例：

```js
function Greeting() {
  return (
    <h1
      style={{ color: 'blue', fontSize: '24px', backgroundColor: 'lightgray' }}
    >
      你好，世界！
    </h1>
  );
}

export default Greeting;
```

你也可以将样式提取到一个单独的对象中并在 `style` 属性中引用它这种方式：

```jsx
function Greeting() {

  const styles = {
    color: 'blue',
    fontSize: '24px',
    backgroundColor: 'lightgray'
  };

  return <h1 style={styles}>你好，世界！</h1>;
}

export default Greeting;
```

- 内联样式通过允许你根据 props 或状态有条件地应用样式来支持动态样式。以下是根据 prop 有条件地应用样式的示例：

```jsx
function Greeting({ isImportant }) {

  const styles = {
    color: isImportant ? 'red' : 'black',
    fontSize: isImportant ? '24px' : '16px'
  };

  return <h1 style={styles}>你好，世界！</h1>;
}

export default Greeting;
```

- 在上面的代码中，`color` 和 `fontSize` 样式根据 `isImportant` prop 有条件地设置。

## 在 React 中使用事件

- **合成事件系统**：这是 React 处理事件的方式。它作为原生事件（如 `click`、`keydown` 和 `submit` 事件）的包装器。React 中的事件处理程序使用驼峰命名约定。（例如 `onClick`、`onSubmit` 等）

这是在 React 中使用 `button` 元素的 `onClick` 属性的示例：

```jsx
function handleClick() {
  console.log("按钮被点击了！");
}

<button onClick={handleClick}>点击我</button>;
```

在 React 中，事件处理函数通常以 `handle` 前缀开始，以表示它们负责处理事件，如 `handleClick` 或 `handleSubmit`。

当用户操作触发事件时，React 将合成事件对象传递给你的处理程序。该对象的行为与原生 JavaScript 中的事件对象非常相似，提供 `type`、`target` 和 `currentTarget` 等属性。

要防止默认行为（如在 `onSubmit` 事件期间浏览器刷新），你可以调用 `preventDefault()` 方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("表单已提交！");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>提交</button>
</form>;
```

你也可以将处理函数包装在箭头函数中，如下所示：

```jsx
function handleDelete(id) {
  console.log("删除项目：", id);
}

<button onClick={() => handleDelete(1)}>删除项目</button>;
```

## 使用状态和 `useState` Hook

- **状态定义**：在 React 中，状态是包含组件数据的对象。当状态更新时，组件将重新渲染。React 将状态视为不可变的，这意味着你不应该直接修改它。
- **`useState()` Hook**：`useState` hook 是一个函数，允许你在函数组件中声明状态变量。这里是基本语法：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在状态变量中你有以下内容：

- `stateVariable` 保存当前状态值
- `setStateFunction`（设置函数）更新状态变量
- `initialValue` 设置初始状态

这是一个 `Counter` 组件的完整示例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>减少</button>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}

export default Counter;
```

## 渲染和 React 组件

- **定义**：在 React 中，渲染是组件在用户界面（UI）中出现的过程，通常是浏览器。渲染过程包括三个阶段：触发、渲染和提交。

触发阶段发生在 React 检测到某些内容已更改并且用户界面（UI）可能需要更新时。这种更改通常是由于状态或 props 的更新引起的。

一旦触发发生，React 进入渲染阶段。在这里，React 重新评估你的组件并确定要显示什么。为此，React 使用真实 DOM 的轻量级副本，称为虚拟 DOM。使用虚拟 DOM，React 可以快速检查组件中需要更改的内容。

提交阶段是 React 将虚拟 DOM 中的准备好的更改应用到真实 DOM 的阶段。换句话说，这是你在屏幕上看到最终结果的阶段。

## 更新状态中的对象和数组

- **更新状态中的对象**：如果你需要更新状态中的对象，那么你应该首先创建一个新对象或复制现有对象，然后为该新对象设置状态。放入状态中的任何对象都应被视为只读。以下是设置用户姓名、年龄和城市的示例。`handleChange` 函数用于处理用户信息的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "洛杉矶" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>用户资料</h1>
      <p>姓名：{user.name}</p>
      <p>年龄：{user.age}</p>
      <p>城市：{user.city}</p>

      <h2>更新用户年龄</h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>更新用户名字</h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>更新用户城市</h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **更新状态中的数组**：更新状态中的数组时，重要的是不要使用 `push()` 或 `pop()` 等方法直接修改数组。相反，你应该在更新状态时创建一个新数组：

```jsx
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `项目 ${items.length + 1}`,
  };

  // 创建一个新数组
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想从数组中删除项目，你应该使用 `filter()` 方法，该方法在过滤掉你想要删除的内容后返回一个新数组：

```jsx
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用 Refs 引用值

- **`ref` 属性**：你可以通过使用 `ref` 属性在 React 中访问 DOM 节点。以下是展示使用 `ref` 聚焦 `input` 元素的示例。`current` 属性用于访问该 `ref` 的当前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="输入文本" />
      <button onClick={handleFocus}>聚焦输入框</button>
    </div>
  );
};

export default Focus;
```

## 使用 `useEffect` Hook

- **`useEffect()` Hook**：在 React 中，效果是在组件渲染过程之外发生的任何事情。也就是说，任何 React 不直接作为 UI 渲染处理的任何事情。常见示例包括获取数据、更新浏览器标签页标题、读取或写入浏览器本地存储、获取用户位置等等。这些操作与外部世界交互，被称为副作用。React 提供 `useEffect` hook 让你处理这些副作用。`useEffect` 让你在组件渲染或更新后运行函数。

```js
import { useEffect } from "react";

useEffect(() => {
 // 你的副作用逻辑（通常是函数）在这里
}, [dependencies]);
```

效果函数在组件渲染后运行，而可选的 `dependencies` 参数控制效果何时运行。

注意 `dependencies` 可以是"响应值"（状态、props、函数、变量等）数组、空数组或完全省略。以下是这些选项如何控制 `useEffect` 工作方式：

- 如果 `dependencies` 是包含一个或多个响应值的数组，效果将在它们更改时运行。

- 如果 `dependencies` 是空数组，`useEffect` 只在组件首次渲染时运行一次。

- 如果你省略 `dependencies`，效果在每次组件渲染或更新时运行。

## 如何创建自定义 Hooks

- **自定义 Hooks**：自定义 hook 允许你从组件中提取可重用的逻辑，如数据获取、状态管理、切换和副作用（如跟踪在线状态）。在 React 中，所有内置 hook 都以 `use` 一词开头，所以你的自定义 hook 应该遵循相同的约定。

以下是创建 `useDebounce` hook 的示例：

```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

## 在 React 中使用表单

- **受控输入**：当你将输入字段值存储在状态中并通过 `onChange` 事件更新它时，这就是受控输入。这让你完全控制表单数据，并允许即时验证和条件渲染。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">你的名字</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">提交</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控输入**：不是通过 `useState` hook 处理输入，HTML 中的非受控输入通过 DOM 的帮助维护自己的内部状态。由于 DOM 控制输入值，你需要使用 `ref` 来拉取输入字段的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">你的</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">提交</button>
   </form>
 );
}

export default App;
```

## 使用 `useActionState` Hook

- **服务器操作**：这些是在服务器上运行的函数，允许直接在服务器上处理表单，而无需 API 端点。这是来自 Next.js 应用程序的示例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `你好，${name}！` };
}
```

`"use server"` 指令将函数标记为服务器操作。

- **`useActionState` Hook**：此 hook 根据表单提交的结果更新状态。以下是 `useActionState` hook 的基本语法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state` 是操作返回的当前状态。
- `action` 是触发服务器操作的函数。
- `isPending` 是一个布尔值，指示操作当前是否正在运行。
- `actionFunction` 参数是服务器操作本身。
- `initialState` 是表示操作运行前状态起始点的参数。
- `permalink` 是包含表单修改的唯一页面 URL 的可选字符串。

## React 中的数据获取

- **数据获取选项**：在 React 中获取数据有很多不同的方法。你可以使用原生 Fetch API，或第三方工具如 Axios 或 SWR。
- **获取数据时常用的狀態變量**：无论你选择哪种方式在 React 中获取数据，都需要跟踪一些状态片段。第一个是数据本身。第二个将跟踪数据是否仍在获取中。第三个是状态变量，将捕获在数据获取过程中可能发生的任何错误。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由于数据获取是副作用，最好在 `useEffect` hook 中使用 `Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!res.ok) {
        throw new Error("网络响应不正常");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然后，如果数据获取未完成，你可以渲染加载消息，如果获取数据时出错则渲染错误消息，或渲染结果。

```jsx
if (loading) {
  return <p>加载中...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用 Axios，你需要安装并导入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然后你可以使用 `axios.get` 获取数据：

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(()an => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用 `useSWR` hook 获取数据，你需要首先安装并导入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是使用 hook 获取数据的方法：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>加载中...</h2>;
 }
 if (error) {
   return <h2>错误：{error.message}</h2>;
 }

 return (
   <>
     <h2>待办事项</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用 `useOptimistic` Hook

- **`useOptimistic` Hook**：此 hook 用于在等待异步操作在后台完成时保持 UI 响应。它有助于管理 UI 中的"乐观更新"，这是一种基于操作预期结果立即更新 UI 的策略，比如等待服务器响应。

以下是基本语法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState` 是为更好的用户体验立即更新的临时状态。
- `addOptimistic` 是在实际状态更改之前应用乐观更新的函数。
- `actualState` 是操作结果的真实状态值，如从服务器获取数据。
- `updateFunction` 是确定乐观状态应如何更新的函数。

以下是 `TaskList` 组件中使用 `useOptimistic` hook 的示例：

```js
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：这用于渲染 UI 的一部分，并将状态更新标记为非紧急过渡。这允许 UI 在昂贵的更新期间保持响应。以下是基本语法：

```js
startTransition(action)
```

`action` 执行状态更新或触发一些与过渡相关的逻辑。这确保紧急 UI 更新（如打字或点击）不会被阻止。

## 使用 `useMemo` Hook

- **记忆化**：这是一种优化技术，其中基于特定参数缓存（记住）昂贵函数调用的结果。当提供相同参数时，返回缓存的结果而不是重新计算函数。
- **`useMemo` Hook**：此 hook 用于记忆计算值。以下是记忆化排序大数组结果的示例。`expensiveSortFunction` 只会在 `largeArray` 更改时运行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用 `useCallback` Hook

- **`useCallback` Hook**：这用于记忆函数引用。

```js
const handleClick = useCallback(() => {
 // 代码在这里
}, [dependency]);
```

- **`React.memo`**：这用于记忆组件以防止在 prop 未更改时不必要的重新渲染。

```js
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* 展示 */}
   </>
 )
});
```

## 依赖管理工具

- **依赖定义**：在软件中，依赖是指应用程序中的一个组件或模块依赖于另一个组件才能正常工作的关系。依赖在软件应用程序中很常见，因为它们允许开发人员使用其他人创建的预构建函数或工具。React 项目需要的两个核心依赖是 `react` 和 `react-dom` 包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **包管理器定义**：要管理项目中的软件依赖，你需要使用包管理器。包管理器是用于安装、更新和删除依赖的工具。许多流行的编程语言如 JavaScript、Python、Ruby 和 Java 都使用包管理器。流行的 JavaScript 包管理器包括 npm、Yarn 和 pnpm。
- **`package.json` 文件**：这是项目中的关键配置文件，包含有关你的项目的元数据，包括其名称、版本和依赖。它还定义脚本、许可信息和其他设置，帮助管理项目及其依赖。
- **`package-lock.json` 文件**：此文件将锁定你的项目使用的所有包的确切版本。当你更新包时，新版本也会在锁定文件中更新。
- **`node_modules` 文件夹**：此文件夹包含 `package.json` 文件中列出的依赖的实际代码，包括你的项目的直接依赖和这些依赖的任何依赖。
- **开发依赖**：这些是仅用于开发而不在生产中使用的包。例如测试库 Jest。你会将 Jest 安装为开发依赖，因为本地测试应用程序时需要它，但在生产中运行应用程序时不需要。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介绍**：React Router 是一个第三方库，允许你向 React 应用程序添加路由。首先，你需要在现有的 React 项目中安装 React Router，如下所示：

```bash
npm i react-router
```

然后在 `main.jsx` 或 `index.jsx` 文件中，你需要设置路由结构，如下所示：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path` 和 `element` 用于将 URL 和 UI 组件耦合在一起。在这种情况下，我们为首页设置了一个路由，指向 `App` 组件。

- **多个视图和路由设置**：在较大的应用程序中，通常会设置多个视图和路由，如下所示：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

这些示例中的 `index` 属性旨在表示给定路径段的默认路由。因此，`Home` 组件将显示在根 `/` 路径上，而 `ProductsHome` 组件将显示在 `/products` 路径上。

- **嵌套路由**：你可以将路由嵌套在其他路由中，这会导致子路由的路径附加到父路由的路径上。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上面的示例中，热门产品的路径将是 products/trending。

- **动态段**：动态段是 URL 路径的任何部分都是动态的。

```jsx
<Route path=":category" element={<Category />} />
```

在此示例中，我们有一个名为 `category` 的动态段。当用户导航到类似 products/brass-instruments 的 URL 时，视图将更改为 `Category` 组件，你可以根据段动态获取适当的数据。

- **`useParams` Hook**：此 hook 用于访问 URL 路径中的动态参数。

```js
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
   {/* 访问 category 参数：params.category */}
   {/* 其余代码在这里 */}
}
```

## React 框架

- **介绍**：React 框架提供路由、图像优化、数据获取、身份验证等功能。这意味着对于某些用例，你可能不需要为前端和后端应用程序设置单独的应用程序。React 框架的示例包括 Next.js 和 Remix。
- **Next.js 路由**：此路由系统包括对动态路由、并行路由、路由处理程序、重定向、国际化等的支持。

以下是创建自定义请求处理程序的示例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js 图像优化**：`Image` 组件扩展了原生 HTML `img` 元素，允许更快的页面加载和大小优化。这意味着图像只会在进入视口时加载，`Image` 组件将自动为每个设备提供正确大小的图像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
```

## Prop 钻取

- **定义**：Prop 钻取是从父组件向深度嵌套的子组件传递 props 的过程，即使一些子组件不需要这些 props。

## 状态管理

- **Context API**：Context 是指父组件使信息对子组件可用而无需通过 props 显式传递的过程。`createContext` 用于创建上下文对象，该对象代表其他组件将读取的上下文。`Provider` 用于向子组件提供上下文值。

```js
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux 通过提供中央存储和对状态更新的严格控制来处理状态管理。它使用可预测的模式，包括动作、reducers 和中间件。动作是将数据从应用程序发送到 Redux 存储的有效载荷，通常由用户交互触发。Reducers 是指定状态应如何响应这些动作的函数，确保状态以不可变的方式更新。另一方面，中间件充当动作分发和 reducer 之间的桥梁，允许你扩展 Redux 的功能（例如日志记录、处理异步操作），而无需修改核心流程。

- **Zustand**：这种状态管理解决方案适用于中小型应用程序。它通过使用 `useStore` hook 直接在组件和页面中访问状态来工作。这让你可以在不需要动作、reducers 或提供程序的情况下修改和访问数据。

## 使用 React DevTools 调试 React 组件

- **React 开发者工具**：这是你可以在 Chrome、Firefox 和 Edge 中使用的浏览器扩展，用于检查 React 组件和识别性能问题。对于 Safari，你需要安装 `react-devtools` npm 包。安装 React DevTools 并在浏览器中打开 React 应用程序后，打开浏览器开发者工具以访问为调试 React 提供的两个额外选项卡 — 组件和分析器。
- **组件选项卡**：此选项卡以树视图格式显示每个组件。你可以在此选项卡中执行以下操作：
  - 查看应用程序的组件层次结构
  - 实时检查和修改 props、状态和上下文值
  - 检查每个选定组件的源代码
  - 将组件数据记录到控制台
  - 检查组件的 DOM 元素
- **分析器选项卡**：此选项卡帮助你分析组件性能。你可以记录组件性能，以便识别不必要的重新渲染、查看提交持续时间，并随后优化慢速组件。

## React 服务器组件

- **定义**：React 服务器组件是仅在服务器上渲染的 React 组件，仅将最终 HTML 发送到客户端。这意味着这些组件可以直接访问服务器端资源，并大大减少发送到浏览器的 JavaScript 数量。

## 真实性能和感知性能的区别

- **感知性能**：这是用户对网站性能的感知。它是他们对响应性和可靠性的评价。这是一种主观测量，因此很难量化，但它非常重要，因为用户体验决定了网站的成功或失败。
- **真实性能**：这是网站的客观和可测量的性能。它使用页面加载时间、服务器响应时间和渲染时间等指标进行测量。这些测量受与网络和代码本身相关的多个因素影响。

## 提高感知性能的技术

- **懒加载**：这种技术通过在后台加载非必要资源来尽可能减少初始加载时间。
- **最小化字体延迟**：如果你的网站有自定义字体，你还应该尝试最小化字体加载延迟，因为这可能导致闪烁或在自定义字体加载时显示后备字体。建议使用与自定义字体相似的后备字体，这样即使发生这种情况，变化也会更微妙。
- **使用加载指示器**：为长时间运行的进程尽快显示加载指示器，当用户点击元素时可以帮助用户感觉连接和参与过程，使等待时间感觉更短。

## 核心性能概念

- **源代码顺序**：这指的是 HTML 元素在文档中的结构方式。这决定了什么首先加载，可以显著影响性能和可访问性。

源代码顺序的一些最佳实践包括：

- 将关键内容如标题、导航或正文文本放在 HTML 结构的更高位置。
- 延迟非必要脚本如分析脚本或第三方小部件，这样它们不会阻止渲染。
- 使用渐进增强，确保即使在样式和脚本加载之前核心体验也能工作。渐进增强是一种基于首先使页面与 HTML 一起工作的理念构建网站和应用程序的方法。

以下是使用我们刚刚讨论的最佳实践的良好源代码顺序示例：

```html
<h1>欢迎来到 FastSite！</h1>
<p>关键信息首先加载。</p>
<script src="slow-script.js" defer></script>
```

- **关键渲染路径**：这是浏览器将代码转换为屏幕上像素的步骤序列。
- **延迟**：这是请求在浏览器和服务器之间传输所需的时间。换句话说，高延迟等于慢页面。

减少延迟的一些方法包括：

- 使用 CDN（内容分发网络）从更近的位置提供文件。
- 启用压缩，如使用 Gzip 来减少文件大小。
- 优化图像并使用懒加载。

```html
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
```

## 改进 INP

- **定义**：INP（Interaction to Next Paint）通过测量用户交互（如点击或按键）到浏览器更新显示的下一次时间来评估页面的整体响应性。较低的 INP 表示页面响应性更好。

改进 INP 的一些方法包括：

- 通过分解长时间的 JavaScript 任务来减少主线程工作。
- 使用 `requestIdleCallback()` 处理非关键脚本。这将在浏览器空闲期间排队调用函数。
- 延迟或懒加载重资产，这在前面已经介绍过。
- 优化事件处理程序。如果这些处理程序运行过于频繁或执行繁重操作，它们会减慢页面速度并增加 INP。解决方案是防抖。防抖确保函数只在用户停止输入短延迟（例如 300ms）后运行。这可以防止不必要的计算并提高性能。

## 浏览器中的渲染工作原理

- **渲染工作原理**：首先浏览器解析 HTML 并构建 DOM。接下来，浏览器处理 CSS，构建 CSS 对象模型（CSSOM）。这是另一个树结构，规定元素应如何设置样式。最后，浏览器将像素绘制到屏幕上，根据计算的样式和布局渲染每个元素。在复杂的页面中，这可能涉及多个图层，这些图层组合在一起形成最终的视觉输出。

## 性能如何影响可持续性

- **背景信息**：互联网约占全球碳排放的 2%——这与航空业相同！每次字节传输都需要电力，从数据中心到用户设备。较大的文件和低效的脚本意味着更多的功耗。高性能网站不仅更快，还能减少不必要的处理和能源使用。

## 减少页面加载时间的方法

- **优化媒体资源**：大图像和视频是加载时间慢的常见原因。通过优化这些资源，你可以显著加快网站速度。这包括压缩图像、使用现代格式如 WebP 和对资源使用懒加载。
- **利用浏览器缓存**：缓存允许浏览器在本地存储网站的部分内容，减少返回访问者的加载时间。
- **缩小和压缩文件**：减小文件大小可以加快下载速度。这包括减小传输文件的大小和缩小 CSS 和 JavaScript 文件。

## 改进"可用时间"

- **定义**："可用时间"是从用户请求页面到他们可以有意义地与之交互的时间间隔。要改进"可用时间"，你可以懒加载资产或最小化渲染阻塞资源。

## 衡量性能的关键指标

- **首次内容绘制或 FCP**：它测量用户看到的第一块内容（文本或图像）出现在屏幕上的速度。良好的 FCP 被认为是低于 1.8 秒的时间，而糟糕的 FCP 是超过 3 秒。你可以使用 Chrome DevTools 并检查性能选项卡来检查你的 FCP。
- **总阻塞时间**：这显示了主线程被繁重的 JavaScript 任务阻塞的时间。如果总阻塞时间（TBT）很高，用户会体验到迟钝的交互。要改进 TBT，可以分解长时间任务并延迟非必要脚本。
- **跳出率**：这是没有交互就离开的访问者百分比。如果你的网站跳出率很高，可能是因为你的页面太慢。
- **独立用户**：此指标跟踪访问你网站的独立访问者数量。要查看跳出率和独立用户，你可以使用 Google Analytics。它将允许你监控这些指标并提高参与度。

## 常见的性能测量工具

- **Chrome DevTools**：Chrome DevTools 是 Google Chrome 内置的工具，让你可以实时分析和调试性能。DevTools 将显示加载时间、CPU 使用率和渲染延迟。对于测量首次内容绘制（FCP）特别有用，FCP 是用户看到第一个可见内容的速度。如果你的网站感觉很慢，DevTools 将帮助你发现瓶颈。
- **Lighthouse**：这是一个自动化工具，检查性能、SEO 和可访问性。
- **WebPageTest**：此工具让你测试网站从不同位置和设备加载的情况。此工具为你提供网站的速度指数、总阻塞时间和其他关键性能指标的详细分解。如果你想了解真实用户在全球范围内如何体验你的网站，WebPageTest 是适合的工具。
- **PageSpeed Insights**：此工具分析你的网站并为移动和桌面提供快速改进建议。它会告诉你什么拖慢了你的网站，并给出具体建议，如优化图像、删除渲染阻塞脚本和减少服务器响应时间。PageSpeed Insights 是检查 Google 如何看待你网站性能的快速简便方法。
- **真实用户监控**：RUM 工具跟踪实际用户行为，显示真实访问者如何体验你的网站。流行的 RUM 工具包括 Google Analytics，它跟踪页面加载时间和跳出率，以及 New Relic 或 Datadog，它们监控实时性能问题。如果你想获得来自实际用户的数据，RUM 工具是必不可少的。

## 使用性能 Web API

- **定义**：性能 Web API 让开发人员直接在代码中跟踪网页加载和响应的效率。这些 API 允许你测量页面加载时间、跟踪渲染和交互延迟以及分析 JavaScript 执行时间。
- **`performance.now()`**：此 API 提供高精度时间戳（以毫秒为单位），用于测量网站不同部分的加载时间。

```js
const start = performance.now();  
// 在这里运行一些代码  
const end = performance.now();  

console.log(`执行时间：${end - start}ms`);
```

- **Performance Timing API**：此 API 为你提供页面加载每个阶段的分解，从 DNS 查找到 `DOMContentLoaded`。

```js
const timing = performance.timing;  

const pageLoadTime = timing.loadEventEnd - timing.navigationStart;  
console.log(`页面加载时间：${pageLoadTime}ms`);
```

- **`PerformanceObserver`**：此 API 监听性能事件，如布局偏移、长时间任务和用户交互。

```js
const observer = new PerformanceObserver((list) => {  
  list.getEntries().forEach((entry) => {  
    console.log(`检测到长时间任务：${entry.duration}ms`);  
  });  
});  

observer.observe({ type: "longtask", buffered: true });
```

## 改进 CSS 性能的技术

- **CSS 动画**：动画某些 CSS 属性（如尺寸、位置和布局）会触发称为"重排"的过程，在此过程中浏览器重新计算页面上某些元素的位置和几何形状。这需要重绘，这在计算上是昂贵的。因此，建议尽可能减少 CSS 动画或至少给用户一个切换它们开或关的选项。

## 改进 JavaScript 性能的技术

- **代码分割**：将 JavaScript 代码分割成执行关键和非关键任务的模块也很有帮助。这样，你将能够尽快预加载关键模块，并延迟非关键模块以尽快渲染页面。
- **DOM 操作**：请记住，DOM 操作是指通过与文档对象模型（DOM）交互来动态更改页面内容的过程。操作 DOM 在计算上是昂贵的。通过减少 JavaScript 代码中的 DOM 操作数量将提高性能。

## CSS 框架

- **CSS 框架**：CSS 框架可以加快你的工作流程，在网站上创建统一的视觉风格，使你的设计在多个浏览器中看起来一致，并保持你的 CSS 代码更有组织性。
- **流行的 CSS 框架**：一些流行的 CSS 框架是 Tailwind CSS、Bootstrap、Materialize 和 Foundation。
- **潜在的缺点**：
  - 框架提供的 CSS 可能与你的自定义 CSS 冲突。
  - 你的网站可能看起来与使用相同框架的其他网站相似。
  - 大型框架可能导致性能问题。

## 两种类型的 CSS 框架

- **实用优先的 CSS 框架**：这些框架具有特定目的的小类，如设置边距、内边距或背景颜色。你可以根据需要将这些小类直接分配给 HTML 元素。Tailwind CSS 被归类为实用优先的 CSS 框架。

以下是使用 Tailwind CSS 设置按钮样式的示例。

```html
<button class="bg-blue-500 text-white font-bold py-2 px-4 rounded-full hover:bg-blue-700">
  按钮
</button>
```

- **基于组件的 CSS 框架**：这些框架具有预构建的组件和预定义的样式，你可以添加到你的网站。组件在 CSS 框架的官方文档中可用，你可以将它们复制并粘贴到你的项目中。Bootstrap 被归类为基于组件的 CSS 框架。

以下是使用 Bootstrap 创建列表组的示例。不是将小类应用到你的 HTML 元素，而是添加整个组件，包括 HTML 结构。

```html
<div class="card" style="width: 25rem;">
  <ul class="list-group list-group-flush">
    <li class="list-group-item">HTML</li>
    <li class="list-group-item">CSS</li>
    <li class="list-group-item">JavaScript</li>
  </ul>
</div>
```

## Tailwind CSS

Tailwind 是一个实用优先的 CSS 框架。不是编写自定义 CSS 规则，而是通过在 HTML 中组合小的实用类来构建你的设计。

### 响应式设计实用类

Tailwind 使用 `sm:`、`md:` 和 `lg:` 等前缀在不同屏幕尺寸上应用样式。

```html
<div class="w-full md:w-1/2 lg:flex-row">
  响应式布局
</div>
```

### Flexbox 实用类

像 `flex`、`flex-col`、`justify-around` 和 `items-center` 这样的类可以轻松创建灵活的布局。

```html
<div class="flex flex-col md:flex-row justify-around items-center">
  <p>小屏幕上的列</p>
  <p>中等和大屏幕上的行</p>
</div>
```

### Grid 实用类

Tailwind 包括 CSS Grid 的实用类，如 `grid`、`grid-cols-1` 和 `md:grid-cols-3`。

```html
<div class="grid grid-cols-1 md:grid-cols-3 gap-8">
  <div class="bg-gray-100 p-4">第 1 列</div>
  <div class="bg-gray-100 p-4">第 2 列</div>
  <div class="bg-gray-100 p-4">第 3 列</div>
</div>
```

### 间距实用类

像 `mt-8`、`mx-auto`、`p-4` 和 `gap-4` 这样的实用类有助于创建一致的间距，而无需编写 CSS。

```html
<div class="mt-8 p-4 bg-indigo-600 text-white">
  间隔内容
</div>
```

### 排版实用类

像 `uppercase`、`font-bold`、`font-semibold` 和 `text-4xl` 这样的实用类控制文本外观。

你可以设置在断点处调整的字体大小，如 `text-3xl` 和 `md:text-5xl`。

```html
<h1 class="text-3xl md:text-5xl font-semibold text-center">
  响应式标题
</h1>
```

### 颜色和悬停状态

Tailwind 提供了广泛的调色板，如 `text-red-700`、`bg-indigo-600` 和 `bg-gray-100`。

像 `hover:bg-pink-600` 这样的类使交互效果变得简单。

```html
<a href="#" class="bg-pink-500 hover:bg-pink-600 text-white px-4 py-2 rounded-md">
  悬停我
</a>
```

### 边框、环和效果

- **边框**：`border-2 border-red-300` 添加指定厚度和颜色的边框。
- **环**：`ring-1 ring-gray-300` 创建轮廓效果，通常用于焦点或卡片。
- **圆角和缩放**：像 `rounded-md`、`rounded-xl` 和 `scale-105` 这样的类增加光泽。

```html
<div class="p-6 rounded-xl ring-2 ring-fuchsia-500 scale-105">
  突出显示的卡片
</div>
```

### 渐变

Tailwind 支持渐变实用类，如 `bg-gradient-to-r from-fuchsia-500 to-indigo-600`。

```html
<div class="p-4 text-white bg-gradient-to-r from-fuchsia-500 to-indigo-600">
  渐变背景
</div>
```

## CSS 预处理器

- **CSS 预处理器**：CSS 预处理器是扩展标准 CSS 的工具。它将具有扩展语法的代码编译成原生 CSS 文件。它有助于为复杂项目编写更干净、可重用、不重复和可扩展的 CSS。
- **功能**：CSS 预处理器可以提供的功能包括变量、混合、嵌套和选择器继承。
- **流行的 CSS 预处理器**：一些流行的 CSS 预处理器是 Sass、Less 和 Stylus。
- **潜在的缺点**：
  - 将 CSS 规则编译成标准 CSS 可能会导致开销。
  - 编译后的代码可能难以调试。

## Sass

- **Sass**：它是流行的 CSS 预处理器之一。Sass 代表"句法上令人敬畏的样式表"。
- **Sass 支持的功能**：Sass 支持变量、嵌套 CSS 规则、模块、混合、继承和基本数学运算的操作符等功能

## Sass 支持的两种语法

- **SCSS 语法**：SCSS（Sassy CSS）扩展了 CSS 的基本语法。它是 Sass 最广泛使用的语法。SCSS 文件有 `.scss` 扩展名。

以下是定义和使用 SCSS 中变量的示例。

```scss
$primary-color: #3498eb;

header {
  background-color: $primary-color;
}
```

- **缩进语法**：缩进语法是 Sass 的原始语法，也称为"Sass 语法"。

以下是定义和使用缩进语法中变量的示例。

```sass
$primary-color: #3498eb

header
  background-color: $primary-color
```

### 混合

- **混合**：混合允许你将多个 CSS 属性及其值分组到名称下，并在整个样式表中重用该 CSS 代码块。

以下是定义 SCSS 语法中混合的示例。在这种情况下，混合被称为 `center-flex`。它有三个 CSS 属性，使用 flexbox 居中元素。

```scss
@mixin center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

以下是使用你定义的混合的示例。

```scss
section {
  @include center-flex;
  height: 500px;
  background-color: #3289a8;
}
```

## 手动和自动化测试

- **手动测试**：在手动测试中，测试人员将手动遍历应用程序的每个部分并测试不同功能，以确保其正常工作。如果在测试过程中发现任何错误，测试人员会将这些错误报告给软件团队，以便他们可以修复。
- **自动化测试**：在自动化测试中，你可以通过编写单独的程序来自动化测试，检查你的应用程序是否按预期行为。

## 单元测试

- **单元测试**：在单元测试中，你测试每个函数以确保一切都按预期工作。单元测试还可以作为应用程序文档的一种形式，因为它们旨在表示代码的预期行为。
- **单一职责原则**：单一职责原则建议保持每个函数小且负责一件事。
- **常见的 JavaScript 测试框架**：一些常见的测试框架包括 Jest、Mocha 和 Vitest。Jest 是单元测试的流行测试框架。

以下是使用 Jest 的单元测试示例。

首先，你可以创建一个负责返回新格式化字符串的函数：

```javascript
export function getFormattedWord(str) {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
}
```

在单独的 `getFormattedWord.test.js` 文件中，你可以编写一些测试来验证函数是否按预期工作。`getFormattedWord.test.js` 文件将如下所示：

```javascript
import { getFormattedWord } from "./getFormattedWord.js";
import { test, expect } from "jest";

test('将单词的第一个字母大写', () => {
  expect(getFormattedWord('hello')).toBe('Hello');
});
```

- **`expect` 函数**：`expect` 函数用于测试值。
- **匹配器**：匹配器是检查值是否按预期行为的函数。在上面的示例中，匹配器是 `toBe()`。Jest 有各种匹配器。

要使用 Jest，你首先需要使用 `npm i jest` 安装 `jest` 包。你还需要在 `package.json` 文件中添加一个脚本，如下所示：

```js
"scripts": {
  "test": "jest"
},
```

然后，你可以运行 `npm run test` 命令来运行你的测试。

## 软件开发生命周期

- **软件开发生命周期的不同阶段**：
  - **规划阶段**：开发团队从利益相关者那里收集拟议工作的需求。
  - **设计阶段**：软件团队分解需求并决定解决方案的最佳方法。
  - **实施阶段**：软件团队将需求分解为可管理的任务并实施它们。
  - **测试阶段**：这涉及新工作的手动和自动化测试。有时，团队在整个开发阶段测试应用程序以发现和修复出现的任何问题。
  - **部署阶段**：团队将新更改部署到构建或测试环境。
  - **维护阶段**：这涉及修复生产应用程序中客户出现的任何问题。

- **软件开发生命周期的不同模型**：
  - **瀑布模型**：瀑布模型是生命周期的每个阶段都需要在下一阶段开始之前完成的模型。
  - **敏捷模型**：敏捷模型专注于通过将工作分解为冲刺的迭代开发。

## BDD 和 TDD

- **TDD**：测试驱动开发是一种强调先编写测试的方法论。在构建功能之前编写测试为开发人员在开发过程中提供实时反馈。
- **BDD**：行为驱动开发是将一系列测试与业务目标对齐的方法。BDD 中的测试场景应该用技术性和非技术性人员都能理解的语言编写。这种语法的一个示例是 Gherkin。
- **BDD 测试框架**：BDD 测试框架的示例包括 Cucumber、JBehave 和 SpecFlow。

## 单元测试中的断言

- **断言**：断言用于测试代码是否按预期行为。
- **断言库**：Chai 是常用的断言库。其他常见的 JavaScript 断言库是 `should.js` 和 `expect.js`。

以下是使用 Chai 的断言示例，检查 `addThreeAndFour` 函数的返回值是否等于数字 7：

```js
assert.equal(addThreeAndFour(), 7);
```

- **最佳实践**：无论你使用哪个断言库，你应该编写清晰的断言和失败消息，这将帮助你理解哪些测试失败以及原因。

## 模拟、伪造和存根

- **模拟**：模拟是用模拟真实组件行为的虚假数据替换真实数据的过程。例如，你可以在测试中模拟 API 响应，而不是连续进行 API 调用来获取数据。
- **存根**：存根是为应用程序中的预期行为返回预定义响应或虚拟数据的对象。例如，你可以在测试中存根数据库连接的行为，而无需依赖实际的数据库连接。
- **伪造**：伪造是没有复杂性或副作用的真实组件的简化版本。例如，你可以通过将数据存储在内存中而不是与真实数据库交互来伪造数据库。这将允许你在内存中模拟数据库操作，这比处理真实数据库要快得多。

## 功能测试

- **功能测试**：功能测试检查应用程序的功能和特性是否按预期工作。功能测试的目标是针对多个场景测试整个系统。
- **非功能测试**：非功能测试关注性能和可靠性等事物。
- **冒烟测试**：冒烟测试是在开始更广泛测试之前对系统进行基本或关键问题的初步检查。

## 端到端测试

- **端到端测试**：端到端测试，或 E2E，从用户的角度测试真实世界的场景。端到端测试有助于确保你的应用程序对用户来说行为正确且可预测。然而，设置、设计和维护它很耗时。
- **端到端测试框架**：Playwright 是微软开发的流行端到端测试框架。其他端到端测试工具的示例包括 Cypress、Selenium 和 Puppeteer。

以下是使用 Playwright 的 MasterPuti 代码库中的 E2E 测试示例。`beforeEach` 钩子将在每个测试之前运行。测试检查捐赠者在菜单栏中有支持者链接，以及他们的头像周围有特殊的样式边框：

```js
test.beforeEach(async ({ page }) => {
  execSync("node ./tools/scripts/seed/seed-demo-user --set-true isDonating");
  await page.goto("/donate");
});

...

test("菜单应该有支持者链接", async ({ page }) => {
  const menuButton = page.getByTestId("header-menu-button");
  const menu = page.getByTestId("header-menu");

  await expect(menuButton).toBeVisible();
  await menuButton.click();

  await expect(menu).toBeVisible();

  await expect(page.getByRole("link", { name: "支持者" })).toBeVisible();
});

test("头像应该有捐赠者的特殊边框", async ({ page }) => {
  const container = page.locator(".avatar-container");
  await expect(container).toHaveClass("avatar-container gold-border");
});
```

## 可用性测试

- **可用性测试**：可用性测试是让真实用户与应用程序交互以发现应用程序中的任何设计、用户体验或功能问题。可用性测试关注用户对应用程序的直观性。
- **四种常见的可用性测试类型**：
  - **探索性**：探索性可用性测试涉及用户与应用程序的不同功能交互以更好地了解它们的工作原理。
  - **比较性**：比较测试是你将应用程序的用户体验与市场中的类似应用程序进行比较的地方。
  - **评估性**：评估测试是你研究应用程序使用直观性的地方。
  - **验证性**：验证测试是你识别任何会阻止用户有效使用应用程序的主要问题的地方。
- **可用性测试工具**：可用性测试工具的示例包括 Loop11、Maze、Userbrain、UserTesting 和 UXTweak。

## 兼容性测试

- **兼容性测试**：兼容性测试的目标是确保你的应用程序在不同的计算环境中工作。
- **不同类型的兼容性测试**：
  - **向后兼容性**：向后兼容性是指软件与早期版本兼容。
  - **向前兼容性**：向前兼容性是指软件和系统将与未来版本一起工作。
  - **硬件兼容性**：硬件兼容性是软件在不同硬件配置中正常工作的能力。
  - **操作系统兼容性**：操作系统兼容性是软件在不同操作系统（如 macOS、Windows 和 Ubuntu 和 Fedora 等 Linux 发行版）中工作的能力。
  - **网络兼容性**：网络兼容性意味着软件可以在不同的网络条件下工作，如不同的网络速度、协议、安全设置等。
  - **浏览器兼容性**：浏览器兼容性意味着 Web 应用程序可以在 Google Chrome、Safari、Firefox 等不同浏览器中一致地工作。
  - **移动兼容性**：确保你的软件应用程序在各种 Android 和 iOS 设备（包括手机和平板电脑）上工作是很重要的。

## 性能测试

- **性能测试**：在性能测试中，你测试应用程序在不同工作负载下的速度、响应性、可扩展性和稳定性。目标是解决任何类型的性能瓶颈。
- **不同类型的性能测试**：
  - **负载测试**：负载测试确定系统在正常和峰值负载时间的行为。
  - **压力测试**：压力测试是你在极端负载下测试你的应用程序，并查看系统对更高负载的响应情况。
  - **浸泡测试（耐久性测试）**：浸泡测试或耐久性测试是一种负载测试，你在较长时间内以较高负载测试系统。
  - **尖峰测试**：尖峰测试是你急剧增加和减少负载并分析系统对变化的反应。
  - **断点测试（容量测试）**：断点测试或容量测试是你随着时间的推移逐渐增加负载到系统开始失败或退化的点。

## 安全测试

- **安全测试**：安全测试有助于识别漏洞和弱点。
- **安全原则**：
  - **机密性**：这可以防止敏感信息向非预期接收者发布。
  - **完整性**：这涉及防止恶意用户修改用户信息。
  - **身份验证**：这涉及验证用户身份以确保他们被允许使用该系统。
  - **授权**：这是确定经过身份验证的用户被允许执行哪些操作或被允许访问系统的哪些部分的过程。
  - **可用性**：这确保授权用户在需要时可以访问信息和服务。
  - **不可否认性**：这确保发送方和接收方都有交付和验证发送方身份的证明。它保护发送方否认已发送信息。
- **常见的安全威胁**：
  - **跨站脚本（XSS）**：XSS 攻击发生在攻击者将恶意脚本注入网页然后在受害者浏览器的上下文中执行它们时。
  - **SQL 注入**：SQL 注入允许恶意用户将恶意代码注入数据库。
  - **拒绝服务（DoS）攻击**：DoS 攻击是恶意用户用大量请求或流量淹没网站，导致服务器变慢并可能崩溃，使网站对用户不可用。
- **安全测试工具类别**：
  - **静态应用程序安全测试**：这些工具评估应用程序的源代码以识别安全漏洞。
  - **动态应用程序安全测试**：这些工具与应用程序的前端接口以发现潜在的安全弱点。DAST 工具无法访问源代码。
- **渗透测试（pentest）**：渗透测试是一种安全测试，涉及在应用程序上创建模拟网络攻击以识别系统中的任何漏洞。

## A/B 测试

- **A/B 测试**：A/B 测试涉及比较页面或应用程序的两个版本并研究哪个版本表现更好。它也被称为桶测试或分割测试。A/B 测试允许你做出更数据驱动的决策并持续改进用户体验。
- **A/B 测试工具**：用于 A/B 测试的工具示例包括 GrowthBook 和 LaunchDarkly。

## Alpha 和 Beta 测试

一旦初始开发和软件测试完成，让测试人员和真实用户测试应用程序是很重要的。这就是 alpha 和 beta 测试的用武之地。

- **Alpha 测试**：Alpha 测试由一组选定的测试人员完成，他们遍历应用程序以确保在发布到市场之前没有错误。Alpha 测试是验收测试的一部分，利用白盒和黑盒测试技术。
- **Beta 测试**：Beta 测试是应用程序对真实用户可用的地方。用户可以与应用程序交互并提供反馈。Beta 测试也是用户验收测试的一种形式。
- **验收测试**：验收测试确保软件应用程序在发布之前满足业务要求和用户需求。
- **黑盒测试**：黑盒测试只关注应用程序的预期行为。
- **白盒测试**：白盒测试涉及测试人员了解内部组件并对它们执行测试。

## 回归测试

- **回归**：回归是指新变更无意中破坏现有功能的情况。
- **回归测试**：回归测试有助于捕捉回归问题。在回归测试中，你重新运行功能测试来确保一切都按预期工作。
- **回归测试工具**：你可以用来执行回归测试的工具包括 Puppeteer、Playwright、Selenium 和 Cypress。
- **回归测试技术**：
  - **单元回归测试**：这是当你有一个项目列表，每次对应用程序进行重大变更或修复时都需要测试。
  - **部分回归测试**：这涉及有针对性的方法，以确保新变更没有破坏应用程序的特定方面。
  - **完全回归测试**：这针对代码库中的所有功能运行测试。这是最耗时和详细的选项。
- **重新测试**：重新测试用于检查已知问题并确保它们已解决。相比之下，回归测试搜索通过代码库中的最近变更可能发生的未知问题。

## TypeScript 是什么

- **JavaScript**：JavaScript 是一种动态类型语言。这意味着变量可以在运行时接收任何值。动态类型语言的挑战是缺乏类型安全性可能会引入错误。

例如，即使你的 JavaScript 函数期望一个数组，你仍然可以调用它传递一个数字：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上面示例的 `console` 输出将是 `undefined`。

- **TypeScript**：TypeScript 扩展了 JavaScript 语言以包含静态类型，这有助于在运行代码之前捕获由类型不匹配引起的错误。

例如，你可以为 `array` 参数定义类型，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

这种类型定义告诉 TypeScript `array` 参数必须是字符串数组。然后，当你调用 `getRandomValue` 并传递一个数字时，你会得到一个称为编译器错误的错误。

- **编译器**：你需要首先将 TypeScript 代码编译成常规 JavaScript。当你运行编译器时，TypeScript 将评估你的代码，并在类型不匹配时抛出错误。

## TypeScript 中的数据类型

- **TypeScript 中的原始数据类型**：对于原始数据类型 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供了相应的类型关键字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **数组**：你可以用两种不同的语法定义特定类型的数组。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **对象**：你可以定义对象的确切结构。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想让对象具有任何键，但所有值必须是字符串，有两种方法可以定义它：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用类型**：
  - **`any`**：`any` 表示值可以具有任何类型。它告诉编译器停止关心该变量的类型。
  - **`unknown`**：`unknown` 告诉 TypeScript 你 _确实_ 关心值的类型，但你实际上不知道它是什么。`unknown` 通常比 `any` 更受青睐。
  - **`void`**：这是一种特殊类型，你通常只在定义函数时使用。不返回值的函数使用 `void` 返回类型。
  - **`never`**：它表示永远不会存在的类型。

- **`type` 关键字**：这个关键字就像 `const`，但不是声明变量，而是声明类型。

它对于声明自定义类型（如联合类型或仅包含特定值的类型）很有用：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**：接口就像类型的类。它们可以实现或扩展其他接口，是专门的对象类型，通常比 `type` 声明更受青睐，除非你需要 `type` 声明提供的特定功能。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定义返回类型**：你还可以定义函数的 _返回类型_。

下面的示例将返回值定义为字符串。如果你尝试返回任何其他内容，TypeScript 将给出编译器错误。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定义泛型类型**：你可以定义泛型类型并在函数中引用它。它可以被认为是传递给函数以控制函数类型定义行为的特殊参数。

以下是为函数定义泛型类型的示例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 语法告诉 TypeScript 你正在为函数定义泛型类型 `T`。`T` 是泛型类型的常用名称，但你可以使用任何名称。

然后，你告诉 TypeScript `array` 参数是泛型类型值的数组，并且返回值是该相同类型的单个元素。

- **在函数调用中指定类型参数**：你可以使用尖括号在函数名称和参数之间传递类型参数到函数调用。

以下是向函数调用传递类型参数的示例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

这告诉 TypeScript 你期望找到的元素将是输入元素。

## 类型缩小

- **通过真实性缩小**：在下面的示例中，当你尝试访问 `email` 的 `value` 属性时，你会得到编译器错误，因为 `email` _可能_ 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用条件语句确认 `email` 是 _真实_ 的，然后再访问属性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真实性检查也可以反向工作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("找不到邮箱元素！")
}
console.log(email.value);
```

抛出错误结束此代码的逻辑执行，这意味着当你到达 `console.log()` 调用时，TypeScript 知道 `email` _不能_ 是 `null`。

- **可选链**：可选链 `?.` 也是类型缩小的一种形式，基于相同的前提，即如果 `email` 值是 `null`，则属性访问不能发生。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 运算符**：你可以使用条件来检查变量的 _类型_ 使用 `typeof` 运算符。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 关键字**：如果对象来自类，你可以使用 `instanceof` 关键字来缩小类型。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **强制转换**：当 TypeScript 无法自动确定值的类型时，例如下面示例中 `request.json()` 方法的结果，你会得到编译器错误。解决此问题的一种方法是强制转换类型，但这样做会削弱 TypeScript 捕获潜在错误的能力。

``typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **类型守卫**：而不是强制转换类型，你可以编写类型守卫：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 语法表示你的函数返回一个布尔值，当为真时意味着 `user` 值满足 `User` 接口。

## `tsconfig` 文件

- **`tsconfig.json`**：TypeScript 的编译器设置位于项目根目录中的 `tsconfig.json` 文件中。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

以下是上面示例中使用的编译器选项的描述：

- **`compilerOptions`**：`compilerOptions` 属性是你控制 TypeScript 编译器行为的地方。
- **`rootDir` 和 `outDir`**：`rootDir` 和 `outDir` 告诉 TypeScript 哪个目录保存你的源文件，哪个目录应包含转译的 JavaScript 代码。
- **`lib`**：`lib` 属性确定编译器使用哪些类型定义，并允许你包含对特定 ES 版本、DOM 等的支持。
- **`module` 和 `moduleResolution`**：`module` 和 `moduleResolution` 协同工作，管理你的包如何使用模块 - CommonJS 或 ECMAScript。
- **`esModuleInterop`**：`esModuleInterop` 通过自动创建命名空间对象来实现 CommonJS 和 ES 模块之间更顺畅的互操作性。
- **`skipLibCheck`**：`skipLibCheck` 选项跳过验证代码中未通过导入引用的 `.d.ts` 文件。
- **`strict`**：`strict` 标志启用几项检查，如确保正确处理可空类型和在 TypeScript 回退到 `any` 时发出警告。
- **`exclude`**：顶层 `exclude` 属性告诉编译器在编译期间忽略这些 TypeScript 文件。

# --assignment--

复习前端库主题和概念。