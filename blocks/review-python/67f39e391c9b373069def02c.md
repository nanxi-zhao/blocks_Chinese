---
id: 67f39e391c9b373069def02c
title: Python复习
challengeType: 31
dashedName: review-python
---

# --description--

## 什么是Python？

- **介绍**：Python是一种通用编程语言，以其简洁性和易用性而闻名。Python用于许多领域，如数据科学和机器学习、Web开发、脚本和自动化、嵌入式系统和物联网等。
- **常见用例**：Python用于数据科学、机器学习、Web开发、网络安全、自动化和微计算机，如树莓派和MicroPython兼容板。

## Python在本地环境中的使用

- **安装**：在Windows、Mac和Linux上安装Python的最佳方式是从官方Python网站（`https://www.python.org/`）下载安装程序。

## 变量

- **声明变量**：要声明变量，从变量名开始，后跟赋值运算符（`=`），然后是数据类型。这可以是数字、字符串、布尔值等。以下是一些示例：

```py
name = 'John Doe'
age = 25
```

- **变量命名约定**：以下是变量应使用的命名约定：

  - 变量名只能以字母或下划线（_）开头，不能以数字开头。
  - 变量名只能包含字母数字字符（a-z, A-Z, 0-9）和下划线（_）。
  - 变量名区分大小写——`age`、`Age`和`AGE`都被认为是唯一的。
  - 变量名不能是Python的保留关键字，如`if`、`class`或`def`。
  - 多个单词的变量名用下划线分隔。例如：`snake_case`。

## 注释

- **单行注释**：这种类型的注释应用于你想在代码中留下的简短笔记。

```py
# 这是一个单行注释
```

- **多行字符串**：这种类型的字符串可用于留下较大的笔记或注释掉代码部分。

```py
"""
这是一个多行字符串。
这里是被注释掉的代码。

name = 'John Doe'
age = 25
"""
```

- **`print()`函数**：要将数据打印到控制台，可以像这样使用`print()`函数：

```py
print('Hello world!') # Hello world!
```

## Python中的常见数据类型

- **介绍**：Python是一种动态类型语言，像JavaScript一样，这意味着你不需要显式声明变量的类型。语言会根据你分配给变量的内容知道变量的类型。
- **整数**：不带小数的整数：

```py
my_integer_var = 10
print('Integer:', my_integer_var) # Integer: 10
```

- **浮点数**：带小数的数字：

```py
my_float_var = 4.50
print('Float:', my_float_var) # Float: 4.50
```

- **复数**：具有实部和虚部的数字：

```py
my_complex_var = 3 + 4j
print('Complex:', my_complex_var) # Complex: (3+4j)
```

- **字符串**：用引号括起来的字符序列：

```py
my_string_var = 'hello'
print('String:', my_string_var) # String: hello
```

- **布尔值**：表示`True`或`False`的值：

```py
my_boolean_var = True
print('Boolean:', my_boolean_var) # Boolean: True
```

- **集合**：唯一元素的无序集合：

```py
my_set_var = {7, 5, 8}
print('Set:', my_set_var) # Set: {7, 5, 8}
```

- **字典**：键值对的集合，用花括号括起来：

```py
my_dictionary_var = {"name": "Alice", "age": 25}
print('Dictionary:', my_dictionary_var) # Dictionary: {'name': 'Alice', 'age': 25}
```

- **元组**：不可变的有序集合，用括号括起来：

```py
my_tuple_var = (7, 5, 8)
print('Tuple:', my_tuple_var) # Tuple: (7, 5, 8)
```

- **范围**：数字序列，通常在循环中使用：

```py
my_range_var = range(5)
print(my_range_var) # range(0, 5)
```

- **列表**：支持不同数据类型的有序元素集合：

```py
my_list = [22, 'Hello world', 3.14, True]
print(my_list) # [22, 'Hello world', 3.14, True]
```

- **None**：表示 absence of a value 的特殊值：

```py
my_none_var = None
print('None:', my_none_var) # None: None
```

## 不可变类型和可变类型

- **不可变类型**：这些类型一旦声明就不能更改，尽管你可以将它们的变量指向新内容，这称为重新赋值。它们包括整数、浮点数、复数、布尔值、字符串、元组、范围和`None`。
- **可变类型**：这些类型一旦声明就可以更改。你可以添加、删除或更新它们的项目。它们包括集合类型，如列表、集合和字典。
- **`type()`函数**：要查看变量的类型，可以像这样使用`type()`函数：

```py
greeting = 'Hello there!'
age = 21

print(type(greeting)) # <class 'str'>
print(type(age)) # <class 'int'>
```

- **`isinstance()`函数**：用于检查变量是否匹配特定数据类型：

```py
print(isinstance('Hello world', str)) # True
print(isinstance('John Doe', int)) # False
```

## 使用字符串

- **定义**：正如你从JavaScript中回忆的那样，字符串是不可变的，这意味着它们创建后不能更改。在Python中，你可以使用单引号或双引号。建议选择一个规则并坚持使用：

```py
developer = 'Jessica'
city = 'Los Angeles'
```

- **从字符串中访问字符**：你可以像这样使用方括号表示法从字符串中访问字符：

```py
my_str = "Hello world"

print(my_str[0])  # H
print(my_str[6])  # w

print(my_str[-1])  # d
print(my_str[-2]) # l
```

- **转义字符串**：如果字符串包含引号，可以使用反斜杠（`\`）像这样：

```py
msg = 'It\'s a sunny day'
quote = "She said, \"Hello!\""
```

- **字符串连接**：要连接字符串，可以像这样使用`+`运算符：

```py
developer = 'Jessica'
print('My name is ' + developer + '.') # My name is Jessica
```

另一种连接字符串的方法是使用`+=`运算符。这用于在同一步骤中执行连接和赋值，如下所示：

```py
greeting = 'My name is '
developer = 'Jessica.'

greeting += developer
print(greeting) # My name is Jessica.
```

- **`f-strings`**：这是格式化字符串字面量的简称。它允许你处理插值，也使用紧凑和可读的语法进行一些连接：

```py
developer = 'Jessica'
greeting = f'My name is {developer}.'
print(greeting) # My name is Jessica.
```

- **字符串切片**：这是提取字符串部分的时候。这是基本语法：

```py
str[start:stop:step]
```

起始位置表示提取应开始的索引。停止位置是切片应结束的地方。这个位置不包含在内。步长位置表示切片的增量间隔。以下是一些示例：

```py
message = 'Python is fun!'

print(message[0:6])  # Python
print(message[7:])  # is fun!
print(message[::2])  # Pto sfn
```

- **获取字符串长度**：`len()`函数用于返回字符串中的字符数：

```py
developer = 'Jessica'

print(len(developer)) # 7
```

## 使用`in`运算符

- **`in`运算符**：这返回一个布尔值，指定字符或字符串是否存在于字符串中：

```py
my_str = 'Hello world'

print('Hello' in my_str)  # True
print('hey' in my_str)    # False
print('hi' in my_str)    # False
print('e' in my_str)  # True
print('f' in my_str)  # False
```

## 常见字符串方法

- **`str.upper()`**：这返回一个新字符串，所有字符都转换为大写：

```py
developer = 'Jessica'

print(developer.upper()) # JESSICA
```

- **`str.lower()`**：这返回一个新字符串，所有字符都转换为小写：

```py
developer = 'Jessica'

print(developer.lower()) # jessica
```

- **`str.strip()`**：这返回字符串的副本，删除指定的前导和尾随字符（如果方法没有传递参数，则删除前导和尾随空格）。

```py
greeting = '  hello world  '

trimmed_my_str = greeting.strip()
print(trimmed_my_str)  # 'hello world'
```

- **`replace()`**：这返回一个新字符串，将所有旧字符串的出现替换为新字符串。

```py
greeting = 'hello world'

replaced_my_str = greeting.replace('hello', 'hi')
print(replaced_my_str)  # 'hi world'
```

- **`split()`**：这用于使用指定分隔符将字符串拆分为列表。分隔符是指定拆分应发生位置的字符串。

```py
dashed_name = 'example-dashed-name'

split_words = dashed_name.split('-')
print(split_words)  # ['example', 'dashed', 'name']
```

- **`join()`**：这用于将可迭代元素连接成带有分隔符的字符串。可迭代是一个可以循环的元素集合，如列表、字符串或元组。

```py
example_list = ['example', 'dashed', 'name']

joined_str = ' '.join(example_list)
print(joined_str)  # example dashed name
```

- **`str.startswith(prefix)`**：这返回一个布尔值，指示字符串是否以指定前缀开头：

```py
developer = 'Naomi'

result = developer.startswith('N')
print(result)  # True
```

- **`str.endswith(suffix)`**：这返回一个布尔值，指示字符串是否以指定后缀结尾：

```py
developer = 'Naomi'

result = developer.endswith('N')
print(result)  # False
```

- **`str.find()`**：这返回子字符串第一次出现的索引。如果找不到，则返回`-1`：

```py
developer = 'Naomi'

result = developer.find('N')
print(result)  # 0

city = 'Los Angeles'
print(city.find('New')) # -1
```

- **`str.count(substring)`**：这计算子字符串在字符串中出现的次数：

```py
city = 'Los Angeles'
print(city.count('e')) # 2
```

- **`str.capitalize()`**：这返回一个新字符串，第一个字符大写，其他字符小写：

```py
dessert = 'chocolate cake'
print(dessert.capitalize()) # Chocolate cake
```

- **`str.isupper()`**：如果字符串中的所有字母都是大写，则返回`True`，否则返回`False`：

```py
dessert = 'chocolate cake'
print(dessert.isupper()) # False
```

- **`str.islower()`**：如果字符串中的所有字母都是小写，则返回`True`，否则返回`False`：

```py
dessert = 'chocolate cake'
print(dessert.islower()) # True
```

- **`str.title()`**：这返回一个新字符串，每个单词的第一个字母大写：

```py
city = 'los angeles'
print(city.title()) # Los Angeles
```

- **`str.maketrans()`**：此方法用于创建1对1字符映射表以进行转换。它通常与`translate()`方法一起使用，该方法将该表应用于字符串并返回转换后的结果。

```py
trans_table = str.maketrans('abc', '123')
print(trans_table) # {97: 49, 98: 50, 99: 51}

result = 'abcabc'.translate(trans_table)
print(result)  # 123123
```

## 整数和浮点数的常见运算

- **基本数学运算**：在Python中，你可以对整数和浮点数进行基本数学运算，包括加法、减法、乘法和除法：

```py
int_1 = 56
int_2 = 12
float_1 = 5.4
float_2 = 12.0

# 加法

print('Integer Addition:', int_1 + int_2) # Integer Addition: 68
print('Float Addition:', float_1 + float_2) # Float Addition: 17.4

# 减法

print('Int Subtraction:', int_1 - int_2) # Int Subtraction: 44
print('Float Subtraction:',  float_2 - float_1) # Float Subtraction: 6.6

# 乘法

print('Int Multiplication:', int_1 * int_2) # Int Multiplication: 672
print('Float Multiplication:', float_2 * float_1) # Float Multiplication: 64.80000000000001

# 除法

print('Int Division:', int_1 / int_2) # Int Division: 4.666666666666667
print('Float Division:', float_2 / float_1) # Float Division: 2.222222222222222
```

当你将浮点数和整数相加时，结果将转换为浮点数，如下所示：

```py
int_1 = 56
float_1 = 5.4

print(int_1 + float_1) # 61.4
```

- **取模运算符（`%`）**：这返回一个数除以另一个数的余数：

```py
int_1 = 56
int_2 = 12

print(int_1 % int_2) # 8
```

- **地板除法（`//`）**：此运算符用于将两个数相除并将结果向下舍入到最近的整数：

```py
int_1 = 56
int_2 = 12

print(int_1 // int_2) # 4
```

- **指数运算符（`**`）**：此运算符用于将一个数提升到另一个数的幂：

```py
int_1 = 4
int_2 = 2

print(int_1 ** int_2) # 16
```

- **`float()`函数**：你可以使用此函数将整数转换为浮点数。

```py
num = 4

print(float(num)) # 4.0
```

- **`int()`函数**：你可以使用此函数将浮点数转换为整数。

```py
num = 4.0

print(int(num)) # 4
```

- **`round()`函数**：这用于将数字舍入到最近的整数：

```py
num_1 = 3.4
num_2 = 7.7

print(round(num_1)) # 3
print(round(num_2)) # 8
```

- **`abs()`函数**：这用于返回数字的绝对值：

```py
num = -13

print(abs(num)) # 13
```

- **`bin()`函数**：这用于将整数转换为其二进制表示形式的字符串：

```py
num = 56

print(bin(num))  # 0b111000
```

- **`oct()`函数**：这用于将整数转换为其八进制表示形式的字符串：

```py
num = 56

print(oct(num))  # 0o70
```

- **`hex()`函数**：这用于将整数转换为其十六进制表示形式的字符串：

```py
num = 56

print(hex(num))  # 0x38
```

- **`pow()`函数**：这用于将一个数提升到另一个数的幂：

```py
result = pow(2, 3) 
print(result)  # 8
```

## 增强赋值

- **定义**：增强赋值将二进制运算与赋值结合在一个步骤中。它取一个变量，对其应用一个运算与另一个值，并将结果存储回同一变量。

```py
# 加法赋值 
my_var = 10
my_var += 5

print(my_var) # 15

# 减法赋值
count = 14
count -= 3

print(count) # 11

# 乘法赋值 
product = 65
product *= 7

print(product) # 455

# 除法赋值 
price = 100
price /= 4

print(price) # 25.0

# 地板除法赋值 
total_pages = 23
total_pages //= 5

print(total_pages) # 4

# 取模赋值 
bits = 35
bits %= 2

print(bits) # 1

# 指数赋值 
power = 2
power **= 3

print(power) # 8
```

还有其他增强赋值运算符，如位运算符的那些。它们包括`&=`、`^=`、`>>=`和`<<=`。

## 使用函数

- **定义**：函数是可重用的代码片段，接受输入（参数）并返回输出。要调用函数，你需要引用函数名后跟一组括号：

```py
# 定义函数

def get_sum(num_1, num_2):
    return num_1 + num_2

result = get_sum(3, 4) # 函数调用
print(result) # 7
```

如果函数没有显式返回值，则默认返回值为`None`：

```py
def greet():
    print('hello') 

result = greet() # hello
print(result) # None
```

你也可以像这样为参数提供默认值：

```py
def get_sum(num_1, num_2=2):
    return num_1 + num_2

result = get_sum(3) 
print(result) # 5
```

如果你调用函数时参数数量不正确，你会得到一个`TypeError`：

```py
def calculate_sum(a, b):
    print(a + b)

calculate_sum()

# TypeError: calculate_sum() missing 2 required positional arguments: 'a' and 'b'
```

## 常见内置函数

- **`input()`函数**：这用于提示用户输入一些内容：

```py
name = input('What is your name?') # 用户输入'Kolade'并按回车  
print('Hello', name) # Hello Kolade
```

- **`int()`函数**：这用于将数字、布尔值或数字字符串转换为整数：

```py
print(int(3.14)) # 3
print(int('42')) # 42
print(int(True)) # 1
print(int(False)) # 0 
```

## 装饰器

- **定义**：装饰器是Python中一种特殊的函数。它们就像其他函数的包装器，所以它们将另一个函数作为参数。

```py
def say_hello():
    name = input('What is your name? ')
    return 'Hello ' + name

def uppercase_decorator(func):
    def wrapper():
        original_func = func()
        modified_func = original_func.upper()
        return modified_func
    return wrapper

say_hello_res = uppercase_decorator(say_hello)

print(say_hello_res())
```

## Python中的作用域

- **局部作用域**：这是在函数或类内声明的变量，只能在该函数或类内访问。

```py
def my_func():
    num = 10
    print(num)
```

- **封闭作用域**：这是嵌套在另一个函数内的函数可以访问其嵌套函数的变量。

```py
def outer_func():
    msg = 'Hello there!'

    def inner_func():
        print(msg)
    inner_func()

print(outer_func()) # Hello there!
```

- **全局作用域**：这指的是在任何函数或类之外声明的变量，可以从程序的任何地方访问。

```py
tax = 0.70 

def get_total(subtotal):
    total = subtotal + (subtotal * tax)
    return total

print(get_total(100))  # 170.0
```

- **内置作用域**：Python中为预定义函数、模块、关键字和对象保留的名称。

```py
print(str(45)) # '45'
print(type(3.14)) # <class 'float'>
print(isinstance(3, str)) # False
```

## 比较运算符

- **等于（`==`）**：检查两个值是否相等：

```py
print(3 == 4) # False
```

- **不等于（`!=`）**：检查两个值是否不相等：

```py
print(3 != 4) # True
```

- **严格大于（`>`）**：检查一个值是否大于另一个值：

```py
print(3 > 4) # False
```

- **严格小于（`<`）**：检查一个值是否小于另一个值：

```py
print(3 < 4) # True
```

- **大于或等于（`>=`）**：检查一个值是否大于或等于另一个值：

```py
print(3 >= 4) # False
```

- **小于或等于（`<=`）**：检查一个值是否小于或等于另一个值：

```py
print(3 <= 4) # True
```

## 使用`if`、`elif`和`else`语句

- **`if`语句**：这些是用于确定某事是否为真的条件。如果条件评估为`True`，则该代码块将运行。

```py
age = 18

if age >= 18:
    print('You are an adult') # You are an adult
```

- **`elif`语句**：这些是跟在`if`语句后面的条件。如果`elif`条件评估为`True`，则该代码块将运行。

```py
age = 16

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')  # You are a teenager
```

- **`else`子句**：如果没有其他条件评估为`True`，则运行此子句。

```py
age = 12

if age >= 18:
    print('You are an adult')
elif age >= 13:
    print('You are a teenager')
else:
    print('You are a child')  # You are a child
```

你也可以像这样使用嵌套的`if`语句：

```py
is_citizen = True
age = 25

if is_citizen:
    if age >= 18:
        print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

## 真值和假值

- **定义**：在Python中，每个值都有一个固有的布尔值，或者在逻辑上下文中有内置的意义，即它应该被视为`True`还是`False`。许多值被认为是真值，即它们在逻辑上下文中评估为`True`。其他的则是假值，意味着它们评估为`False`。以下是一些假值示例：

```md
None
False
Integer 0
Float 0.0
Empty strings ''
```

其他值如非零数字和非空字符串是真值。

## 使用`bool()`函数

- **定义**：如果你想检查一个值是真值还是假值，可以使用内置的`bool()`函数。它显式地将值转换为其布尔等价物，并为真值返回`True`，为假值返回`False`。以下是一些示例：

```py
print(bool(False)) # False
print(bool(0))  # False
print(bool('')) # False

print(bool(True)) # True
print(bool(1)) # True
print(bool('Hello')) # True
```

## 布尔运算符和短路

- **定义**：这些是特殊运算符，允许你组合多个表达式，以在代码中创建更复杂的决策逻辑。Python中有三个布尔运算符：`and`、`or`和`not`。
- **`and`运算符**：此运算符接受两个操作数，如果第一个操作数是假值则返回第一个操作数，否则返回第二个操作数。两个操作数都必须是真值，表达式才能产生真值。

```py
is_citizen = True
age = 25

print(is_citizen and age) # 25
```

你也可以在条件中像这样使用`and`运算符：

```py
is_citizen = True
age = 25

if is_citizen and age >= 18:
    print('You are eligible to vote') # You are eligible to vote
else:
    print('You are not eligible to vote')
```

- **`or`运算符**：此运算符如果第一个操作数是真值则返回第一个操作数，否则返回第二个操作数。如果至少有一个操作数是真值，则or表达式产生真值。以下是一个示例：

```py
age = 19
is_employed = False

print(age or is_employed) # 19
```

就像`and`运算符一样，你可以在条件中像这样使用`or`运算符：

```py
age = 19
is_student = True

if age < 18 or is_student:
    print('You are eligible for a student discount') # You are eligible for a student discount
else:
    print('You are not eligible for a student discount')
```

- **短路**：`and`和`or`运算符被称为短路运算符。短路意味着Python从左到右检查值，并在确定最终结果后立即停止。
- **`not`运算符**：此运算符接受单个操作数并反转其布尔值。它将真值转换为`False`，将假值转换为`True`。与我们之前看过的运算符不同，`not`总是返回`True`或`False`。以下是一些示例：

```py
print(not '') # True, 因为空字符串是假值
print(not 'Hello') # False, 因为非空字符串是真值
print(not 0) # True, 因为0是假值
print(not 1) # False, 因为1是真值
print(not False) # True, 因为False是假值
print(not True) # False, 因为True是真值
```

以下是条件中`not`运算符的示例：

```py
is_admin = False

if not is_admin:
    print('Access denied for non-administrators.') # Access denied for non-administrators.
else:
    print('Welcome, Administrator!')
```

## Python列表

- **介绍**：在Python中，列表数据类型是由字符串、数字甚至其他列表组成的有序元素序列。列表是可变的且从零开始索引。

```python
cities = ['Los Angeles', 'London', 'Tokyo']
```

- **访问列表中的元素**：要从`cities`列表中访问元素，可以引用其在序列中的索引号：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[0] # Los Angeles
```

- **使用负索引访问元素**：要访问任何列表的最后一个元素，可以使用`-1`作为索引号：

```python
cities = ['Los Angeles', 'London', 'Tokyo']
cities[-1] # Tokyo
```

- 负索引用于从列表末尾而不是从索引`0`开始访问元素。

- **使用`list()`构造函数创建列表**：也可以使用`list()`构造函数创建列表。`list()`构造函数用于将可迭代对象转换为列表：

```python
developer = 'Jessica'

print(list(developer)) 
# 结果: ['J', 'e', 's', 's', 'i', 'c', 'a']
```

- **查找列表的长度**：可以使用`len()`函数获取列表的长度：

```python
numbers = [1, 2, 3, 4, 5]
len(numbers) # 5
```

- **列表可变性**：列表是可变的，这意味着只要传入有效的索引号，就可以更新列表中的任何元素。要更新特定索引处的列表，可以为该索引分配新值：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[0] = 'JavaScript'
print(programming_languages) # ['JavaScript', 'Java', 'C++', 'Rust']
```

- **索引超出范围错误**：如果传入超出列表范围的索引（正数或负数），则会收到`IndexError`：

```python
programming_languages = ['Python', 'Java', 'C++', 'Rust']
programming_languages[10] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
"""
```

- **从列表中删除元素**：可以使用`del`关键字从列表中删除元素：

```python
developer = ['Jane Doe', 23, 'Python Developer']
del developer[1]
print(developer) # ['Jane Doe', 'Python Developer']
```

- **检查元素是否存在于列表中**：可以使用`in`关键字检查元素是否存在于列表中：

```py
programming_languages = ['Python', 'Java', 'C++', 'Rust']

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **嵌套列表**：列表可以嵌套在其他列表中：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
```

- 要访问嵌套列表，需要使用索引`2`来访问，因为列表是从零开始索引的。

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2] # ['Python', 'Rust', 'C++']
```

- 要进一步访问嵌套列表中的第二种语言，需要使用索引`1`来访问：

```python
developer = ['Alice', 25, ['Python', 'Rust', 'C++']]
developer[2][1] # Rust
```

- **从列表中解包值**：从列表中解包值是一种将列表中的值分配给新变量的技术。以下是将`developer`列表解包到名为`name`、`age`和`job`的新变量中的示例：

```py
developer = ['Alice', 34, 'Rust Developer']
name, age, job = developer
```

- **收集列表中的剩余项目**：要收集列表中的任何剩余元素，可以使用星号（`*`）运算符，如下所示：

```py
developer = ['Alice', 34, 'Rust Developer']
name, *rest = developer
```

- 如果赋值运算符左侧的变量数量与列表中的项目总数不匹配，则会收到`ValueError`。

- **切片列表**：切片是使用切片运算符`:`访问列表一部分的概念。要切片从索引`1`开始到索引`3`结束的列表，可以使用以下语法：

```python
desserts = ['Cake', 'Cookies', 'Ice Cream', 'Pie']
desserts[1:3] # ['Cookies', 'Ice Cream']
```

- **步长间隔**：也可以指定步长间隔，确定索引之间的增量。以下是使用切片提取偶数列表的示例：

```python
numbers = [1, 2, 3, 4, 5, 6]
numbers[1::2] # [2, 4, 6]
```

## 列表方法

- **append()**：用于在列表末尾添加项目。以下是使用`append()`方法将数字`6`添加到`numbers`列表的示例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.append(6)
print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **追加列表**：`append()`方法也可用于在另一个列表末尾添加一个列表：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.append(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, [6, 8, 10]]
```

- **extend()**：用于在列表末尾添加多个项目。以下是将数字`6`、`8`和`10`添加到`numbers`列表末尾的示例：

```py
numbers = [1, 2, 3, 4, 5]
even_numbers = [6, 8, 10]

numbers.extend(even_numbers)
print(numbers) # [1, 2, 3, 4, 5, 6, 8, 10]
```

- **insert()**：用于在列表的特定索引处插入项目。以下是使用`insert()`方法的示例：

```py
numbers = [1, 2, 3, 4, 5]
numbers.insert(2, 2.5)

print(numbers) # [1, 2, 2.5, 3, 4, 5]
```

- **remove()**：用于从列表中删除项目。`remove()`方法只会删除列表中项目的第一次出现：

```py
numbers = [1, 2, 3, 4, 5, 5, 5]
numbers.remove(5)

print(numbers) # [1, 2, 3, 4, 5, 5]

```

- **pop()**：用于从列表中删除特定项目并返回它：

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop(1) # 数字2被返回
```

- 如果没有为`pop`方法指定元素，则删除最后一个元素。

```py
numbers = [1, 2, 3, 4, 5]
numbers.pop() # 数字5被返回
```

- **clear()**：用于从列表中删除所有项目：

```py
numbers = [1, 2, 3, 4, 5]
numbers.clear()

print(numbers) # []
```

- **sort()**：`sort()`方法用于就地排序元素。以下是就地排序随机`numbers`列表的示例：

```py
numbers = [19, 2, 35, 1, 67, 41]
numbers.sort()

print(numbers) # [1, 2, 19, 35, 41, 67]
```

- **sorted()**：用于排序列表中的元素并返回新的排序列表，而不是修改原始列表。

- **reverse()**：用于反转列表中元素的顺序：

```py
numbers = [6, 5, 4, 3, 2, 1]
numbers.reverse()

print(numbers) # [1, 2, 3, 4, 5, 6]
```

- **index()**：用于查找元素在列表中首次出现的索引：

```python
programming_languages = ['Rust', 'Java', 'Python', 'C++']
programming_languages.index('Java') # 1
```

- 如果使用`index()`方法找不到元素，则结果将是`ValueError`。

## Python中的元组

- **定义**：元组是Python数据类型，用于创建有序的值序列。元组可以包含混合的数据类型：

```py
developer = ('Alice', 34, 'Rust Developer')
```

- 元组是不可变的，这意味着元组中的元素一旦创建就不能更改。如果尝试更新元组中的项目，将收到`TypeError`：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')
programming_languages[0] = 'JavaScript'

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object does not support item assignment
"""
```

- **从元组中访问元素**：要从元组中访问元素，使用方括号表示法和索引号：

```py
developer = ('Alice', 34, 'Rust Developer')
developer[1] # 34
```

- 可以使用负索引从元组末尾开始访问元素：

```py
numbers = (1, 2, 3, 4, 5)
numbers[-2] # 4
```

- 如果尝试传入超过或等于元组长度的索引号，则会收到`IndexError`：

```py
numbers = (1, 2, 3, 4, 5)
numbers[7]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: tuple index out of range
"""
```

- 也可以使用`tuple()`构造函数创建元组。在构造函数中，可以传入不同的可迭代对象，如字符串、列表甚至其他元组。

```python
developer = 'Jessica'

print(tuple(developer)) 
# 结果: ('J', 'e', 's', 's', 'i', 'c', 'a')
```

- **验证元组中的项目**：要检查项目是否在元组中，可以使用`in`关键字，如下所示：

```py
programming_languages = ('Python', 'Java', 'C++', 'Rust')

'Rust' in programming_languages # True
'JavaScript' in programming_languages # False
```

- **解包元组**：可以像这样从元组中解包项目：

```py
developer = ('Alice', 34, 'Rust Developer')
name, age, job = developer
```

- 如果需要收集元组中的任何剩余元素，可以使用星号（`*`）运算符，如下所示：

```py
developer = ('Alice', 34, 'Rust Developer')
name, *rest = developer
```

- **切片元组**：切片可用于提取元组的一部分。例如，项目`pie`和`cookies`可以切片到单独的元组中：

```py
desserts = ('cake', 'pie', 'cookies', 'ice cream')
desserts[1:3] # ('pie', 'cookies')
```

- **从元组中删除项目**：从元组中删除项目将引发`TypeError`，因为元组是不可变的：

```py
developer = ('Jane Doe', 23, 'Python Developer')
del developer[1]

"""
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: "tuple" object doesn't support item deletion
"""
```

- **何时使用元组而不是列表？**：如果你需要一个动态的元素集合，可以在其中添加、删除和更新元素，则应使用列表。如果你知道正在处理固定且不可变的数据集合，则应使用元组。

## 常见元组方法

- **`count()`**：用于确定项目在元组中出现的次数。例如，可以检查语言`'Rust'`在元组中出现的次数：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('Rust') # 2
```

- 如果`count()`函数中指定的项目在元组中根本不存在，则返回值将为`0`：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.count('JavaScript') # 0
```

- 如果没有向`count()`函数传递任何参数，则Python将返回`TypeError`。

- **index()**：用于查找特定项目在元组中的索引。以下是使用`index()`方法查找语言`'Java'`索引的示例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust')
programming_languages.index('Java') # 1
```

- 如果找不到指定的项目，则Python将返回`ValueError`。

- 可以向`index()`方法传递可选的起始索引，以指定在元组中开始搜索项目的位置：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
programming_languages.index('Python', 3) # 5
```

- 也可以向`index()`方法传递可选的结束索引，以指定在元组中停止搜索项目的位置：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python', 'JavaScript', 'Python')
programming_languages.index('Python', 2, 5) # 2
```

- **`sorted()`**：用于排序任何可迭代对象中的元素并返回新的排序列表。以下是使用`sorted()`函数创建新数字列表的示例：

```py
numbers = (13, 2, 78, 3, 45, 67, 18, 7)
sorted(numbers) # [2, 3, 7, 13, 18, 45, 67, 78]
```

- **修改排序行为**：可以使用可选的`reverse`和`key`参数自定义可迭代对象的排序行为。以下是使用`key`参数按长度排序元组中项目的示例：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')
sorted(programming_languages, key=len)

# 结果
# ['C++', 'Rust', 'Java', 'Rust', 'Python', 'Python']
```

- 可以使用`reverse`参数创建按相反顺序排列的新值列表，如下所示：

```py
programming_languages = ('Rust', 'Java', 'Python', 'C++', 'Rust', 'Python')

print(sorted(programming_languages, reverse=True))

# 结果
# ['Rust', 'Rust', 'Python', 'Python', 'Java', 'C++']
```

## Python中的循环

- **定义**：循环用于重复执行代码块指定次数。

- **`for`循环**：用于遍历序列（如列表、元组或字符串）并对该序列中的每个项目执行代码块。以下是使用`for`循环遍历列表并将每种语言打印到控制台的示例：

```py
programming_languages = ['Rust', 'Java', 'Python', 'C++']

for language in programming_languages:
    print(language)

"""
结果 

Rust
Java
Python
C++
"""
```

- 以下是使用`for`循环遍历字符串`code`并打印每个字符的示例：

```py
for char in 'code':
    print(char)

"""
结果 

c
o
d
e
"""
```

- `for`循环可以嵌套。以下是使用嵌套`for`循环的示例：

```py
categories = ['Fruit', 'Vegetable']
foods = ['Apple', 'Carrot', 'Banana']

for category in categories:
    for food in foods:
        print(category, food)

"""
结果

Fruit Apple
Fruit Carrot
Fruit Banana
Vegetable Apple
Vegetable Carrot
Vegetable Banana
"""

```

- **`while`循环**：重复执行代码块直到条件为`False`。以下是使用`while`循环进行猜数字游戏的示例：

```py
secret_number = 3
guess = 0

while guess != secret_number:
    guess = int(input('猜一个数字 (1-5): '))
    if guess != secret_number:
        print('错了！再试一次。')

print('你猜对了！')

"""
结果

猜一个数字 (1-5): 2
错了！再试一次。
猜一个数字 (1-5): 1
错了！再试一次。
猜一个数字 (1-5): 3
你猜对了！
"""

```

- **`break`和`continue`语句**：用于修改循环的执行。

- `break`语句用于在满足特定条件时立即退出循环。以下是使用`break`语句处理`developer_names`列表的示例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        break
    print(developer)
```

- `continue`语句用于跳过当前迭代并进入循环的下一次迭代。以下是使用`continue`语句而不是`break`语句的示例：

```py
developer_names = ['Jess', 'Naomi', 'Tom']

for developer in developer_names:
    if developer == 'Naomi':
        continue
    print(developer)
```

- `for`和`while`循环都可以与`else`子句结合使用，该子句仅在循环未被`break`终止时执行：

```python
words = ['sky', 'apple', 'rhythm', 'fly', 'orange']

for word in words:
    for letter in word:
        if letter.lower() in 'aeiou':
            print(f"'{word}' 包含元音 '{letter}'")
            break
    else:
        print(f"'{word}' 没有元音")
```

## 范围及其在循环中的使用

- **`range()`函数**：用于生成整数序列。

```py
range(start, stop, step)
```

- 必需的`stop`参数是一个整数（不包含），表示生成数字序列的终点。以下是使用`range()`函数的示例：

```py
for num in range(3):
    print(num)
```

- 如果未指定`start`参数，则默认为`0`。默认情况下，整数序列将按`1`递增。可以使用可选的`step`参数更改默认增量值。以下是生成从2到但不包括11（即包括10）的偶数整数序列的示例：

```py
for num in range(2, 11, 2):
    print(num)
```

- 如果不向`range()`函数提供任何参数，则会收到`TypeError`。

- `range()`函数只接受整数作为参数，不接受浮点数。使用浮点数也会导致`TypeError`：

```py
ERROR!
Traceback (most recent call last):
  File "<main.py>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

- 可以为`step`参数使用负整数来生成递减顺序的整数序列：

```py
for num in range(40, 0, -10):
    print(num)
```

- `range()`函数还可以通过与`list`构造函数一起使用来创建整数列表。`list`构造函数用于将可迭代对象转换为列表。以下是生成包含2到10之间偶数整数的列表的示例：

```py
numbers = list(range(2, 11, 2))
print(numbers) # [2, 4, 6, 8, 10]
```

## Python中的`enumerate()`和`zip()`函数

- **`enumerate()`**：用于遍历序列并跟踪该序列中每个项目的索引。`enumerate()`函数将可迭代对象作为参数，并返回由索引和可迭代对象中每个项目的值组成的`enumerate`对象。

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

for index, language in enumerate(languages):
    print(f'索引 {index} 和语言 {language}')

# 结果
# 索引 0 和语言 Spanish
# 索引 1 和语言 English
# 索引 2 和语言 Russian
# 索引 3 和语言 Chinese

```

- `enumerate()`函数也可以在`for`循环之外使用：

```python
languages = ['Spanish', 'English', 'Russian', 'Chinese']

print(list(enumerate(languages)))
# [(0, 'Spanish'), (1, 'English'), (2, 'Russian'), (3, 'Chinese')]
```

- `enumerate()`函数还接受可选的`start`参数，该参数指定计数的起始值。如果省略此参数，则计数将从`0`开始。

- **`zip()`**：用于并行遍历多个可迭代对象。以下是使用`zip()`函数遍历`developers`和`ids`的示例：

```python
developers = ['Naomi', 'Dario', 'Jessica', 'Tom']
ids = [1, 2, 3, 4]

for name, id in zip(developers, ids):
    print(f'姓名: {name}')
    print(f'ID: {id}')


"""
结果

姓名: Naomi
ID: 1
姓名: Dario
ID: 2
姓名: Jessica
ID: 3
姓名: Tom
ID: 4
"""

```

## Python中的列表推导式

- **定义**：列表推导式允许你在一行中通过将循环和条件直接放在方括号内来创建新列表。这使代码更短，通常更容易阅读。

```py
even_numbers = [num for num in range(21) if num % 2 == 0]
print(even_numbers)
```

## 可迭代方法

- **`filter()`**：用于根据条件从可迭代对象中过滤元素。它返回一个仅包含满足条件的元素的迭代器。以下是创建仅包含超过四个字符的单词的新列表的示例：

```py
words = ['tree', 'sky', 'mountain', 'river', 'cloud', 'sun']

def is_long_word(word):
    return len(word) > 4

long_words = list(filter(is_long_word, words))
print(long_words) # ['mountain', 'river', 'cloud']
```

- **`map()`**：用于将函数应用于可迭代对象中的每个项目并返回包含结果的新可迭代对象。以下是使用`map()`函数将摄氏温度列表转换为华氏温度的示例：

```py
celsius = [0, 10, 20, 30, 40]

def to_fahrenheit(temp):
    return (temp * 9/5) + 32

fahrenheit = list(map(to_fahrenheit, celsius))
print(fahrenheit) # [32.0, 50.0, 68.0, 86.0, 104.0]
```

- **`sum()`**：用于获取可迭代对象（如列表或元组）的总和。以下是使用`sum()`函数的示例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers)
print(total) # 结果: 50
```

- 你还可以传递可选的`start`参数，该参数设置求和的初始值。以下是使用`start`参数作为位置参数的更新示例：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, 10) # 位置参数
print(total) # 60
```

- 你也可以选择将`start`参数作为关键字参数使用，如下所示：

```py
numbers = [5, 10, 15, 20]
total = sum(numbers, start=10) # 关键字参数
print(total) # 60
```

## Lambda函数

- **定义**：Python中的lambda函数是创建无名函数（匿名函数）的简洁方式。
- Lambda函数通常用作另一个函数的参数。以下是lambda函数的示例：

```py
numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]
```

- 使用lambda函数的最佳实践包括不将它们分配给变量，保持它们简单易读，以及将它们用于简短的一次性函数。

## 字典

- **字典**：字典是存储键值对集合的内置数据结构。键需要是不可变的数据类型。这是Python字典的一般语法：

```python
dictionary = {
    key1: value1,
    key2: value2
}
```

- **`dict()`构造函数**：`dict()`构造函数是构建字典的另一种方式。你将元组列表作为参数传递给`dict()`构造函数。这些元组包含键作为第一个元素和值作为第二个元素。

```python
pizza = dict([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250), ('toppings', ['mozzarella', 'basil'])])
```

- **方括号表示法**：要访问键值对的值，可以使用称为方括号表示法的语法。

```python
dictionary[key]
```

## 常见字典方法

- **`get()`方法**：`get()`方法检索与键关联的值。它类似于方括号表示法，但它让你设置默认值，防止键不存在时出错。

```python
dictionary.get(key, default)
```

- **`keys()`和`values()`方法**：`keys()`和`values()`方法返回包含字典中所有键和值的视图对象。视图对象是一种查看字典内容的方式，而无需创建数据的单独副本。

```python
pizza = {
    'name': 'Margherita Pizza',
    'price': 8.9,
    'calories_per_slice': 250
}

pizza.keys()
# dict_keys(['name', 'price', 'calories_per_slice'])

pizza.values()
# dict_values(['Margherita Pizza', 8.9, 250])
```

- **`items()`方法**：`items()`方法返回包含字典中所有键值对的视图对象，包括键和值。

```python
pizza.items()
# dict_items([('name', 'Margherita Pizza'), ('price', 8.9), ('calories_per_slice', 250)])
```

- **`clear()`方法**：`clear()`方法从字典中删除所有键值对。

```python
pizza.clear()
```

- **`pop()`方法**：`pop()`方法删除具有第一个参数指定的键的键值对并返回其值。如果键不存在，它返回第二个参数指定的默认值。如果键不存在且未指定默认值，则引发`KeyError`。

```python
pizza.pop('price', 10)
pizza.pop('total_price') # KeyError
```

- **`popitem()`方法**：在Python 3.7及以上版本中，`popitem()`方法删除最后插入的项目。

```python
pizza.popitem()
```

- **`update()`方法**：`update()`方法使用另一个字典的键值对更新键值对。如果它们有共同的键，则它们的值被覆盖。新键将作为新的键值对添加到字典中。

```python
pizza.update({ 'price': 15, 'total_time': 25 })
```

## 遍历字典

- **遍历值**：如果你需要遍历字典中的值，可以编写一个带有`values()`的`for`循环来获取字典的所有值。

```python
products = {
    'Laptop': 990,
    'Smartphone': 600,
    'Tablet': 250,
    'Headphones': 70,
}

for price in products.values():
    print(price)
```

输出：

```md
990
600
250
70
```

- **遍历键**：如果你需要遍历上面`products`字典中的键，可以编写`products.keys()`或直接`products`。

```python
for product in products.keys():
    print(product)

for product in products:
    print(product)
```

输出：

```md
Laptop
Smartphone
Tablet
Headphones
```

- **遍历键值对**：如果你需要同时遍历键及其对应的值，可以遍历`products.items()`。你会得到包含键及其对应值的单独元组。

```python
for product in products.items():
    print(product)
```

输出：

```md
('Laptop', 990)
('Smartphone', 600)
('Tablet', 250)
('Headphones', 70)
```

要将键和值存储在单独的循环变量中，需要用逗号分隔它们。第一个变量存储键，第二个存储值。

```python
for product, price in products.items():
    print(product, price)
```

输出：

```md
Laptop 990
Smartphone 600
Tablet 250
Headphones 70
```

- **`enumerate()`函数**：如果你需要遍历字典同时跟踪计数器，可以调用`enumerate()`函数。该函数返回一个`enumerate`对象，它为每个项目分配一个整数，就像计数器一样。你可以从任何数字开始计数，但默认情况下，它从0开始。

将索引和项目分配给单独的循环变量是使用`enumerate()`的常见方式。例如，使用`products.items()`，你可以获得整个键值对以及索引：

```python
for index, product in enumerate(products.items()):
    print(index, product)
```

输出：

```md
0 ('Laptop', 990)
1 ('Smartphone', 600)
2 ('Tablet', 250)
3 ('Headphones', 70)
```

要自定义计数的初始值，可以向`enumerate()`传递第二个参数。例如，这里我们从1开始计数。

```python
for index, product in enumerate(products.items(), 1):
    print(index, product)
```

输出：

```md
1 ('Laptop', 990)
2 ('Smartphone', 600)
3 ('Tablet', 250)
4 ('Headphones', 70)
```

## 集合

- **集合**：集合是Python中的内置数据结构，不允许重复值。集合是可变和无序的，这意味着它们的元素不按任何特定顺序存储，所以你不能使用索引或键来访问它们。此外，集合只能包含不可变数据类型的值，如数字、字符串和元组。

- **定义集合**：要定义集合，你需要将其元素写在花括号内并用逗号分隔。

```python
my_set = {1, 2, 3, 4, 5}
```

- **定义空集合**：如果你需要定义空集合，必须使用`set()`函数。只写空花括号会自动创建字典。

```python
set() # 集合
{}    # 字典
```

## 常见集合方法

- **`add()`方法**：你可以使用`add()`方法向集合添加元素，将新元素作为参数传递。

```python
my_set.add(6)
```

- **`remove()`和`discard()`方法**：要从集合中删除元素，你可以使用`remove()`方法或`discard()`方法，将要删除的元素作为参数传递。如果元素未找到，`remove()`方法将引发`KeyError`，而`discard()`方法不会。

```python
my_set.remove(4)
my_set.discard(4)
```

- **`clear()`方法**：`clear()`方法从集合中删除所有元素。

```python
my_set.clear()
```

## 数学集合运算

- **`issubset()`和`issuperset()`方法**：`issubset()`和`issuperset()`方法检查一个集合是否是另一个集合的子集或超集。

```python
my_set = {1, 2, 3, 4, 5} 
your_set = {2, 3, 4, 5}

print(your_set.issubset(my_set)) # True
print(my_set.issuperset(your_set)) # True
```

- **`isdisjoint()`方法**：`isdisjoint()`方法检查两个集合是否不相交，即它们没有共同的元素。

```python
print(my_set.isdisjoint(your_set)) # False
```

- **并集运算符（`|`）**：并集运算符`|`返回包含两个集合所有元素的新集合。

```python
my_set | your_set # {1, 2, 3, 4, 5, 6}
```

- **交集运算符（`&`）**：交集运算符`&`返回仅包含集合共同元素的新集合。

```python
my_set & your_set # {2, 3, 4}
```

- **差集运算符（`-`）**：差集运算符`-`返回包含第一个集合中不在其他集合中的元素的新集合。

```python
my_set - your_set # {1, 5}
```

- **对称差集运算符（`^`）**：对称差集运算符`^`返回包含在第一个或第二个集合中但不在两个集合中的元素的新集合。

```python
my_set ^ your_set # {1, 5, 6}
```

- **`in`运算符**：你可以使用`in`运算符检查元素是否在集合中。

```python
print(5 in my_set)
```

## Python标准库

- **Python标准库**：库为你提供预编写和可重用的代码，如函数、类和数据结构，你可以在项目中重用。Python拥有广泛的标准库，其中包含实现许多问题和任务标准化解决方案的内置模块。一些流行的内置模块示例包括`math`、`random`、`re`（"regular expressions"的缩写）和`datetime`。

## 导入语句

- **导入语句**：要访问内置模块中定义的元素，你使用导入语句。导入语句通常写在文件的顶部。导入语句对函数、类、常量、变量和模块中定义的任何其他元素都适用。

- **基本导入语句**：你可以使用`import`关键字后跟模块名称：

```python
import module_name
```

然后，如果你需要调用该模块中的方法，你将使用点表示法，模块名称后跟方法名称。

```python
module_name.method_name()
```

例如，你将在代码中编写以下内容来导入`math`模块并获取36的平方根：

```python
import math

math.sqrt(36)
```

- **使用不同名称导入模块**：如果你需要使用不同名称（也称为"别名"）导入模块，可以在导入语句末尾使用`as`后跟别名。这通常用于长模块名称或避免命名冲突。

```python
import module_name as module_alias
```

例如，要在代码中将`math`模块称为`m`，你可以像这样分配别名：

```python
import math as m
```

然后，你可以使用别名访问模块的元素：

```python
m.sqrt(36)
```

- **导入特定元素**：如果你不需要模块中的所有内容，可以使用`from`导入特定元素。在这种情况下，导入语句以`from`开头，后跟模块名称，然后是`import`关键字，最后是你要导入的元素名称。

```python
from module_name import name1, name2
```

然后，你可以在Python脚本中使用这些名称而无需模块前缀。例如：

```python
from math import radians, sin, cos

angle_degrees = 40
angle_radians = radians(angle_degrees)

sine_value = sin(angle_radians)
cos_value = cos(angle_radians)

print(sine_value) # 0.6427876096865393
print(cos_value)  # 0.766044443118978
```

这很有帮助，但它可能导致命名冲突，如果你已经有同名的函数或变量。在选择要使用的导入语句类型时请记住这一点。

如果你需要为这些名称分配别名，也可以这样做，使用`as`关键字后跟别名。

```python
from module_name import name1 as alias1, name2 as alias2
```

- **带星号（`*`）的导入语句**：星号告诉Python你想要导入该模块中的所有内容，但你想要导入它，这样你就不需要使用模块名称作为前缀。

```python
from module_name import *
```

例如，如果你这样做来导入`math`模块，你将能够调用该模块中定义的任何函数而无需指定模块名称作为前缀。

```python
from math import *
print(sqrt(36))  # 6.0
```

然而，这通常不被推荐，因为它可能导致命名空间冲突并使难以知道名称来自哪里。

## `if __name__ == '__main__'`

- **`__name__`变量**：`__name__`是Python中的特殊内置变量。当Python文件直接执行时，Python将此变量的值设置为字符串`"__main__"`。但如果Python文件作为模块导入到另一个Python脚本中，则`__name__`变量的值设置为该模块的名称。

这就是为什么你经常在Python脚本中找到这个条件的原因。它包含你只想在Python脚本作为主程序运行时才运行的代码。

```python
if __name__ == '__main__': 
    # 代码
```

## Python中的常见错误

- **SyntaxError**：当你的代码不遵循Python的语法规则时，Python会引发此错误。例如，代码`print("Hello there"`会导致语法错误，消息为`SyntaxError: '(' was never closed`，因为代码缺少右括号。
- **NameError**：当你尝试访问未定义的变量或函数时，Python会引发`NameError`。例如，如果你在代码中有行`print(username)`而没有首先定义`username`变量，你会得到一个名称错误，消息为`NameError: name 'username' is not defined`。
- **TypeError**：这是当你对两个或多个不兼容的数据类型执行操作时Python抛出的错误。例如，如果你尝试将字符串添加到数字中，你会得到错误`TypeError: can only concatenate str (not "int") to str`。
- **IndexError**：如果你访问列表或其他序列（如元组和字符串）中不存在的索引，你会得到`IndexError`。例如，在`Hello world`字符串中，最后一个字符的索引是`11`。如果你这样访问字符，`greet = "hello world"; print(greet[12])`，你会得到错误消息`IndexError: string index out of range`。
- **AttributeError**：当你尝试使用该类型对象中不存在的方法或属性时，Python会引发此错误。例如，像`"hello".append("!")`这样在字符串上调用`.append()`会导致错误，消息为`AttributeError: 'str' object has no attribute 'append'`。

## Python中的良好调试技术

- **使用`print`函数**：在调试时在代码的各个点插入`print()`语句有助于你查看变量的值以及代码的流向。
- **使用Python的内置调试器（`pdb`）**：Python提供了一个`pdb`模块用于调试。它是Python标准库的一部分，所以总是可以使用。使用`pdb`，你可以使用`set_trace()`方法设置跟踪，这样你就可以开始逐步执行代码并以交互方式检查变量。
- **利用IDE调试工具**：许多集成开发环境（IDE）和代码编辑器，如Pycharm和VS Code，提供具有断点、逐步执行、变量检查和其他调试功能的调试工具。

## 异常处理

- **`try...except`**：这用于执行可能引发异常的代码块。`try`块是你预期可能发生错误的地方，而`except`块接受指定的异常并在引发该指定错误时运行。以下是一个示例：

  ```py
  try:
    print(22 / 0)
  except ZeroDivisionError:
    print('You can\'t divide by zero!')
    # You can't divide by zero!
  ```

  你也可以链接多个`except`块，这样你可以处理更多类型的异常：

  ```py
  try:
    number = int(input('Enter a number: '))
    print(22 / number)
  except ZeroDivisionError:
    print('You cannot divide by zero!')
    # You cannot divide by zero! prints when you enter 0
  except ValueError:
    print('Please enter a valid number!')
    # Please enter a valid number! prints when you enter a string  
  ```

- **`else`和`finally`**：这些块扩展了`try...except`。如果没有异常发生，`else`块运行。`finally`块无论是否有错误都会运行。

  ```py
  try:
    result = 100 / 4
  except ZeroDivisionError:
    print('You cannot divide by zero!') # This will not run
  else:
    print(f'Result is {result}') # Result is 25.0
  finally:
    print('Execution complete!') # Execution complete!
  ```

- **异常对象**：这让你可以访问异常本身以进行更好的调试和打印直接错误消息。要访问异常对象，你需要使用`as`关键字。以下是一个示例：

  ```py
  try:
      value = int('This will raise an error')
  except ValueError as e:
      print(f'Caught an error: {e}')
      # Caught an error: invalid literal for int() with base 10: 'This will raise an error'
  ```

- **`raise`语句**：这允许你手动引发异常。你可以使用它在满足某个条件时抛出异常。以下是一个示例：

  ```py
  def divide(a, b):
      if b == 0:
          raise ZeroDivisionError('You cannot divide by zero')
      return a / b
  ```

## 异常信号

  `raise`语句在创建自己的自定义异常时也很有用，因为你可以使用它来抛出带有自定义消息的异常。以下是一个示例：

  ```py
  class InvalidCredentialsError(Exception):
      def __init__(self, message="Invalid username or password"):
          self.message = message
          super().__init__(self.message)

  def login(username, password):
      stored_username = "admin"
      stored_password = "password123"

      if username != stored_username or password != stored_password:
          raise InvalidCredentialsError()

      return f"Welcome, {username}!"
  ```

  以下是你可以如何从`InvalidCredentialsError`异常中使用`login`函数：

  ```py
  # failed login attempt
  try:
      message = login("user", "wrongpassword")
      print(message)
  except InvalidCredentialsError as e:
      print(f"Login failed: {e}")

  # successful login attempt
  try:
      message = login("admin", "password123")
      print(message)
  except InvalidCredentialsError as e:
      # This block is not executed because the login was successful
      print(f"Login failed: {e}")
  else:
      # The else block runs if the 'try' block completes without an exception
      print(message)
  ```

  `raise`语句也可以与`from`关键字一起使用来链接异常，显示不同错误之间的关系：

  ```py
  def parse_config(filename):
    try:
        with open(filename, 'r') as file:
            data = file.read()
            return int(data)
    except FileNotFoundError:
        raise ValueError('Configuration file is missing') from None
    except ValueError as e:
        raise ValueError('Invalid configuration format') from e

  config = parse_config('config.txt')
```

## Python类和对象

- **类定义**：类是创建对象的蓝图。它通过其属性和方法定义对象将具有的行为。以下是Python中类定义的基本示例：

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def bark(self):
        print(f'{self.name.upper()} says woof woof!')
```

- **创建对象**：对象是类的实例。
