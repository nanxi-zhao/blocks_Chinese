---
id: 67c2bbd476f6e540b4c0b0d4
title: React状态和Hooks复习
challengeType: 31
dashedName: review-react-state-and-hooks
---

# --description--

## 在React中处理事件

- **合成事件系统**：这是React处理事件的方式。它作为原生事件（如`click`、`keydown`和`submit`事件）的包装器。React中的事件处理程序使用驼峰命名约定。（例如`onClick`、`onSubmit`等）

以下是React中使用`button`元素的`onClick`属性的示例：

```jsx
function handleClick() {
  console.log("按钮被点击了！");
}

<button onClick={handleClick}>点击我</button>;
```

在React中，事件处理函数通常以`handle`前缀开头，以表明它们负责处理事件，如`handleClick`或`handleSubmit`。

当用户操作触发事件时，React会将一个合成事件对象传递给你的处理程序。这个对象的行为很像原生JavaScript中的原生事件对象，提供诸如`type`、`target`和`currentTarget`等属性。

要防止默认行为，比如在`onSubmit`事件期间浏览器刷新，你可以调用`preventDefault()`方法：

```jsx
function handleSubmit(event) {
  event.preventDefault();
  console.log("表单已提交！");
}

<form onSubmit={handleSubmit}>
  <input type="text" />
  <button>提交</button>
</form>;
```

你也可以像这样将处理函数包装在箭头函数中：

```jsx
function handleDelete(id) {
  console.log("删除项目:", id);
}

<button onClick={() => handleDelete(1)}>删除项目</button>;
```

## 使用状态和`useState` Hook

- **状态定义**：在React中，状态是一个包含组件数据的对象。当状态更新时，组件将重新渲染。React将状态视为不可变的，这意味着你不应该直接修改它。
- **`useState()` Hook**：`useState` hook是一个函数，它允许你在函数组件中声明状态变量。以下是基本语法：

```js
const [stateVariable, setStateFunction] = useState(initialValue);
```

在状态变量中你有以下内容：

- `stateVariable`保存当前状态值
- `setStateFunction`（设置函数）更新状态变量
- `initialValue`设置初始状态

以下是`Counter`组件的完整示例：

```jsx
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h2>{count}</h2>

      <button onClick={() => setCount(count - 1)}>减少</button>
      <button onClick={() => setCount(count + 1)}>增加</button>
    </div>
  );
}

export default Counter;
```

## 渲染和React组件

- **定义**：在React中，渲染是组件出现在用户界面（UI）中的过程，通常是在浏览器中。渲染过程包括三个阶段：触发、渲染和提交。

触发阶段发生在React检测到某些内容已更改并且用户界面（UI）可能需要更新时。这种更改通常是由于状态或props的更新。

一旦触发发生，React进入渲染阶段。在这里，React重新评估你的组件并确定要显示什么。为此，React使用一个称为虚拟DOM的"真实"DOM的轻量级副本。通过虚拟DOM，React可以快速检查组件中需要更改的内容。

提交阶段是React将虚拟DOM中的准备好的更改应用到真实DOM的阶段。换句话说，这是你在屏幕上看到最终结果的阶段。

## 更新状态中的对象和数组

- **更新状态中的对象**：如果你需要更新状态中的对象，那么你应该先创建一个新对象或复制现有对象，然后为该新对象设置状态。放入状态的任何对象都应被视为只读。以下是设置用户姓名、年龄和城市的示例。`handleChange`函数用于处理用户信息的更新：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>用户资料</h1>
      <p>姓名: {user.name}</p>
      <p>年龄: {user.age}</p>
      <p>城市: {user.city}</p>

      <h2>更新用户年龄</h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>更新用户名字</h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>更新用户城市</h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

- **更新状态中的数组**：当更新状态中的数组时，重要的是不要直接使用`push()`或`pop()`等方法修改数组。相反，你应该在更新状态时创建一个新数组：

```js
const addItem = () => {
  const newItem = {
    id: items.length + 1,
    name: `项目 ${items.length + 1}`,
  };

  // 创建一个新数组
  setItems((prevItems) => [...prevItems, newItem]);
};
```

如果你想从数组中删除项目，你应该使用`filter()`方法，该方法在过滤掉你想删除的内容后返回一个新数组：

```js
const removeItem = (id) => {
  setItems((prevItems) => prevItems.filter((item) => item.id !== id));
};
```

## 使用Refs引用值

- **`ref`属性**：你可以通过使用`ref`属性在React中访问DOM节点。以下是展示使用`ref`来聚焦`input`元素的示例。`current`属性用于访问该`ref`的当前值：

```jsx
import { useRef } from "react";

const Focus = () => {
  const inputRef = useRef(null);

  const handleFocus = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="输入文本" />
      <button onClick={handleFocus}>聚焦输入框</button>
    </div>
  );
};

export default Focus;
```

## 使用`useEffect` Hook

- **`useEffect()` Hook**：在React中，效果是发生在组件渲染过程之外的任何事情。也就是说，任何React不直接作为UI渲染的一部分处理的事情。常见示例包括获取数据、更新浏览器标签页标题、读取或写入浏览器的本地存储、获取用户位置等等。这些操作与外部世界交互，被称为副作用。React提供`useEffect` hook让你处理这些副作用。`useEffect`让你在组件渲染或更新后运行一个函数。

```js
import { useEffect } from "react";

useEffect(() => {
 // 你的副作用逻辑（通常是函数）放在这里
}, [dependencies]);
```

效果函数在组件渲染后运行，而可选的`dependencies`参数控制效果何时运行。

注意`dependencies`可以是"响应值"（状态、props、函数、变量等）数组、空数组或完全省略。以下是这些选项如何控制`useEffect`的工作方式：

- 如果`dependencies`是包含一个或多个响应值的数组，则效果将在它们更改时运行。

- 如果`dependencies`是空数组，`useEffect`只在组件首次渲染时运行一次。

- 如果你省略`dependencies`，效果将在组件每次渲染或更新时运行。

## 如何创建自定义Hooks

- **自定义Hooks**：自定义hook允许你从组件中提取可重用的逻辑，如数据获取、状态管理、切换和副作用（如跟踪在线状态）。在React中，所有内置hook都以`use`开头，所以你的自定义hook应该遵循相同的约定。

以下是创建`useDebounce` hook的示例：

```js
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export { useDebounce };
```

# --assignment--

复习React状态和hooks主题和概念。