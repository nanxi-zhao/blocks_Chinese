---
id: 6724e296dceca21b82426229
title: Typescript 复习
challengeType: 31
dashedName: review-typescript
---

# --description--

## 什么是 TypeScript

- **JavaScript**: JavaScript 是一种动态类型语言。这意味着变量在运行时可以接收任何值。动态类型语言的挑战在于缺乏类型安全性可能会引入错误。

例如，即使你的 JavaScript 函数期望一个数组，你仍然可以用一个数字调用它：

```javascript
const getRandomValue = (array) => {
  return array[Math.floor(Math.random() * array.length)];
}

console.log(getRandomValue(10));
```

上面示例的 `console` 输出将是 `undefined`。

- **TypeScript**: TypeScript 扩展了 JavaScript 语言以包含静态类型，这有助于在你运行代码之前捕获由类型不匹配引起的错误。

例如，你可以为 `array` 参数定义一个类型，如下所示：

```typescript
const getRandomValue = (array: string[]) => {
  return array[Math.floor(Math.random() * array.length)];
}
```

这种类型定义告诉 TypeScript `array` 参数必须是一个字符串数组。然后，当你调用 `getRandomValue` 并传递一个数字时，你会得到一个称为编译器错误的错误。

- **编译器**: 你首先需要将 TypeScript 代码编译成普通的 JavaScript。当你运行编译器时，TypeScript 将评估你的代码，并对任何类型不匹配的问题抛出错误。

## TypeScript 中的数据类型

- **TypeScript 中的基本数据类型**: 对于基本数据类型 `string`、`null`、`undefined`、`number`、`boolean` 和 `bigint`，TypeScript 提供了相应的类型关键字。

```typescript
let str: string = "Naomi";
let num: number = 42;
let bool: boolean = true;
let nope: null = null;
let nada: undefined = undefined;
```

- **数组**: 你可以使用两种不同的语法定义特定类型的数组。

```typescript
const arrOne: string[] = ["Naomi"];
const arrTwo: Array<string> = ["Camperchan"];
```

- **对象**: 你可以定义对象的确切结构。

```typescript
const obj: { a: string, b: number } = { a: "Naomi", b: 42 };
```

如果你想要一个具有任何键的对象，但所有值都必须是字符串，有两种方法可以定义它：

```typescript
const objOne: Record<string, string> = {};
const objTwo: { [key: string]: string } = {};
```

- **TypeScript 中的其他有用类型**:
  - **`any`**: `any` 表示一个值可以有任何类型。它告诉编译器停止关心该变量的类型。
  - **`unknown`**: `unknown` 告诉 TypeScript 你 _确实_ 关心值的类型，但你实际上不知道它是什么。`unknown` 通常比 `any` 更受推荐。
  - **`void`**: 这是一种特殊类型，你通常只在定义函数时使用。没有返回值的函数使用 `void` 作为返回类型。
  - **`never`**: 它表示一个永远不会存在的类型。

- **`type` 关键字**: 这个关键字类似于 `const`，但不是声明一个变量，而是声明一个类型。

它对于声明自定义类型很有用，例如联合类型或仅包含特定值的类型：

```typescript
type stringOrNumber = string | number;
type bot = "camperchan" | "camperbot" | "naomi";
```

- **`interface`**: 接口类似于类型的类。它们可以实现或扩展其他接口，是专门的对象类型，通常更受推荐，除非你需要 `type` 声明提供的特定功能。

```typescript
interface wowie {
  zowie: boolean;
  method: () => void;
}
```

- **定义返回类型**: 你也可以定义函数的 _返回类型_。

下面的示例将返回值定义为字符串。如果你尝试返回任何其他内容，TypeScript 将给出一个编译器错误。

```typescript
const getRandomValue = (array: string[]): string => {
  return array[Math.floor(Math.random() * array.length)];
}
```

## 泛型

- **定义泛型类型**: 你可以定义一个泛型类型并在函数中引用它。它可以被认为是提供给函数的特殊参数，用于控制函数类型定义的行为。

下面是为函数定义泛型类型的示例：

```typescript
const getRandomValue = <T>(array: T[]): T => {
  return array[Math.floor(Math.random() * array.length)];
}
const val = getRandomValue([1, 2, 4])
```

`<T>` 语法告诉 TypeScript 你正在为函数定义一个泛型类型 `T`。`T` 是泛型类型的常见名称，但你可以使用任何名称。

然后，你告诉 TypeScript `array` 参数是一个匹配泛型类型的值数组，并且返回值是同一类型的单个元素。

- **在函数调用中指定类型参数**: 你可以使用函数名和参数之间的尖括号将类型参数传递给函数调用。

下面是将类型参数传递给函数调用的示例：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

这告诉 TypeScript 你期望找到的元素将是一个输入元素。

## 类型缩小

- **通过真实性缩小**: 在下面的示例中，你尝试访问 `email` 的 `value` 属性时会得到一个编译器错误，因为 `email` _可能_ 是 `null`。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

你可以使用条件语句确认 `email` 是 _真实的_ 然后再访问属性：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

真实性检查也可以反向工作：

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

抛出错误会结束这段代码的逻辑执行，这意味着当你到达 `console.log()` 调用时，TypeScript 知道 `email` _不可能_ 是 `null`。

- **可选链**: 可选链 `?.` 也是一种类型缩小形式，基于相同的前提，即如果 `email` 值是 `null`，属性访问就无法进行。

```typescript
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

- **`typeof` 操作符**: 你可以使用条件来检查变量的类型，使用 `typeof` 操作符。

```typescript
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

- **`instanceof` 关键字**: 如果对象来自一个类，你可以使用 `instanceof` 关键字来缩小类型。

```typescript
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

- **类型转换**: 当 TypeScript 无法自动确定值的类型时，例如下面示例中 `request.json()` 方法的结果，你会得到一个编译器错误。解决方法之一是转换类型，但这样做会削弱 TypeScript 捕获潜在错误的能力。

```typescript
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

- **类型守卫**: 你可以编写一个类型守卫，而不是转换类型：

```typescript
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

`user is User` 语法表示你的函数返回一个布尔值，当为 true 时意味着 `user` 值满足 `User` 接口。

## `tsconfig` 文件

- **`tsconfig.json`**: TypeScript 的编译器设置位于项目根目录中的 `tsconfig.json` 文件中。

```json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./prod",
    "lib": ["ES2023"],
    "target": "ES2023",
    "module": "ES2022",
    "moduleResolution": "Node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true
  },
  "exclude": ["test/"]
}
```

下面是上面示例中使用的编译器选项的描述：

- **`compilerOptions`**: `compilerOptions` 属性是你控制 TypeScript 编译器行为的地方。
- **`rootDir` 和 `outDir`**: `rootDir` 和 `outDir` 告诉 TypeScript 哪个目录包含你的源文件，哪个目录应该包含转译后的 JavaScript 代码。
- **`lib`**: `lib` 属性确定编译器使用哪些类型定义，并允许你包含对特定 ES 版本、DOM 等的支持。
- **`module` 和 `moduleResolution`**: `module` 和 `moduleResolution` 协同工作来管理你的包如何使用模块 - 无论是 CommonJS 还是 ECMAScript。
- **`esModuleInterop`**: `esModuleInterop` 通过自动为导入创建命名空间对象，允许 CommonJS 和 ES 模块之间更顺畅的互操作性。
- **`skipLibCheck`**: `skipLibCheck` 选项跳过验证代码中未被导入引用的 `.d.ts` 文件。
- **`strict`**: `strict` 标志启用几项检查，例如确保正确处理可空类型，并在 TypeScript 回退到 `any` 时发出警告。
- **`exclude`**: 顶层的 `exclude` 属性告诉编译器在编译期间忽略这些 TypeScript 文件。

# --assignment--

复习 Typescript 主题和概念。