---
id: 6810891bd6de8a87a833df42
title: 步骤 10
challengeType: 20
dashedName: step-10
---

# --description--

从输出中可以看出，消息已被加密。下一步将是使你的代码可重用，以便你想要加密不同的消息。

为此，你需要创建一个函数。提醒一下，下面是创建一个名为 `spam` 的函数并在终端上打印 `Spam!` 的方法：

```py
def spam():
    print('Spam!')
```

创建一个名为 `caesar` 的函数。将你现有的所有代码放在函数体内。注意保持函数体内所有行的缩进级别相同。

# --hints--

你应该有一个名为 `caesar` 的函数。

```js
({ test: () => assert(runPython(`_Node(_code).has_function("caesar")`)) })
```

你应该将目前为止编写的所有代码移到 `caesar` 函数体内。确保保持函数体内所有行的缩进级别相同...

```js
({ test: () => assert(runPython(`_Node(_code).find_function("caesar").find_body().is_equivalent("alphabet = 'abcdefghijklmnopqrstuvwxyz'\\nshift = 5\\nshifted_alphabet = alphabet[shift:] + alphabet[:shift]\\ntranslation_table = str.maketrans(alphabet, shifted_alphabet)\\ntext = 'hello world'\\nencrypted_text = text.translate(translation_table)\\nprint(encrypted_text)")`)) })
```

# --seed--

## --seed-contents--

```py
--fcc-editable-region--
alphabet = 'abcdefghijklmnopqrstuvwxyz'
shift = 5
shifted_alphabet = alphabet[shift:] + alphabet[:shift]
translation_table = str.maketrans(alphabet, shifted_alphabet)
text = 'hello world'
encrypted_text = text.translate(translation_table)
print(encrypted_text)
--fcc-editable-region--
```
