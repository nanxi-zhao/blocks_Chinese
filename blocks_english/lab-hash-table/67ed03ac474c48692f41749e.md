---
id: 67ed03ac474c48692f41749e
title: Build a Hash Table
challengeType: 27
dashedName: build-a-hash-table
---

# --description--

在这个实验中，你将从头开始构建一个哈希表。哈希表是一种存储键值对的数据结构。哈希表通过将键作为输入，然后根据特定的哈希函数对此键进行哈希来工作。

为了本实验的目的，哈希函数将是简单的：它将对键中每个字符的Unicode值求和。哈希值将用作存储关联值的实际键。相同的哈希值也将用于检索和删除与键关联的值。

**目标：**实现以下用户需求并通过所有测试以完成实验。

**用户故事：**

1. 你应该定义一个名为`HashTable`的类，当创建`HashTable`的新实例时，其`collection`属性应初始化为空字典。`collection`字典应根据键的哈希值存储键值对。

2. `HashTable`类应该有四个实例方法：`hash`、`add`、`remove`和`lookup`。

3. `hash`方法应该：

    - 接受一个字符串作为参数。
    - 返回计算为字符串中每个字符的Unicode（ASCII）值之和的哈希值。你可以使用`ord`函数进行此计算。

4. `add`方法应该：
    - 接受两个参数表示键值对，并计算键的哈希值。
    - 使用计算出的哈希值将键值对存储在`collection`字典中。
    - 如果多个键产生相同的哈希值，它们的键值对应该存储在相同哈希值下的嵌套字典中。

5. `remove`方法应该：

    - 接受一个键作为其参数并计算其哈希值。
    - 确认键是否存在于集合中。
    - 从哈希表中删除相应的键值对。
    - 如果键不存在于集合中，它不应引发错误或删除任何内容。

6. `lookup`方法应该：

    - 接受一个键作为其参数。
    - 计算键的哈希值，并返回存储在哈希表中的相应值。
    - 如果键不存在于集合中，它应返回`None`。

# --hints--

你应该定义一个`HashTable`类。

```js
({ 
    test: () => assert(runPython(`
    _Node(_code).has_class("HashTable")
    `)) 
})
```

当创建`HashTable`类的新实例时，其`collection`属性应初始化为空字典。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.collection == {}
    `) 
})
```

`HashTable`类应该有一个`hash`方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('hash')`))}})
```

`hash`方法应该接受一个字符串作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.hash)
    len(sig.parameters) == 1
  `))
})
```

`hash`方法应该接受一个字符串作为其参数并返回字符串中每个字符的Unicode值之和。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("fcc")
        assert hash_result == 300

        # 防止硬编码
        assert ht.hash("golf") == 424
        assert ht.hash("read") == 412
`) })
```

`HashTable`类应该有一个`add`方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('add')`))}})
```

`add`方法应该接受一个键和值作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.add)
    len(sig.parameters) == 2
  `))
})
```

`HashTable`类应该有一个`remove`方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('remove')`))}})
```

`remove`方法应该接受一个键作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.remove)
    len(sig.parameters) == 1
  `))
})
```

当你尝试删除集合中不存在的键时，它不应引发错误或删除任何内容。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        ht.add("rose", "flower")
        index = ht.hash("rose")
        original = ht.collection.copy()

        ht.remove("tulip")

        assert ht.collection == original
        assert "rose" in ht.collection[index]
        assert "tulip" not in ht.collection.get(index, {})
    `) 
})
```

如果多个键哈希到相同的索引，`remove`方法应该只删除特定的键值对，而不是删除该索引处的整个字典。

```js
({
  test: () => runPython(`
    ht = HashTable()
    ht.add("rose", "flower")
    ht.add("sore", "pain")  # "rose" 和 "sore" 都哈希到相同的索引

    index = ht.hash("rose")
    ht.remove("rose")

    assert index in ht.collection
    assert "rose" not in ht.collection[index]
    assert "sore" in ht.collection[index]
    assert ht.collection[index]["sore"] == "pain"
  `)
})
```

`HashTable`类应该有一个`lookup`方法。

```js
({test: () => {assert(runPython(`_Node(_code).find_class('HashTable').has_function('lookup')`))}})
```

`lookup`方法应该接受一个键作为参数。

```js
({ test: () => assert(runPython(`
    import inspect 
    ht= HashTable()
    sig = inspect.signature(ht.lookup)
    len(sig.parameters) == 1
  `))
})
```

`HashTable.hash('golf')`应该返回`424`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        hash_result = ht.hash("golf")
        assert hash_result == 424

        # 防止硬编码
        assert ht.hash("dear") == 412
        assert ht.hash("cat") == 312
    `) 
})
```

`HashTable.add('golf', 'sport')`应该将键值对添加到键`424`处的集合中。

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")
    expected_value = {424: {'golf': 'sport'}}

    assert ht.collection == expected_value
    `) 
})
```

`HashTable.add('dear', 'friend')`和`HashTable.add('read', 'book')`应该将两个键值对作为嵌套字典添加到索引`412`处的集合中。

```js
({ 
    test: () => runPython(`

    ht = HashTable()

    ht.add("dear", "friend")
    ht.add("read", "book")

    expected_value = {
        "dear": "friend",
        "read": "book"
    }

    assert ht.collection.get(412) == expected_value
    `) 
})
```

当键存在于哈希表中时，`remove()`方法应该从集合中删除给定的键及其对应的值。

```js
({ 
    test: () => runPython(`
    ht = HashTable()
    ht.add("golf", "sport")

    expected_value_before_removal = {
        "golf": "sport"
    }

    index = ht.hash("golf")

    assert ht.collection.get(index) == expected_value_before_removal

    ht.remove("golf")

    assert "golf" not in ht.collection.get(index, {})
    `) 
})
```

当`('golf', 'sport')`键值对存在于哈希表中时，`HashTable.lookup('golf')`应该返回`sport`。

```js
({ 
    test: () => runPython(`
    ht = HashTable()

    ht.add("golf", "sport")

    expected_value = "sport"
    assert ht.lookup("golf") == expected_value
    `) 
})

```

当`('golf', 'sport')`键值对不存在于集合中时，`HashTable.lookup('golf')`应该返回`None`。

```js
({ 
    test: () => runPython(`
        ht = HashTable()
        assert ht.lookup("golf") is None
`) })

```

当你向哈希表中添加`('rose', 'flower')`时，其`collection`属性应该如下所示：`{ 441: { 'rose': 'flower' }}`。

```js
({ 
    test: () => runPython(`

    ht = HashTable()

    ht.add("rose", "flower")

    expected_value = {
        "rose": "flower"
    }

    assert ht.collection.get(441) == expected_value

    # 防止硬编码

    ht2 = HashTable()

    ht2.add("kebab", "food")
    expected_value = {
        "kebab": "food"
    }

    assert ht2.collection.get(501) == expected_value
    `)
})
```

当你添加一个与现有键哈希到相同值的键时，比如`fcc`和`cfc`，`collection`应该如下所示：`{ 300: { 'fcc': 'coding', 'cfc':  'chemical' }}`。

```js
({ 
    test: () => runPython(`

    ht = HashTable()

    ht.add("fcc", "coding")
    ht.add("cfc", "chemical")

    expected_value = {
        "fcc": "coding",
        "cfc": "chemical"
    }

    assert ht.collection.get(300) == expected_value

    # 防止硬编码

    ht2 = HashTable()
    ht2.add("cat", "animal")
    ht2.add("act", "verb")

    expected_value = {
        "cat": "animal",
        "act": "verb"
    }

    assert ht2.collection.get(312) == expected_value
    `)
})
```

# --seed--

## --seed-contents--

```py
class HashTable:
    def __init__(self):
        # 你的代码在这里
        pass

    def hash(self, string):
        # 你的代码在这里
        pass

    def add(self, key, val):
        # 你的代码在这里
        pass

    def remove(self, key):
        # 你的代码在这里
        pass

    def lookup(self, key):
        # 你的代码在这里
        pass
```

# --solutions--

```py
class HashTable:
    def __init__(self):
        self.collection = {}

    def hash(self, string):
        hashed = 0
        for char in string:
            hashed += ord(char)  
        return hashed

    def add(self, key, val):
        the_hash = self.hash(key)
        if the_hash not in self.collection:
            self.collection[the_hash] = {}
        self.collection[the_hash][key] = val

    def remove(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            del self.collection[the_hash][key]
            if not self.collection[the_hash]: 
                del self.collection[the_hash]

    def lookup(self, key):
        the_hash = self.hash(key)
        if the_hash in self.collection and key in self.collection[the_hash]:
            return self.collection[the_hash][key]
        return None
```