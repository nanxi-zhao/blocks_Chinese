---
id: 67335f45489c5a11b71d0ed5
title: 什么是变量提升？
challengeType: 19
dashedName: what-is-hoisting
---

# --interactive--

提升是 JavaScript 中一种经常让初学者困惑的行为，但理解它可以帮助你避免代码中的细微错误。简单来说，提升是 JavaScript 在编译阶段将声明移动到其各自作用域顶部的默认行为，然后才执行代码。

要理解提升，重要的是要知道 JavaScript 在两个阶段运行：编译阶段和执行阶段。在编译阶段，JavaScript 引擎会遍历你的代码并为变量和函数设置内存空间。这就是提升发挥作用的地方。

让我们从变量提升开始，当你使用 `var` 关键字声明一个变量时，JavaScript 会将声明提升到其作用域的顶部。但是，重要的是要注意只有声明被提升，而不是初始化。这意味着你可以在代码中使用一个变量，然后再声明它，但它的值将是 `undefined`，直到你实际给它赋值。

:::interactive_editor

```js
console.log(x); // undefined
var x = 5;
console.log(x); // 5
```

:::

在这段代码中，尽管我们在声明 `x` 之前使用它，但我们不会得到错误，而是得到 `undefined`。这是因为 JavaScript 将声明 `var x` 提升到其作用域的顶部，但不提升初始化 `x = 5`。就好像代码被重写成这样：

:::interactive_editor

```js
var x;
console.log(x); // undefined
x = 5;
console.log(x); // 5
```

:::

函数提升的工作方式略有不同。当你使用 `function` 声明语法声明一个函数时，函数名和函数体都会被提升。这意味着你可以在代码中声明函数之前调用它。以下是函数提升的示例：

:::interactive_editor

```js
sayHello(); // "Hello, World!"

function sayHello(){
  console.log("Hello, World!");
}
```

:::

在这种情况下，我们可以在声明之前调用 `sayHello()`，因为整个函数被提升到其作用域的顶部。

重要的是要注意，提升在 ES6 中引入的 `let` 和 `const` 声明中工作方式不同。

```js
console.log(y); // Throws a ReferenceError
let y = 10;
```

这些声明被提升但未初始化，你在代码中的实际声明之前无法访问它们。这通常被称为时间死区。

理解提升可以帮助你编写更清晰、更可预测的代码。但是，依赖提升会使你的代码更难阅读和维护。作为最佳实践，建议在作用域顶部声明变量，在使用函数之前声明函数，无论是否提升。这使你的代码行为更加明确，更容易让其他人（包括未来的自己）理解。

# --questions--

## --text--

使用 `var` 声明的变量被提升时会发生什么？

## --answers--

声明和初始化都被移动到顶部。

### --feedback--

想想在显式赋值之前提升的变量有什么值。

---

只有声明被移动到顶部。

---

变量根本没有被提升。

### --feedback--

想想在显式赋值之前提升的变量有什么值。

---

变量从代码中被删除。

### --feedback--

想想在显式赋值之前提升的变量有什么值。

## --video-solution--

2

## --text--

函数提升与变量提升有何不同？

## --answers--

函数不会被提升。

### --feedback--

考虑是否可以在声明之前调用函数。

---

只有函数名被提升。

### --feedback--

考虑是否可以在声明之前调用函数。

---

函数名和函数体都被提升。

---

函数提升只适用于箭头函数。

### --feedback--

考虑是否可以在声明之前调用函数。

## --video-solution--

3

## --text--

尝试在代码中声明之前访问用 `let` 声明的变量的结果是什么？

## --answers--

返回 `undefined`。

### --feedback--

想想课程中提到的"时间死区"概念。

---

抛出 `ReferenceError`。

---

返回 `null`。

### --feedback--

想想课程中提到的"时间死区"概念。

---

没有问题地工作

### --feedback--

想想课程中提到的"时间死区"概念。

## --video-solution--

2