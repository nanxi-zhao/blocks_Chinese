---
id: 67d1ec6711b62f1cc5cc52e1
title: React中的Effects是什么，useEffect钩子是如何工作的？
challengeType: 19
dashedName: what-are-effects-in-react-and-how-does-the-useeffect-hook-work
---

# --description--

在React中，effect是发生在组件渲染过程之外的任何事情。也就是说，任何React不直接作为UI渲染一部分处理的事情。

常见示例包括获取数据、更新浏览器标签页的标题、读取或写入浏览器的本地存储、获取用户位置等等。这些操作与外部世界交互，被称为副作用。

React提供了`useEffect`钩子让你处理这些副作用。`useEffect`让你在组件渲染或更新后运行一个函数。

让我们看看`useEffect`钩子是如何工作的，以及为什么它对现代React开发至关重要。

要使用`useEffect`钩子，首先需要导入它：

```js
import { useEffect } from "react";
```

然后你像这样使用它作为函数：

```js
useEffect(() => {
  // 你的副作用逻辑(通常是函数)在这里
}, [dependencies]);
```

effect函数在组件渲染后运行，而可选的`dependencies`参数控制effect何时运行。

注意`dependencies`可以是"响应值"(状态、props、函数、变量等)的数组、空数组，或完全省略。以下是所有这些选项如何控制`useEffect`的工作方式：

- 如果`dependencies`是一个包含一个或多个响应值的数组，effect将在它们改变时运行。

- 如果`dependencies`是一个空数组，`useEffect`只在组件首次渲染时运行一次。

- 如果你省略`dependencies`，effect将在组件每次渲染或更新时运行。

例如，在这个`Counter`应用程序中，我们没有传入`dependencies`参数，所以effect在组件渲染时和每次更新时都会运行：

```jsx
import { useState, useEffect } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("组件渲染");
  });

  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
      }}
    >
      <h2>{count}</h2>
      <div>
        <button onClick={() => setCount(count + 1)}>增加</button>
        <button onClick={() => setCount(count - 1)}>减少</button>
      </div>
    </div>
  );
};

export default Counter;
```

但是如果我们传入一个空数组作为依赖项，effect只在首次渲染时运行：

```js
useEffect(() => {
  console.log('组件渲染');
}, []);
```

如果你传入`count`状态作为依赖项，effect在组件首次渲染时和`count`改变时运行：

```js
useEffect(() => {
  document.title = `当前计数是 ${count}`;
  console.log('组件渲染');
}, [count]);
```

注意，如果你设置的effect在组件渲染生命周期之外持续存在，你可能需要另一个函数在组件渲染或更新后"清理"那个函数。

例如，如果你的effect函数使用`setInterval()`，设置事件监听器如`window.addEventListener()`，或连接到服务器，你需要一个清理函数来分别运行`clearInterval()`、`window.removeEventListener()`和断开服务器连接。

以下是從`useEffect`钩子返回清理函数的语法：

```js
useEffect(() => {
  // 你的副作用逻辑在这里
  return () => {
    // 清理逻辑在这里(可选)
  };
}, [dependencies]);
```

例如，如果你添加了一个滚动事件监听器，你可以在清理函数中通过移除它来清理：

```js
useEffect(() => {
  const handleScroll = () => {
    // 处理滚动逻辑
  };
  window.addEventListener("scroll", handleScroll);

  return () => {
    window.removeEventListener("scroll", handleScroll);
  };
}, []);
```

# --questions--

## --text--

在React中什么被认为是effect？

## --answers--

组件状态的任何更新。

### --feedback--

Effects涉及React在渲染期间不控制的操作。

---

React不管理的渲染过程之外的操作。

---

每次状态更新后渲染UI。

### --feedback--

Effects涉及React在渲染期间不控制的操作。

---

更新组件的props。

### --feedback--

Effects涉及React在渲染期间不控制的操作。

## --video-solution--

2

## --text--

什么决定了React应用中副作用的运行方式？

## --answers--

Effects总是运行一次，无论依赖项如何。

### --feedback--

effect的行为取决于依赖数组的内容。

---

Effects只在props改变时运行，忽略状态。

### --feedback--

effect的行为取决于依赖数组的内容。

---

依赖数组决定了effects何时运行。

---

Effects总是在每次渲染时运行，除非明确禁用。

### --feedback--

effect的行为取决于依赖数组的内容。

## --video-solution--

3

## --text--

React中副作用的常见示例有哪些？

## --answers--

渲染组件和更新状态。

### --feedback--

副作用涉及与React渲染过程之外的世界交互。

---

向子组件传递props。

### --feedback--

副作用涉及与React渲染过程之外的世界交互。

---

定义组件样式和布局。

### --feedback--

副作用涉及与React渲染过程之外的世界交互。

---

获取数据、更新标签页标题和从存储中读取。

## --video-solution--

4