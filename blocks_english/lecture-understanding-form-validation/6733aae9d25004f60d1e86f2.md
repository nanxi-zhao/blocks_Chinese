---
id: 6733aae9d25004f60d1e86f2
title: 使用JavaScript验证表单有哪些方法？
challengeType: 19
dashedName: what-are-some-ways-to-validate-forms-using-javascript
---

# --description--

让我们学习如何使用JavaScript来验证表单。

在之前的课程中，你已经学会了如何使用HTML来限制用户在表单中可以提交的值。但有时这还不够。如果你想变得更复杂，比如向用户显示自己的错误消息，就需要使用JavaScript。

某些HTML元素，如`textarea`和`input`元素，暴露了一个约束验证API。这个API允许你断言用户为该元素提供的值是否通过了你编写的任何HTML级别的验证，比如最小长度或模式匹配。

但是你实际上如何使用它呢？假设你想让公司的员工通过这样的表单发送反馈消息：

```html
<form>
  <label>输入你的邮箱: </label>
  <input required type="email" />

  <label>输入你的反馈: </label>
  <textarea required placeholder="在这里输入你的反馈..."></textarea>

  <button type="submit">提交反馈</button>
</form>
```

我们使用了带有内置验证的邮箱`input`，可以检查基本验证，比如输入是否包含@符号。

但是如果用户提供了像`example@email.com`这样的邮箱地址呢？这会通过基本验证，但我们希望更具体地接受那些拥有公司邮箱地址的用户。

这就是我们可以使用`pattern`属性来指定邮箱地址必须以公司邮箱地址结尾的地方。以下是更新后的示例：

```html
<form>
  <label>输入你的邮箱: </label>
  <input required placeholder="username@sampleCompany.com" type="email" pattern=".+@sampleCompany\.com" />

  <label>输入你的反馈: </label>
  <textarea required placeholder="在这里输入你的反馈..."></textarea>

  <button type="submit">提交反馈</button>
</form>
```

现在，如果你尝试提交反馈，你会看到一条消息说"请匹配要求的格式。"

尽管`input`确实有占位符文本向他们显示所需的格式，但最好还是使用JavaScript包含一个自定义的错误消息。

让我们首先看看`checkValidity()`方法：

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.checkValidity())
})
```

在上面的例子中，我们从DOM中查询了我们的input，并添加了一个input事件监听器。

我们知道`e.target`指的是触发事件的元素。在这种情况下，是我们的`input`。但是`checkValidity()`方法是什么呢？

这是约束验证API的一部分。`checkValidity()`方法如果元素匹配所有HTML验证（基于其属性）则返回`true`，如果失败则返回`false`。

当我们尝试使用无效输入时，我们会看到`false`被记录在控制台中。现在我们知道输入是无效的，让我们报告无效性：

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.reportValidity();
  }
})
```

结果，你会看到浏览器的错误消息"请匹配要求的格式。"

它立即报告无效状态，而不是等待我们提交表单。但它仍然使用默认消息。这是因为`reportValidity`方法只是告诉浏览器输入是无效的。浏览器仍然选择如何显示它为什么无效。这就是`setCustomValidity`方法的用武之地。

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  if (!e.target.checkValidity()) {
    e.target.setCustomValidity(
      "你必须使用以@sampleCompany.com结尾的公司邮箱地址"
    );
  }
});
```

这个方法接受一个自定义错误消息，显示给用户。结果，你会看到自定义错误消息`你必须使用以@sampleCompany.com结尾的公司邮箱地址`。

如果你有兴趣探索更多关于不同类型的 validity 状态以及为什么特定验证失败的原因，你可以像这样记录`validity`属性：

```js
const input = document.querySelector("input");

input.addEventListener("input", (e) => {
  console.log(e.target.validity);
})
```

`validity`属性是`ValidityState`对象的一个实例。以下是浏览器中该对象可能的样子示例：

```javascript
ValidityState {
  badInput: false,
  customError: false,
  patternMismatch: true,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: true,
  valueMissing: false,
  valid: true
}
```

有几个有用的属性，它们都持有布尔值`true`或`false`。

一些你可以自己进一步探索的有用属性包括`valueMissing`属性，当必填输入字段留空时该属性为`true`。或者是`patternMismatch`，如果值不匹配指定的正则表达式模式则为`true`。

学完这节课后，我鼓励你玩弄这节课给出的例子，并探索更多关于不同validity属性的内容。

# --questions--

## --text--

约束验证API的哪个方法用于检查输入元素是否满足所有验证约束？

## --answers--

`validateInput()`

### --feedback--

课程在向输入元素添加事件监听器时演示了这个方法。

---

`checkValidity()`

---

`isValid()`

### --feedback--

课程在向输入元素添加事件监听器时演示了这个方法。

---

`testConstraints()`

### --feedback--

课程在向输入元素添加事件监听器时演示了这个方法。

## --video-solution--

2

## --text--

在表单验证中`setCustomValidity()`方法的目的是什么？

## --answers--

为无效输入设置自定义CSS样式。

### --feedback--

课程解释了如何使用这个方法为用户提供更多信息反馈。

---

创建自定义验证规则。

### --feedback--

课程解释了如何使用这个方法为用户提供更多信息反馈。

---

为无效输入显示自定义错误消息。

---

覆盖默认的HTML验证。

### --feedback--

课程解释了如何使用这个方法为用户提供更多信息反馈。

## --video-solution--

3

## --text--

当必填输入字段留空时，`validity`对象的哪个属性变为true？

## --answers--

`isEmpty`

### --feedback--

课程在记录空必填字段的`validity`对象时显示了这个属性。

---

`required`

### --feedback--

课程在记录空必填字段的`validity`对象时显示了这个属性。

---

`valueMissing`

---

`invalidValue`

### --feedback--

课程在记录空必填字段的`validity`对象时显示了这个属性。

## --video-solution--

3