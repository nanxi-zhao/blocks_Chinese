---
id: 68baa5e4f0e07f079245ca08
title: 深度优先搜索和广度优先搜索是如何工作的？
challengeType: 19
dashedName: how-do-depth-first-and-breadth-first-search-work
---

# --description--

当你开始使用数据结构和算法时，很快就会意识到你需要执行的常见操作之一是访问每个节点。

这个过程被称为"遍历"数据结构。

遍历用于对数据结构中的每个节点执行某些操作，比如打印它们的值、查找特定值，或对节点执行某些操作。

通过系统地访问每个节点，你可以确保该过程不会跳过任何节点。

但是你如何确定应该以什么顺序遍历数据结构呢？该过程应该从哪里开始，下一个节点应该如何选择？

如果没有明确的方法来遍历数据结构，遍历它就像在没有特定路径可遵循的迷宫中行走一样。

这就是广度优先搜索(BFS)和深度优先搜索(DFS)等算法变得非常重要的地方。它们通常用于遍历图和查找两个节点之间的路径。

当它们用于遍历数据结构时，它们定义了应该访问节点的顺序，以确保不会跳过任何节点。

让我们从广度优先搜索(BFS)开始。

## 广度优先搜索(BFS)

**广度优先搜索(BFS)**是一种在移动到图中的下一层之前访问所有相邻节点的算法。

它可以用于在无权图中找到两个节点之间的最短路径，因为它分析每一层的所有节点，所以它首先找到边数最少的路径。

该算法通常使用队列数据结构来跟踪已访问的节点。队列遵循FIFO(先进先出)方法，其中第一个添加到队列中的节点是第一个被移除的节点。

算法的工作原理如下：

* 你从一个特定节点开始。

* 该节点被标记为已访问并添加到队列中。

* 当队列不为空时，当前节点从队列中移除(出队)。然后，对于它的每个邻居，如果邻居尚未被访问，则将其标记为已访问并添加到队列中。

一个重要的考虑因素是，由于广度优先搜索(BFS)需要在内存中存储队列，而这个队列可能包含大量节点，因此该算法的空间需求可能相当大。这对于同一层上有大量节点的图尤其如此。

让我们看看BFS应用于称为树的特定类型图的示例。

你将在即将到来的课程中了解更多关于树的知识，但它们本质上是没有循环的图，其中节点按层次结构组织。循环是从同一节点开始和结束的路径。

让我们将广度优先搜索(BFS)算法应用到这棵树上：

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-1.png" alt="树形图显示了按层次结构排列的节点A到G。节点A在根部，有子节点B和C。节点B有子节点D和E，节点C有子节点F和G。" />

**步骤1：**

我们从树的根节点A开始。我们将A添加到队列中并立即标记为已访问。

* **队列：** `[A]`

* **已访问：** `{A}`

**步骤2：**

我们对节点A进行出队操作。我们将它的未访问子节点(节点B然后是节点C)添加到队列中并标记为已访问。

* **队列：** `[B, C]`

* **已访问：** `{A, B, C}`

同一层节点添加到队列中的顺序由数据结构的实现和图表示中存储边(连接)的顺序定义。

如果实现是一致的，同一层节点遍历的特定顺序不会影响算法的正确性。它仍然会逐层访问每个节点。

**步骤3：**

我们对节点B进行出队操作。我们将它的未访问子节点(节点D然后是节点E)添加到队列中并标记为已访问。

* **队列：** `[C, D, E]`

* **已访问：** `{A, B, C, D, E}`

**步骤4：**

我们对节点C进行出队操作。我们将它的未访问子节点(节点F然后是节点G)添加到队列中并标记为已访问。

* **队列：** `[D, E, F, G]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤5：**

我们对节点D进行出队操作。该节点没有任何未访问的子节点，因此已访问集合中没有任何变化。

* **队列：** `[E, F, G]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤6：**

我们对节点E进行出队操作。该节点没有任何未访问的子节点，因此已访问集合中没有任何变化。

* **队列：** `[F, G]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤7：**

我们对节点F进行出队操作。该节点没有任何未访问的子节点，因此已访问集合中没有任何变化。

* **队列：** `[G]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤8：**

我们对节点G进行出队操作。该节点没有任何未访问的子节点，因此已访问集合中没有任何变化。

* **队列：** `[]`

* **已访问：** `{A, B, C, D, E, F, G}`

当队列为空时，遍历完成。

节点按以下顺序遍历：

**A → B → C → D → E → F → G**

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-2.png" alt="相同的树形图，箭头显示BFS遍历顺序：A到B到C到D到E到F到G，演示逐层访问。" />

注意算法如何逐层访问节点。

我们从节点A开始，然后移动到下一层访问节点B和C，再移动到下一层访问节点D、E、F和G。这就是广度优先搜索(BFS)的核心原理。

## 深度优先搜索(DFS)

虽然广度优先搜索(BFS)首先访问同一层的所有相邻节点，但**深度优先搜索(DFS)**在回溯之前会尽可能深入地跟踪每个分支。

你可以将这个算法想象成通过选择特定路径并沿着它走直到到达死胡同或出口来探索迷宫。如果你到达死胡同，你会回去选择不同的路径。

深度优先搜索(DFS)通常用于解决具有单一解的谜题、检测图中的循环和查找连接的图组件。

该算法可以使用递归或堆栈数据结构来跟踪已访问的节点。

堆栈遵循LIFO(后进先出)方法，其中最后添加到堆栈中的节点是第一个从堆栈中移除的节点。

算法的工作原理如下：

* 从特定节点开始。

* 该节点被标记为已访问并添加到堆栈中。

* 当堆栈不为空时，当前节点被弹出(移除)。这时我们"访问"或处理它(例如，通过打印其值)。然后，所有未访问的邻居都被标记为已访问并添加到堆栈中。

该算法的一个限制是它不能保证在无权图中找到两个节点之间的最短路径。

让我们看看深度优先搜索(DFS)应用于我们的树示例的示例。

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-3.png" alt="与之前相同的树形图，显示了节点A到G的层次结构，为DFS演示做好准备。" />

**步骤1：**

我们从根节点A开始。我们将其标记为已访问并添加到堆栈中。

* **堆栈：** `[A]`

* **已访问：** `{A}`

**步骤2：**

我们从堆栈中弹出节点A。

然后，我们将它的未访问子节点节点B和节点C添加到堆栈中。我们将按相反顺序添加它们，`C`然后`B`，这样`B`就在顶部(LIFO)并将在下一步处理。我们还将它们标记为已访问。

* **堆栈：** `[C, B]`

* **已访问：** `{A, B, C}`

**步骤3：**

我们从堆栈中弹出节点B。

然后，我们将它的未访问子节点节点D和节点E按相反顺序(`E`然后`D`)添加到堆栈中。我们还将它们标记为已访问。

* **堆栈：** `[C, E, D]`

* **已访问：** `{A, B, C, D, E}`

**步骤4：**

我们从堆栈中弹出节点D。该节点没有子节点可以添加到堆栈中。

* **堆栈：** `[C, E]`

* **已访问：** `{A, B, C, D, E}`

**步骤5：**

我们从堆栈中弹出节点E。该节点没有子节点可以添加到堆栈中。

* **堆栈：** `[C]`

* **已访问：** `{A, B, C, D, E}`

**步骤6：**

我们弹出节点C。

然后，我们将它的子节点节点F和节点G按相反顺序(节点G然后节点F)添加到堆栈中，并将它们标记为已访问。

* **堆栈：** `[G, F]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤7：**

我们从堆栈中弹出节点F。该节点没有子节点可以添加到堆栈中。

* **堆栈：** `[G]`

* **已访问：** `{A, B, C, D, E, F, G}`

**步骤8：**

我们弹出节点G。该节点没有子节点可以添加到堆栈中。

* **堆栈：** `[]`

* **已访问：** `{A, B, C, D, E, F, G}`

当堆栈为空时，遍历完成，所有节点都已访问。

算法按以下顺序访问节点：

**A → B → D → E → C → F → G**

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/how-do-depth-first-and-breadth-first-search-work-4.png" alt="树形图，数字显示DFS遍历顺序：A(1), B(2), D(3), E(4), C(5), F(6), G(7)，演示深度优先探索分支。" />

注意我们如何从节点A开始，然后一直向下到树的节点B，以及节点D和E，然后我们再次向上移动到节点C，然后是节点F和G。这就是深度优先搜索(DFS)的核心原理，在回溯和寻找其他路径之前遍历完整路径。

在这种情况下，我们使用堆栈解决了这个示例。或者，深度优先搜索(DFS)可以使用递归来实现，其中函数处理当前节点，然后为每个未访问的邻居调用自身。函数调用堆栈隐式管理LIFO(后进先出)顺序。

广度优先搜索(BFS)和深度优先搜索(DFS)都是遍历图和树的基本算法。广度优先搜索(BFS)逐层探索节点，非常适合在无权图中找到最短路径。另一方面，深度优先搜索(DFS)在回溯之前尽可能深入地跟踪一个分支，非常适合解决迷宫和检测循环。了解它们的优缺点有助于为特定问题选择正确的算法。

# --questions--

## --text--

以下哪种数据结构通常用于实现标准的广度优先搜索(BFS)算法？

## --answers--

堆栈

### --feedback--

想想队列如何处理数据以及这与逐层访问节点有何关系。

---

队列

---

链表

### --feedback--

想想队列如何处理数据以及这与逐层访问节点有何关系。

---

树

### --feedback--

想想队列如何处理数据以及这与逐层访问节点有何关系。

## --video-solution--

2

## --text--

关于深度优先搜索(DFS)的以下陈述哪一个是正确的？

## --answers--

深度优先搜索保证在无权图中找到两个节点之间的最短路径。

### --feedback--

想想深度优先搜索(DFS)用来遍历数据结构的策略。

---

深度优先搜索在移动到下一层之前访问当前层的所有邻居。

### --feedback--

想想深度优先搜索(DFS)用来遍历数据结构的策略。

---

深度优先搜索总是比BFS更节省空间。

### --feedback--

想想深度优先搜索(DFS)用来遍历数据结构的策略。

---

深度优先搜索通常使用递归或堆栈实现。

## --video-solution--

4

## --text--

如果你想在无权图中找到从起始节点到目标节点的最短路径，哪种算法是最合适的选择？

## --answers--

广度优先搜索(BFS)

---

深度优先搜索(DFS)

### --feedback--

想想广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

---

二分搜索

### --feedback--

想想广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

---

归并排序

### --feedback--

想想广度优先搜索和深度优先搜索的核心遍历策略，以及哪一种能保证找到两个节点之间的最短路径。

## --video-solution--

1