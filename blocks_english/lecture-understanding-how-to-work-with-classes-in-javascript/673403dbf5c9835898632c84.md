---
id: 673403dbf5c9835898632c84
title: 类中的静态属性和方法是什么？
challengeType: 19
dashedName: what-are-static-properties-and-methods-in-classes
---

# --description--

让我们来学习静态属性和方法。

静态属性和方法属于类本身，而不是类的单个实例。你可以直接在类名上访问它们，而无需创建类的实例。它们在类中定义以封装相关功能。

你可以通过在方法名前写[static](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)关键字来定义静态方法。

```js
class MyClass {
  static staticMethod() { ... }
}
```

然后，你可以直接在类上使用点符号调用静态方法，并传递任何必要的参数：

```js
MyClass.staticMethod();
```

注意你可以在不创建类实例的情况下调用该方法。这是静态方法的关键特征之一。

这里有一个例子。假设我们正在创建一个电影应用程序，我们希望能够根据评分来比较电影。

我们可以将这种比较方法视为一个更高级别的方法，它不特定于任何电影：

```js
if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } 
```

这就像一个与[Movie](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类相关的更一般的方法。

为了可读性和可维护性的目的，将它定义在[Movie](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类中以保持所有相关方法相对接近是有帮助的。

因此，这是静态方法的完美候选。你可以在这里看到，就在构造函数下面：

```js
class Movie {

  constructor(title, rating) {
    this.title = title;
    this.rating = rating;
  }

  static compareMovies(movieA, movieB) {
    if (movieA.rating > movieB.rating) {
      console.log(`${movieA.title} has a higher rating.`);
    } else if (movieA.rating < movieB.rating) {
      console.log(`${movieB.title} has a higher rating.`);
    } else {
      console.log("These movies have the same rating.");
    }
  }

}
```

静态方法用[static](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)关键字定义，名为[compareMovies](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)。它有两个参数：[movieA](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)和[movieB](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)。这些将是[Movie](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的实例。

我们将根据它们的评分在`0`到`100`的范围内进行比较。这个逻辑通过条件语句实现，它将根据哪部电影评分更高来打印适当的消息。

一旦方法被定义，你可以在类上调用它。但首先，你需要在程序中准备好并定义参数。

在这种情况下，方法接受两个电影实例作为参数，所以我们在这里定义这些实例：

```js
let movieA = new Movie("Movie A", 80);
let movieB = new Movie("Movie B", 45);
```

你可以看到[movieA](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)的评分比[movieB](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)高。让我们看看这个方法的输出。

要调用该方法，你只需要在类本身上使用点符号。你写类的名称（[Movie](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)），后跟一个点，然后是静态方法的名称（[compareMovies](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L54-L62)）。

然后，你在括号内传递参数。在这种情况下，它们是方法所需的两个电影实例。

```js
Movie.compareMovies(movieA, movieB);
```

这是输出：

```js
Movie A has a higher rating.
```

静态方法对于实现"工厂"方法也很有帮助。工厂方法是你除了构造函数之外定义的方法，用于根据特定条件创建对象。

这里有一个[Pizza](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的例子。静态方法[createMargherita](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L107-L109)是一个工厂方法，你可以调用它来创建一个玛格丽特披萨实例，其类型和价格已经设置好了。

```js
class Pizza {
  constructor(type, price) {
    this.type = type;
    this.price = price;
  }

  static createMargherita() {
    return new this("Margherita", 6.99);
  }
}
```

这也引出了关于静态方法的一个非常重要的点。

静态方法中[this](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js#L45-L45)关键字的值是类本身，因为静态方法属于类。

这就是为什么我们可以使用[this](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js#L45-L45)来创建[Pizza](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类的新实例。

如果你在[Pizza](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类本身上调用这个方法并将返回的实例赋值给一个变量，就像这个例子中一样：

```js
let myPizza = Pizza.createMargherita();
```

你可以在代码中需要的地方使用它。例如，你可以将它打印到控制台：

```js
console.log(myPizza);
```

这是输出：

```js
Pizza { type: 'Margherita', price: 6.99 }
```

你也可以使用点符号调用它的方法和访问它的属性，像这样：

```js
console.log(myPizza.type);
```

这是输出：

```js
Margherita
```

除了方法，你还可以使用[static](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/pragma.js#L42-L42)关键字定义静态属性。

在这个例子中，我们有一个静态的[numberOfPizzasSold](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-working-with-classes-in-javascript/673403dbf5c9835898632c84.md#L155-L155)属性。

```js
class Pizza {
  static numberOfPizzasSold = 0;

  constructor(type) {
    this.type = type;
    Pizza.numberOfPizzasSold++;
  }
}
```

它是静态的，因为它不属于任何特定的披萨实例，而是属于类本身。

它的初始值为`0`，每次创建新实例时都会更新。

如果你创建两个披萨实例，值将更新两次：

```js
let pizza1 = new Pizza("Margherita");
let pizza2 = new Pizza("Neapolitan");
```

要访问静态属性的值，你只需要在类本身上使用点符号，因为属性属于类。

```js
console.log(Pizza.numberOfPizzasSold);
```

在这种情况下，输出是`2`，因为卖出了两个披萨。

这些是JavaScript中静态属性和方法的基础知识。理解静态成员对于创建可重用和高效的类至关重要。

# --questions--

## --text--

JavaScript类中静态方法的主要目的是什么？

## --answers--

创建类的新实例。

### --feedback--

想想静态方法如何与类本身相关，而不是与单个对象相关。

---

访问类实例的属性。

### --feedback--

想想静态方法如何与类本身相关，而不是与单个对象相关。

---

定义无需创建类实例即可访问的方法。

---

从父类继承属性和方法。

### --feedback--

想想静态方法如何与类本身相关，而不是与单个对象相关。

## --video-solution--

3

## --text--

JavaScript中静态方法和实例方法的主要区别是什么？

## --answers--

静态方法只能在类内部使用，而实例方法可以在类外部使用。

### --feedback--

想想静态方法和实例方法的范围和可访问性。

---

静态方法可以访问实例属性，而实例方法不能访问实例属性。

### --feedback--

想想静态方法和实例方法的范围和可访问性。

---

静态方法与类本身相关联，而实例方法与类的特定实例相关联。

---

静态方法总是公共的，而实例方法可以是公共的或私有的。

### --feedback--

想想静态方法和实例方法的范围和可访问性。

## --video-solution--

3

## --text--

在JavaScript中如何访问类的静态属性？

## --answers--

通过使用[this](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js#L45-L45)关键字。

### --feedback--

想想静态属性如何与类本身相关联。

---

通过创建类的实例并通过实例访问属性。

### --feedback--

想想静态属性如何与类本身相关联。

---

通过直接使用类名和属性名。

---

通过使用类的原型属性。

### --feedback--

想想静态属性如何与类本身相关联。

## --video-solution--

3