---
id: 68ca71c3f0ee7ece4ea1e286
title: 什么是名称改编，它是如何工作的？
challengeType: 19
dashedName: what-is-name-mangling-and-how-does-it-work
---

# --description--

在之前的课程中，你学习了用单下划线和双下划线作为前缀的属性。

为了提醒你它们之间的区别，单下划线是一个约定，意味着该属性是供类内部使用的，不应该从类外部直接访问。而双下划线则防止该属性从类外部直接访问。

以下是演示两者如何工作的示例：

```py
class Example:
    def __init__(self):
        self._internal = 'I can be accessed from outside the class, but should not'
        self.__private = 'You cannot access me directly from outside the class'

obj = Example()

print(obj._internal) # I can be accessed from outside the class, but should not
print(obj.__private)  # AttributeError: 'Example' object has no attribute '__private'
```

用双下划线作为前缀的属性会触发Python的名称改编过程，Python在内部通过添加下划线和类名作为前缀来重命名该属性，将[__attribute](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)转换为[_ClassName__attribute](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L51-L51)。

要看到这个实际效果，你可以创建类的实例并使用该实例的[__dict__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L177-L177)特殊属性，这是一个包含对象属性的字典：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)

print(example1.__dict__)
```

结果将是：

```py
{
  '_internal': 'I can be accessed from outside the class, but should not',
  '_Example__private': 'I cannot be accessed directly from outside the class'
}
```

如你所见，[__private](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)属性被存储为[_Example__private](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L51-L51)。这意味着你可以通过这种方式从类外部访问该属性：

```py
class Example:
    def __init__(self, internal, private):
        self._internal = internal
        self.__private = private

example1 = Example(
    'I can be accessed from outside the class, but should not',
    'I cannot be accessed directly from outside the class'
)
example2 = Example(
    'I should not be accessed from outside the class',
    'But I can be accessed from outside the class with name mangling'
)

print(example1._Example__private) # I cannot be accessed directly from outside the class
print(example2._Example__private) # But I can be accessed from outside the class with name mangling
```

那么，为什么Python要进行名称改编呢？

名称改编的主要目的是防止在使用继承时意外覆盖属性和方法。以下是一个清楚说明这一点的示例：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

你可以看到，[Parent](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类和从它继承的[Child](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)类都有各自独立的[_class__data](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L51-L51)属性。这通过名称改编实现。否则，[Child](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/eslint-plugin-react/lib/util/propTypes.js#L45-L45)会意外地覆盖Parent数据。

以下是如果不允许Python进行名称改编会发生什么，也就是说如果你不在两个类中用双下划线作为属性前缀：

```py
class Parent:
   def __init__(self):
       self.data = 'Parent data'

class Child(Parent):
   def __init__(self):
       super().__init__()
       self.data = 'Child data'

c = Child()
print(c.__dict__)  # {'data': 'Child data'}
```

那么，你应该使用单下划线（[_](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L19-L19)）还是双下划线（[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)）作为属性前缀呢？这取决于情况。如果属性只供类内部使用，坚持使用单下划线。

但如果你正在处理一个将被继承的类，你应该使用双下划线，这样父类的属性就不会被覆盖。

# --questions--

## --text--

单下划线和双下划线之间有什么区别？

## --answers--

单下划线和双下划线在Python中以相同的方式处理。

### --feedback--

关注Python如何处理以[_](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L19-L19)和[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)开头的属性。

---

单下划线使属性完全私有，而双下划线使它们受保护。

### --feedback--

关注Python如何处理以[_](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L19-L19)和[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)开头的属性。

---

单下划线防止直接访问，而双下划线允许直接访问。

### --feedback--

关注Python如何处理以[_](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L19-L19)和[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)开头的属性。

---

单下划线只是一个约定，而双下划线触发名称改编。

### --feedback--

关注Python如何处理以[_](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L19-L19)和[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)开头的属性。

## --video-solution--

4

## --text--

什么是名称改编？

## --answers--

Python将所有属性转换为方法以便于访问的过程。

### --feedback--

想想Python如何在内部重命名双下划线属性。

---

Python删除带单下划线的属性以保持它们隐藏的过程。

### --feedback--

想想Python如何在内部重命名双下划线属性。

---

Python将[__attribute](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)转换为[_ClassName__attribute](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L51-L51)以避免在子类中意外覆盖的过程。

### --feedback--

想想Python如何在内部重命名双下划线属性。

---

Python加密私有数据使其无法从类外部访问的过程。

### --feedback--

想想Python如何在内部重命名双下划线属性。

## --video-solution--

3

## --text--

当你不在父类和子类中用双下划线作为属性前缀时会发生什么？

## --answers--

两个类都保持各自独立的属性副本而不互相干扰。

### --feedback--

想想当两个类都使用相同的属性名而不使用[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)时，[print(c.__dict__)](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L177-L177)显示什么。

---

子类完全覆盖父类属性，父类的数据丢失。

### --feedback--

想想当两个类都使用相同的属性名而不使用[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)时，[print(c.__dict__)](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L177-L177)显示什么。

---

父类属性变为只读，子类无法更改。

### --feedback--

想想当两个类都使用相同的属性名而不使用[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)时，[print(c.__dict__)](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L177-L177)显示什么。

---

Python引发错误，因为属性必须始终用双下划线作为前缀。

### --feedback--

想想当两个类都使用相同的属性名而不使用[__](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/lecture-understanding-inheritance-and-polymorphism/68ca71c3f0ee7ece4ea1e286.md#L20-L20)时，[print(c.__dict__)](file:///e:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node-fetch/node_modules/@types/node/globals.d.ts#L177-L177)显示什么。

## --video-solution--

2