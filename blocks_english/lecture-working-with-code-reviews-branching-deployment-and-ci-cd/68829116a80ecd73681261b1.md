---
id: 68829116a80ecd73681261b1
title: 与远程对应部分保持同步的良好实践有哪些？
challengeType: 19
dashedName: what-are-good-practices-for-remaining-in-sync-with-your-remote-counterparts
---

# --description--

我们已经稍微谈到了使用分支来处理隔离的更改，以避免污染你的 `main` 分支。但这意味着什么，为什么它很重要？

如果你直接向 `main` 分支提交更改，而上游仓库接受了不属于你的其他更改，你最终会遇到所谓的"分歧历史"。这意味着你的 `main` 分支上的提交不再与上游 `main` 分支上的提交对齐。这让同步上游更改变成了一场噩梦。

所以，假设你一直在遵循良好的分支实践，这不是问题。如果你跟随着我们之前的课程，你应该有一个你克隆到本地的仓库分支，并且你应该有一个指向原始仓库的上游远程。

如果你没有这样做，这里是一个快速提醒。你需要分叉一个仓库，在本地克隆你的分叉，并运行这个命令：

```sh
git remote add upstream <url>
```

将 `<url>` 替换为原始仓库的 SSH URL，而不是你的分叉。

配置好上游后，你可以运行以下一系列命令来拉取最新的上游更改：

```sh
git checkout main
git fetch upstream
git merge upstream/main
```

这些命令是做什么的？你已经了解了 `git checkout`，所以第一个命令确保你在本地的 `main` 分支上。

第二个命令 `git fetch upstream` 告诉 Git 去获取上游远程（即原始仓库）的最新更改。但是，与拉取不同，Git 不会自动更新你的分支。这很重要，因为你的本地 `main` 分支连接到你的分叉上的 `main` 分支——而不是原始仓库上的 `main` 分支！执行 git 拉取可能会导致意外行为。

最后一个命令 `git merge upstream/main` 告诉 Git 将上游远程中 `main` 分支的最新更改合并到你的当前分支——即你的本地 `main` 分支，因为我们已经检出了它。

但如果合并失败怎么办？如果你不小心提交到了 `main`，而 Git 无法合并分歧的历史怎么办？好吧...假设你没有从 `main` 分支发出任何拉取请求，你可以进行硬重置来强制 Git 更新你的分支。

```sh
git reset --hard upstream/main
```

`git reset` 命令允许你重置分支的当前状态。传递 `--hard` 标志告诉 Git 强制本地文件与分支状态匹配。这确保你有一个干净的工作环境。传递 `upstream/main` 告诉 Git 你希望你的当前分支（即 `main`）与上游远程的 `main` 分支匹配。对这个命令要小心——任何时候你强行更新 Git 历史，都可能发生奇怪和不幸的事情。

一旦你正确更新了本地 `main` 分支，将该状态推送到你的远程分叉（如果按照我们的课程应该是 `origin`）是很重要的。要做到这一点，你可以运行：

```sh
git push
```

这会将当前状态推送到你的远程分叉。但如果你不得不进行硬重置来清理历史，你的远程分叉也可能有分歧的历史，推送可能会失败。

你可以通过强制推送来纠正这个问题：

```sh
git push --force
```

**对这个命令要小心**。强制推送实际上重写了你的远程历史，如果你做错了什么，那么强制推送就会变成一场噩梦来解开。

将同步的更改推送到你的远程分叉很重要，因为它帮助你确保如果你丢失了现有的本地仓库，可以安全地克隆带有最新更改的分叉。

一旦你同步了 `main` 分支，你就可以从该状态创建一个新分支来开始处理另一个贡献——使用原始代码库的最新版本！

# --questions--

## --text--

为什么在使用分叉仓库时应该避免直接向 `main` 分支提交更改？

## --answers--

因为它会创建重复的提交。

### --feedback--

想想当你的分支和原始仓库分别发展时会发生什么。

---

因为它会导致"分歧历史"，使得与上游同步变得困难。

---

Git 不允许直接向 main 分支提交。

### --feedback--

想想当你的分支和原始仓库分别发展时会发生什么。

---

因为它会自动删除你的本地更改。

### --feedback--

想想当你的分支和原始仓库分别发展时会发生什么。

## --video-solution--

2

## --text--

以下哪一系列命令能正确地用原始仓库的更改更新你的本地 `main` 分支？

## --answers--

`git checkout main`; `git pull upstream`

### --feedback--

考虑获取上游更改而不会扰乱你的分叉所需的逐步过程。

---

`git pull upstream main`

### --feedback--

考虑获取上游更改而不会扰乱你的分叉所需的逐步过程。

---

`git checkout main`; `git fetch upstream`; `git merge upstream/main`

---

`git fetch upstream/main`; `git merge`

### --feedback--

考虑获取上游更改而不会扰乱你的分叉所需的逐步过程。

## --video-solution--

3

## --text--

如果你不小心向 `main` 分支提交了，并且无法合并上游更改，什么命令可以强制重置你的 `main` 分支以匹配上游（假设你没有发出任何拉取请求）？

## --answers--

`git checkout upstream/main`

### --feedback--

哪个命令完全重置你的分支以匹配另一个分支的状态？

---

`git reset --hard upstream/main`

---

`git rebase upstream/main`

### --feedback--

哪个命令完全重置你的分支以匹配另一个分支的状态？

---

`git clean upstream/main`

### --feedback--

哪个命令完全重置你的分支以匹配另一个分支的状态？

## --video-solution--

2