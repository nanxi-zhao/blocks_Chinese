---
id: 68420c314cdf5c6863ca8330
title: 什么是算法，大O表示法是如何工作的？
challengeType: 19
dashedName: what-is-an-algorithm-and-how-does-big-o-notation-work
---

# --description--

在您的设备上运行的每个计算机程序都有一组特定的指令，这些指令按特定顺序执行以完成任务。

任务可以是排序一组数字、修改图像、跟踪库存，甚至是运行您最喜欢的游戏。

这就是算法发挥作用的地方。**算法**是解决一个问题或执行任务的一组明确指令。

您可以将算法视为"食谱"。当您烹饪时，食谱列出了您需要的所有食材，并提供逐步说明如何准备一道菜。

同样，您可以将算法视为告诉计算机确切应该做什么以及如何做的"食谱"。

算法有两个关键特征：

* 它们不能无限期地继续。它们必须在有限的步骤内完成。

* 每个步骤都必须精确且明确。

它们可能有零个、一个或多个输入，并生成一个或多个输出。

算法的步骤与任何编程语言无关。

但要让它们在计算机上实际运行，您需要在编程语言中实现它们，如Python或JavaScript。

如果算法是正确的，任何有效输入的输出都应该与预期输出匹配。

除了正确性，算法还应该是高效的。

算法效率可以从它们运行所需的时间和完成任务所需的内存空间来衡量。

了解算法的效率非常重要，因为它让您了解随着输入规模的增长，算法的表现如何。

例如，排序15个整数与排序100万个整数是不同的。

随着过程规模和复杂性的增长，如果算法不够高效来处理它，您最终可能会得到一个非常慢的计算机程序，甚至可能崩溃整个系统。

这就是为什么开发和选择最高效的算法非常重要。

这就是大O表示法变得非常重要的地方。

大O表示法描述了算法在输入规模增加时的最坏情况性能或增长率。

算法的增长率指的是随着输入规模增长，它所需的资源如何增加。

大O表示法关注最坏情况性能，因为这种情况对于理解算法的效率非常重要，即使在最坏情况下也是如此，无论输入如何。

回到我们的排序示例，直观上排序100万个整数应该比排序15个整数花费更多的时间和资源。

但要多多少呢？

这真的取决于您选择用来排序的算法。

大O表示法不会给您一个确切的数字来描述算法的效率，但它会根据算法执行的操作数量，给您一个关于随着输入规模增长它如何扩展的想法。

在大O表示法中，我们通常用字母[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)表示输入规模。例如，如果输入是一个列表，[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)将表示该列表中的元素数量。

在基于操作数量找到算法的时间复杂度时，不考虑常数因子和低阶项。这是因为随着[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)的增长，这些较小项在总操作数中的影响会变得越来越小。

将主导算法整体行为的项将是带有[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)的项，即输入规模。

例如，如果一个算法执行[7n + 20](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L69-L69)次操作才能完成，随着[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)的增长，常数[20](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L69-L69)对最终结果的影响会越来越小。[7n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L69-L69)项将趋于主导，这将定义算法的整体行为和效率。

另一个例子是执行[20n² + 15n + 7](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L71-L71)次操作才能完成的算法。随着[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)的增长，[20n²](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L71-L71)项将趋于主导，所以这个算法将具有二次时间复杂度，因为主导项有[n²](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L71-L71)。

二次时间复杂度是算法世界中可以找到的许多不同时间复杂度类型之一。

让我们了解一些最常见的类型。

**[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L77-L77)** 被称为"常数时间复杂度"。当算法具有常数时间复杂度时，无论输入规模如何，它都花费相同的时间运行。

例如，检查一个数字是偶数还是奇数总是花费相同的时间，无论数字本身如何。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

**[O(log n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L89-L89)** 被称为"对数时间复杂度"。这意味着算法所需的时间随着输入规模的增长而缓慢增加。这在问题规模被常数分数反复减少的问题中很常见。

例如，一种名为二分搜索的流行搜索算法具有[O(log n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L89-L89)的最坏情况时间复杂度。这是因为每次比较都会消除剩余元素的一半，这使得它总体上更高效。

**[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L93-L93)** 被称为"线性时间复杂度"。具有这种时间复杂度的算法的运行时间与输入规模成比例增加。

例如，遍历列表所有元素的[for](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L97-L97)循环将随着列表元素数量的增加而执行更多迭代。如果列表大小翻倍，操作数量也会大约翻倍。

```python
for grade in grades:  # grades is a list.
    print(grade)
```

**[O(n log n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L102-L102)** 被称为"线性对数时间复杂度"。这是高效排序算法（如归并排序和快速排序）的常见时间复杂度。

**[O(n²)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L104-L104)** 被称为"二次时间复杂度"。这些算法的运行时间相对于输入规模二次增长，这对于现实世界的问题通常效率不高。

嵌套循环是二次时间复杂度的常见例子。对于外循环的每个[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)次迭代，内循环将执行[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)次迭代，导致[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)平方次迭代。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

其他时间复杂度包括"指数时间复杂度"，表示为[O(2^n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L114-L114)，和"阶乘时间复杂度"，表示为[O(n!)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L114-L114)。两者对于现实场景都不够高效。

在该图中，您可以比较表示最常见时间复杂度的数学函数的增长。将x轴（水平）视为输入规模，将y轴（垂直）视为算法的运行时间。

您可以看到二次时间复杂度（[O(n²)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L104-L104)）（黄色）比其他复杂度增长得快得多，而常数时间复杂度（[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L77-L77)）（红色）保持不变，即使输入变得更大。

<img src="https://cdn.MasterPuti.org/curriculum/lecture-transcripts/what-is-an-algorithm-and-how-does-big-o-notation-work-1.png" alt="graph comparing time complexity" />

很好。到目前为止，您已经了解了时间要求方面的大O表示法，但这种表示法也可以应用于空间要求的上下文。

在这种情况下，它描述了随着输入规模增长，算法所需的内存空间如何增长。

具有"常数空间复杂度"[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L77-L77)的算法总是需要恒定的内存量，即使输入变得更大。

一个例子是只在内存中创建和存储几个变量的算法。

相比之下，具有"线性空间复杂度"[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L93-L93)的算法所需的空间随着输入规模的增长而成比例增加。

这方面的一个例子是创建和存储长度为[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L63-L63)的列表副本的算法。

最后，具有"二次空间复杂度"[O(n²)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L104-L104)的算法的空间需求随着输入规模的增长而二次增加。

这方面的一个例子是创建一个二维矩阵，其维度由输入规模决定，存储所有可能的对。

算法是计算机程序的构建块，而大O表示法是一个强大的框架，用于基于算法在最坏情况下的时间和空间需求随着输入规模增长而扩展的情况来分析它们的效率。了解它们的效率对于开发在现实场景中高效工作的软件非常重要。

# --questions--

## --text--

以下哪项最能描述算法？

## --answers--

用于编写代码的特定编程语言。

### --feedback--

想想当您试图完成特定任务时遵循的是什么。

---

为解决问题或执行任务而设计的一组逐步指令。

---

一种计算机硬件组件类型。

### --feedback--

想想当您试图完成特定任务时遵循的是什么。

---

用于开发和玩游戏的软件应用程序。

### --feedback--

想想当您试图完成特定任务时遵循的是什么。

## --video-solution--

2

## --text--

在算法的上下文中，大O表示法的主要用途是什么？

## --answers--

测量算法在特定计算机上运行的确切时间（以秒为单位）。

### --feedback--

想想大O表示法帮助您理解当算法处理的数据量变得非常大时，算法的性能如何。

---

计算算法中的总代码行数。

### --feedback--

想想大O表示法帮助您理解当算法处理的数据量变得非常大时，算法的性能如何。

---

描述算法的资源使用量如何随着输入规模的增加而增长。

---

确定算法的最佳情况性能。

### --feedback--

想想大O表示法帮助您理解当算法处理的数据量变得非常大时，算法的性能如何。

## --video-solution--

3

## --text--

如果算法的时间复杂度为[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/68420c314cdf5c6863ca8330.md#L93-L93)，这对它的性能意味着什么？

## --answers--

算法的运行时间与输入规模成比例增加。

---

无论输入规模如何，算法的运行时间保持不变。

### --feedback--

想想"线性"在直接关系或图表上的直线方面的含义。

---

算法的运行时间随着输入规模呈指数增长。

### --feedback--

想想"线性"在直接关系或图表上的直线方面的含义。

---

算法的运行时间随着输入规模的增大而减少。

### --feedback--

想想"线性"在直接关系或图表上的直线方面的含义。

## --video-solution--

1