---
id: 6895d06b5968736797c408e7
title: 映射、哈希映射和集合是如何工作的？
challengeType: 19
dashedName: how-do-maps-hash-maps-and-sets-work
---

# --description--

在本课中，我们将讨论映射、哈希映射和集合。但在此之前，让我们先定义抽象数据类型。

抽象数据类型（ADT）是数据类型的概念表示，包括可以在数据上执行的操作以及该数据的属性。

抽象数据类型就像蓝图，描述了可以执行的**操作**，而不是**如何**执行这些操作。它们将接口与操作的实际实现分离。

**映射**是一种ADT，以非常特定和高效的方式管理键值对集合及其操作。

在映射中，每个值都与特定键相关联。

映射的一个关键特征是每个键都必须是唯一的。这种唯一性允许直接查找，这使得检索信息的过程更加高效。

只有键必须是唯一的，值可以重复。

映射抽象数据类型还定义了重要操作，如插入键值对、获取与键关联的值、更新与键关联的值、删除键值对以及检查键是否存在于映射中。

它实际上并没有指定应该如何执行这些操作，只是将它们列为数据类型的可用操作。

**哈希映射**，也称为哈希表，是映射抽象数据类型的具体实现。

哈希映射使用一种称为"哈希"的技术来非常高效地执行常见操作。

哈希本质上通过使用哈希函数为每个元素生成哈希值来工作。

哈希值基于键值对的键生成，用于计算底层数组中的索引，这是存储键值对的实际数据结构。

但您可能会问自己：如果两个键产生相同的索引会发生什么？

哈希映射通过巧妙的策略解决这些冲突。

一种选择是使用"链式"策略，其中每个数组索引指向一个链表（另一种数据结构），其中存储了所有具有相同索引的元素。

另一种策略是使用"开放寻址"，这涉及根据预定义的搜索序列在数组中搜索下一个可用索引。

哈希映射的平均情况时间复杂度是"常数时间"[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)，用于插入、检索和删除键值对。

这些操作的最坏情况时间复杂度是线性时间[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L46-L46)，当存在许多哈希冲突时发生，因此冲突解决策略必须多次应用。

插入哈希映射的空间复杂度在平均情况下是常数[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)，存储新对需要恒定的内存量。然而，在最坏情况下，由于底层数组的调整大小操作，它可能具有线性空间复杂度[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L46-L46)。通常，删除元素具有常数空间复杂度[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)。

这将哈希表变成了类似于线性数据结构的东西，其中需要扫描[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L50-L50)个元素来找到目标键。然而，如果哈希映射实现得当，这种情况相对罕见。

Python的**字典**在幕后实现为哈希映射。

要创建Python字典，您只需要在花括号内写入键值对并用逗号分隔。每个键应该用冒号与其对应的值分隔。

```python
my_dictionary = {
  "A": 1,
  "B": 2, 
  "C": 3
}
```

在这段代码中，["A"](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L58-L58)是键，[1](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L58-L58)是值：

```python
"A": 1
```

或者，您可以使用[dict()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L70-L70)：

```python
my_dictionary = dict(A="1", B="2", C="3")
```

您可以通过其对应的键获取值：

```python
my_dictionary["A"]  # 1
```

您还可以更新与键关联的值：

```python
my_dictionary["A"] = 4
```

您可以删除键值对：

```python
del my_dictionary["A"]  
```

您还可以检查字典中是否存在键（或不存在）：

```python
"C" in my_dictionary
```

您可以调用这些方法分别获取字典的键、值和项。

```python
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

很好。现在您对映射和哈希映射有了更多了解，让我们来谈谈集合。

**集合**是唯一元素的无序集合。

让我们将这个概念分解为其关键组成部分：

* 集合是无序的。集合的元素不以任何特定顺序存储，因此您无法通过索引访问它们。

* 集合只包含唯一元素。如果您尝试添加相同的值两次，只会保留一个值的副本。

它们类似于数学中的集合，并且实现了相同的集合操作，如交集、并集和差集。

集合的主要优势之一是它们保证元素是唯一的（无重复）。这就是为什么它们经常用于从列表和其他数据结构中删除重复项。

它们也是动态的。它们可以调整到当前存储的元素数量。这使它们非常强大。

添加元素、删除元素、获取集合长度和检查元素是否在集合中的平均情况时间复杂度是"常数时间"[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)，这是非常高效的。

由于集合是使用哈希表实现的，添加、删除和检查成员资格的最坏情况时间复杂度是"线性时间"[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L46-L46)。当存在多个哈希冲突时可能会发生这种情况，将哈希表转换为类似于线性数据结构的东西，其中需要[n](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L50-L50)次扫描来找到键。

在空间复杂度方面，在平均情况下，插入元素将具有常数复杂度[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)，新唯一元素需要恒定的内存量。然而，在最坏情况下，可能存在底层数组的调整大小操作，这可能需要线性空间复杂度[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L46-L46)。通常，删除元素需要常数空间复杂度[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)。

Python有一个内置的[set](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L131-L131)数据结构，您可以在程序中使用它来处理集合。

在幕后，Python集合使用哈希表实现，其中只存储键，不存储任何关联的值。

集合只能存储不可变数据类型的对象，因为它们的哈希值始终保持不变。相比之下，可变对象的哈希值在它们被修改时可能会改变。这就是为什么它们不能成为集合的一部分。如果存储在集合中的对象的哈希值发生变化，程序将无法再找到它。

要在Python中定义集合，您只需要用花括号包围元素并用逗号分隔：

```python
numbers = {1, 2, 3, 4}
```

要创建空集合，您可以调用[set()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L143-L143)：

```python
numbers = set()
```

请注意，如果您使用空花括号，这将自动创建Python字典而不是集合，因此您必须调用[set()](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L143-L143)函数来创建空集合。

您可以使用.add()方法向集合添加元素：

```python
numbers.add(5)
```

您还可以使用.remove()方法从集合中删除元素：

```python
numbers.remove(5)
```

如果找不到元素，这将抛出[KeyError](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L163-L163)。但如果您不希望在这种情况下抛出错误，可以改用.discard()方法。

.pop()方法从集合中返回一个任意元素，而.clear()方法从集合中删除所有元素。

您可以使用[in](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L167-L167)运算符测试元素是否在集合中：

```python
5 in numbers
```

Python还支持集合操作，包括并集、差集、对称差集和交集，您可以使用这些方法执行：

```python
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

set_a.union(set_b)
set_a.intersection(set_b)
set_a.symmetric_difference(set_b)
set_a.difference(set_b)
```

或者使用它们的等效运算符：

```python
set_a | set_b
set_a & set_b
set_a ^ set_b
set_a - set_b 
```

添加、删除和测试成员资格的平均情况时间复杂度是"常数时间"[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)。

这些操作的最坏情况时间复杂度是"线性时间"[O(n)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L46-L46)，这是因为哈希映射的最坏情况冲突场景。

您还可以检查一个集合是否是另一个集合的子集或超集：

```python
set_a.issubset(set_b)
set_a.issuperset(set_b)
```

通常，当您需要存储唯一项集合并频繁检查项的存在时，应该使用集合。

映射、哈希映射和集合是为高效数据组织和检索而设计的强大数据结构。它们每一个都有其独特的特征和用例。作为开发人员，您需要为您的项目选择最佳的数据结构。

# --questions--

## --text--

哈希映射（或映射）与集合在存储数据类型方面的根本区别是什么？

## --answers--

哈希映射存储有序集合，而集合存储无序集合。

### --feedback--

想想每种数据结构主要用于存储什么。

---

哈希映射存储唯一的键值对，而集合存储唯一的单个元素。

---

哈希映射不能存储重复值，而集合可以。

### --feedback--

想想每种数据结构主要用于存储什么。

---

集合用于数值数据，而哈希映射用于文本数据。

### --feedback--

想想每种数据结构主要用于存储什么。

## --video-solution--

2

## --text--

什么是允许哈希映射和集合在插入和查找等操作中实现平均情况[O(1)](file:///F:/Code/blocks_Chinese/blocks_english/lecture-working-with-common-data-structures/6895d06b5968736797c408e7.md#L44-L44)（常数时间）性能的主要机制？

## --answers--

它们保持所有元素排序，实现快速二分搜索。

### --feedback--

想想将元素转换为索引的特殊函数。

---

它们将元素存储在链表中，允许快速遍历。

### --feedback--

想想将元素转换为索引的特殊函数。

---

它们使用哈希函数为元素计算直接的内存位置。

---

它们总是存储很少的元素，使所有操作都很快。

### --feedback--

想想将元素转换为索引的特殊函数。

## --video-solution--

3

## --text--

在哈希映射和集合的上下文中，什么是"哈希冲突"？

## --answers--

元素在搜索后成功找到时。

### --feedback--

想想当哈希函数将不同输入映射到相同输出时的结果。

---

元素插入到集合的最开始位置时。

### --feedback--

想想当哈希函数将不同输入映射到相同输出时的结果。

---

当哈希映射内存不足需要调整大小时。

### --feedback--

想想当哈希函数将不同输入映射到相同输出时的结果。

---

当两个不同的键或元素产生相同的哈希值时。

## --video-solution--

4