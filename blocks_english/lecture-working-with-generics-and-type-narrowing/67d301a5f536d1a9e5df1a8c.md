---
id: 67d301a5f536d1a9e5df1a8c
title: 什么是类型缩小，它是如何工作的？
challengeType: 19
dashedName: what-is-type-narrowing-and-how-does-it-work
---

# --description--

有时你会有一个具有广泛类型的值，需要将其缩小到更具体的类型。例如，你可能需要确保对象与你定义的接口匹配。或者字符串在特定值列表内。有几种方法可以实现这一点。

第一种是通过真实性缩小类型。考虑我们上一课的例子：

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email.value);
```

我们试图访问 `email` 的 `value` 属性时会得到编译器错误，因为 `email` 可能是 `null`。但是，我们可以在访问属性之前使用条件语句确认 `email` 是真实的：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (email) {
  console.log(email.value);
}
```

在更新后的示例中，因为 `null` 不是真实值，TypeScript 能够推断出在条件块内 `email` 必须是 `input` 元素。因此它不再抛出编译器错误。

真实性检查也可以反向工作：

```js
const email = document.querySelector<HTMLInputElement>("#email");
if (!email) {
  throw new ReferenceError("Could not find email element!")
}
console.log(email.value);
```

使用这种方法，如果 `email` 是假值，我们会抛出一个错误。`null` 是一个假值。抛出错误会结束这段代码的逻辑执行，这意味着当我们到达 `console.log()` 调用时，TypeScript 知道 `email` 不能是 `null`。

可选链也是一种类型缩小的形式，基于相同的前提，即如果 `email` 值是 `null`，则属性访问无法发生。

```js
const email = document.querySelector<HTMLInputElement>("#email");
console.log(email?.value);
```

那其他类型呢？你也可以使用 `typeof` 运算符缩小类型。让我们看一个示例，我们有一个变量可能表示字符串或数字：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
console.log(myVal / 10)
```

在这个示例中，我们看到一个编译器错误，因为我们无法对字符串值执行算术运算。但是我们可以使用条件来检查 `myVal` 变量的 `typeof`：

```js
const myVal = Math.random() > 0.5 ? 222 : "222";
if (typeof myVal === "number") {
  console.log(myVal / 10);
}
```

因为我们使用了 `typeof` 关键字，TypeScript 现在知道 `myVal` 必须是一个数字，我们可以安全地对其执行算术运算。

那更复杂的对象类型呢？如果相关对象来自一个类，你实际上可以使用 `instanceof` 关键字来缩小类型。回到我们的 `querySelector()` 示例：

```js
const email = document.querySelector("#email");
```

与其传递泛型类型并告诉 TypeScript 元素是什么，我们可以使用 `instanceof` 来缩小类型并编写更安全的代码：

```js
const email = document.querySelector("#email");

if (email instanceof HTMLInputElement) {
    console.log(email.value);
}
```

这种方法可能看起来与我们之前的方法相同，但 `instanceof` 是运行时验证 - 这意味着，如果我们 somehow 得到了错误的 TypeScript 类型，我们的 JavaScript 代码仍会确认 `email` 是一个 `input` 元素。

接下来，让我们看一个从 API 获取 `User` 对象并尝试打印信息的示例：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json();
printAge(myUser);
```

我们会得到一个编译器错误，试图将 `myUser` 传递给函数，因为即使我们知道 API 返回了正确的对象，TypeScript 并不知道。而且 `.json()` 方法不接受泛型类型。

解决这个问题的"简单"方法是转换类型：

```js
interface User {
    name: string;
    age: number;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
printAge(myUser);
```

但是每当你转换类型时，你实际上是在削弱 TypeScript 捕获潜在错误的能力。因此，与其转换类型，你可以编写一个类型保护：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}
```

这里的返回类型是此函数定义的关键组成部分。`user is User` 语法表示我们的函数返回一个布尔值，当为 `true` 时表示 `user` 值满足 `User` 接口。然后我们进行一些基本检查以确保 `user` 对象的结构匹配 - 注意使用了真实性 (`!!user`) 缩小和 `typeof` 缩小。我们必须这样做，因为 `typeof null` 返回 `"object"`：

```js
interface User {
    name: string;
    age: number;
}

const isValidUser = (user: unknown): user is User => {
  return !!user && 
    typeof user === "object" &&
    "name" in user &&
    "age" in user;
}

const printAge = (user: User) => 
  console.log(`${user.name} is ${user.age} years old!`)

const request = await fetch("url")
const myUser = await request.json() as User;
if (isValidUser(myUser)) {
    printAge(myUser);
}
```

现在，如果我们把所有逻辑结合起来，我们就不再得到编译器错误，可以成功构建代码。

类型缩小是一个强大的特性，有助于你编写更安全、更少错误的代码 - 但请记住，TypeScript 类型并不是完全刚性的，因此避免像没有缩小类型就转换值类型这样的做法。

# --questions--

## --text--

以下哪项不是课程中讨论的类型缩小方法？

## --answers--

真实性检查。

### --feedback--

虽然所有这些都可以用于缩小类型，但其中一个没有被提及。

---

可选链。

### --feedback--

虽然所有这些都可以用于缩小类型，但其中一个没有被提及。

---

`typeof` 运算符。

### --feedback--

虽然所有这些都可以用于缩小类型，但其中一个没有被提及。

---

Switch 语句。

## --video-solution--

4

## --text--

类型保护函数中的 `user is User` 语法的目的是什么？

## --answers--

它将 `user` 参数转换为 `User` 类型。

### --feedback--

想想 `is` 这个词，以及 `user is User` 这个短语是如何工作的。

---

它表示函数返回一个布尔值。

### --feedback--

想想 `is` 这个词，以及 `user is` User 这个短语是如何工作的。

---

它表示 `user` 满足 `User` 接口。

---

它创建 `User` 接口的新实例。

### --feedback--

想想 `is` 这个词，以及 `user is` User 这个短语是如何工作的。

## --video-solution--

3

## --text--

以下关于 TypeScript 中类型转换的哪项是正确的？

## --answers--

这是解决类型问题的推荐方法。

### --feedback--

类型转换应作为最后的手段。

---

它增强了 TypeScript 捕获错误的能力。

### --feedback--

类型转换应作为最后的手段。

---

它是使用 `as` 关键字完成的。

---

它应该总是用于替代类型保护。

### --feedback--

类型转换应作为最后的手段。

## --video-solution--

3