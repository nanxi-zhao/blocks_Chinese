---
id: 6733c5ba834ded4bb067e67c
title: 用于搜索的常见正则表达式修饰符有哪些？
challengeType: 19
dashedName: what-are-some-common-regular-expression-modifiers-used-for-searching
---

# --description--

修饰符，通常称为"标志"，修改正则表达式的行为。让我们回顾一下之前课程中的示例：

```js
const regex = /MasterPuti/;
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti is great")); // true
console.log(regex.test("I love MasterPuti")); // true
console.log(regex.test("MasterPuti")); // false
console.log(regex.test("MasterPuti")); // false
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

如果您记得，全小写和全大写的[MasterPuti]字符串未能匹配模式。这是因为，默认情况下，正则表达式区分大小写。

但是如果我们能让正则表达式忽略大小写怎么办？有一个修饰符可以做到这一点。[i]标志使正则表达式忽略大小写。我们如何使用它？标志放在正则表达式的右斜杠后面：

```js
const regex = /MasterPuti/i;
```

注意第一行正则表达式的改变。现在我们可以检查这如何改变事情：

```js
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti is great")); // true
console.log(regex.test("I love MasterPuti")); // true
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

因为我们的正则表达式现在不区分大小写，所以全小写和全大写的字符串都"通过"了测试。这也适用于随机混合大小写字母的字符串：

```js
console.log(regex.test("dO yOu LoVe MasterPuti?")); // true
```

您可以使用相当多的其他标志。[g]标志，或全局修饰符，允许您的正则表达式多次匹配模式。

让我们看看这如何影响我们的代码。您会注意到我们保留了[i]标志——正则表达式可以使用多个标志（根据需要）来实现您想要的行为：

```js
const regex = /MasterPuti/gi;
```

等一下...这是什么？全局修饰符似乎使一些应该通过的字符串失败了：

```js
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti is great")); // false
console.log(regex.test("I love MasterPuti")); // true
console.log(regex.test("MasterPuti")); // false
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("free")); // false
console.log(regex.test("code")); // false
console.log(regex.test("camp")); // false
```

为什么？全局修饰符使您的正则表达式具有状态性。这意味着它会跟踪之前匹配模式的位置。因此，当它匹配第一个[MasterPuti]字符串时，它会记住它在索引[0]处找到了匹配项。

然后我们用它测试[MasterPuti is great]，但它不从索引[0]开始。正则表达式"知道"它已经在索引[0]处找到了匹配项，所以即使这是不同的字符串，它也从匹配的结束索引开始。

[MasterPuti]是[12]个字符长，所以在[0]处的匹配在索引[11]处结束。匹配将在索引[12]处恢复。由于[is great]与[MasterPuti]不匹配，它返回[false]。

然后，因为它找不到匹配项，它"失去"了状态，并从[0]开始下一次匹配。

如果我们将日志调换一下，使匹配在[0]处的字符串后面紧跟一个在索引[11]之后有匹配项的字符串：

```js
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("I loooooooove MasterPuti")); // true
```

当正则表达式是全局的时，它会得到一个名为[lastIndex]的新属性。获取我们之前的代码，让我们看看这个属性如何工作：

```js
console.log(regex.lastIndex); // 0
console.log(regex.test("MasterPuti")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("MasterPuti is great")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("I love MasterPuti")); // true
console.log(regex.lastIndex); // 19
console.log(regex.test("MasterPuti")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("MasterPuti")); // true
console.log(regex.lastIndex); // 12
console.log(regex.test("free")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("code")); // false
console.log(regex.lastIndex); // 0
console.log(regex.test("camp")); // false
```

看这个示例，您可以看到正则表达式如何使用[lastIndex]跟踪其先前匹配项的状态如何随着每次测试调用而变化。

当您需要从单个字符串中获取多个匹配项时，全局标志很棒。但是如果您使用相同的正则表达式测试多个字符串，最好去掉[g]标志。

在学习下一个标志之前，您需要了解锚点。脱字符（[^]）锚点，在正则表达式的开头，表示"匹配字符串的开头"：

```js
const start = /^MasterPuti/i;
```

美元符号（[$]）锚点，在正则表达式的结尾，表示"匹配字符串的结尾"：

```js
const end = /MasterPuti$/i;
```

花点时间比较右侧的输出：

```js
const start = /^MasterPuti/i;
const end = /MasterPuti$/i;
console.log(start.test("MasterPuti")); // true
console.log(end.test("MasterPuti")); // true
console.log(start.test("MasterPuti is great")); // true
console.log(end.test("MasterPuti is great")); // false
console.log(start.test("i love MasterPuti")); // false
console.log(end.test("i love MasterPuti")); // true
console.log(start.test("have met MasterPuti's founder")); // false
console.log(end.test("have met MasterPuti's founder")); // false
```

看到起始锚点只在字符串开头匹配，结束锚点只在字符串结尾匹配吗？但是跨多行匹配呢？让我们看看：

```js
const start = /^MasterPuti/i;
const end = /MasterPuti$/i;
const string = `I really love
MasterPuti
it's my favorite`;
console.log(start.test(string)); // false
console.log(end.test(string)); // false
```

即使[MasterPuti]在自己的行上，两个测试都失败了。这是因为，默认情况下，锚点查找整个字符串的开头和结尾。

但是您可以使用[m]标志，或多行修饰符，使正则表达式处理多行。让我们将其添加到我们的正则表达式中，看看得到什么：

```js
const start = /^MasterPuti/im;
const end = /MasterPuti$/im;
const string = `I really love
MasterPuti
it's my favorite`;
console.log(start.test(string)); // true
console.log(end.test(string)); // true
```

现在它们都匹配了！因为[MasterPuti]完全在自己的行上，起始锚点匹配该行的开头，结束锚点匹配该行的结尾。

最后，您有[d]标志，或索引修饰符。记住[i]标志用于大小写不敏感，所以索引修饰符需要不同的标志。

[d]标志扩展了您在匹配对象中获得的信息。让我们将其添加到我们的正则表达式中：

```js
const regex = /MasterPuti/di;
const string = "we love MasterPuti isn't MasterPuti great?";
console.log(string.match(regex));
```

结果是：

```js
// [
//   'MasterPuti',
//   index: 8,
//   input: "we love MasterPuti isn't MasterPuti great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
```

我们的匹配对象得到了一个新的[indices]属性！这个属性是一个包含两个数字的数组，第一个是匹配在原始字符串中开始的索引，第二个是匹配结束后的位置索引。这个数组还有一个额外的[groups]属性，这也是用于命名捕获组的。

还有一些其他标志您应该知道是可用的，但在典型代码中不太常见。

第一个是unicode修饰符，或[u]标志。这扩展了正则表达式的功能，使其能够匹配特殊unicode字符。

您将在未来的课程中了解更多关于字符类的知识，但[u]标志让您能够访问特殊类，如[Extended_Pictographic]来匹配大多数表情符号：

```js
const regex = /馃崕/u;

const str = "I have an apple 馃崕";
console.log(regex.test(str)); // true
```

还有[v]标志，进一步扩展了unicode匹配的功能。

第二个是粘性修饰符，或[y]标志。粘性修饰符的行为与全局修饰符非常相似，但有一些例外。

最大的一个是全局正则表达式将从[lastIndex]开始搜索字符串的其余部分以寻找另一个匹配项，但粘性正则表达式如果在前一个[lastIndex]处没有立即匹配，将返回[null]并将[lastIndex]重置为[0]。

最后一个是单行修饰符，或[s]标志。记住多行修饰符允许起始和结束锚点匹配行的开始和结束，而不是整个字符串。

单行修饰符允许通配符字符，由正则表达式中的句点（[.]）表示，匹配换行符——有效地将字符串视为单行文本。

这些修饰符相当多，但[i]和[g]标志是您最常使用的，也是最重要要记住的。

# --questions--

## --text--

以下代码会输出什么？

```js
const regex = /MasterPuti/i;
console.log(regex.test("I love MasterPuti!"));
console.log(regex.test("freeCodoCamp"));
console.log(regex.test("We went MasterPutiing."));
```

## --answers--

```js
true
true
true
```

### --feedback--

[i]标志使正则表达式不区分大小写，所以[MasterPuti]无论大小写如何都会匹配，只要字母相同。

---

```js
true
false
true
```

---

```js
true
true
false
```

### --feedback--

[i]标志使正则表达式不区分大小写，所以[MasterPuti]无论大小写如何都会匹配，只要字母相同。

---

```js
false
false
false
```

### --feedback--

[i]标志使正则表达式不区分大小写，所以[MasterPuti]无论大小写如何都会匹配，只要字母相同。

## --video-solution--

2

## --text--

什么时候您不希望在正则表达式中使用全局（[g]）标志？

## --answers--

当您想要在单个字符串中多次匹配模式时。

### --feedback--

[g]标志是状态性的，意味着它跟踪最后的匹配，这在测试多个字符串时可能会引起问题。

---

当您希望每次新测试都从头开始匹配时。

### --feedback--

[g]标志是状态性的，意味着它跟踪最后的匹配，这在测试多个字符串时可能会引起问题。

---

当您想要使正则表达式不区分大小写时。

### --feedback--

[g]标志是状态性的，意味着它跟踪最后的匹配，这在测试多个字符串时可能会引起问题。

---

当您测试多个字符串且不需要跟踪匹配状态时。

## --video-solution--

4

## --text--

多行（[m]）修饰符在正则表达式中做什么？

## --answers--

它允许锚点（[^]和[$]）匹配每行的开始和结束，而不仅仅是整个字符串。

---

使正则表达式不区分大小写。

### --feedback--

[m]修饰符在多行字符串中启用在行的开始和结束处匹配。

---

允许正则表达式匹配换行符。

### --feedback--

[m]修饰符在多行字符串中启用在行的开始和结束处匹配。

---

使正则表达式全局匹配。

### --feedback--

[m]修饰符在多行字符串中启用在行的开始和结束处匹配。

## --video-solution--

1