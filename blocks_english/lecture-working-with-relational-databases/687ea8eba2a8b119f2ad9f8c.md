---
id: 687ea8eba2a8b119f2ad9f8c
title: 有哪些不同的表连接方式？
challengeType: 19
dashedName: what-are-the-different-ways-to-join-tables
---

# --description--

尽管关系数据库将数据组织成单独的表格，但SQL的`JOIN`操作允许您从表格中组合相关信息来查询数据。

有五种主要的`JOIN`操作类型：

- `INNER JOIN`
- `FULL OUTER JOIN`
- `LEFT OUTER JOIN`
- `RIGHT OUTER JOIN`
- `SELF JOIN`
- 以及`CROSS JOIN`

让我们从`INNER JOIN`开始。

`INNER JOIN`过滤结果，只包含您指定的连接列在两个表格中相等的行。基本上，它给您数据的交集。

为了说明这一点，假设我们有两个表格。

第一个是这个包含多个产品的`products`表格。它包括它们的ID、名称、类别、价格和产地。

```sql
| product_id | product_name     | category    | price (USD) | origin        |
| ---------- | ---------------- | ----------- | ----------- | ------------- |
| 1          | Ice Cream        | Food        | 2.50        | India         |
| 2          | Pizza Margherita | Food        | 12.00       | Italy         |
| 3          | Sushi            | Food        | 18.75       | Japan         |
| 4          | T-Shirt          | Clothing    | 25.00       | USA           |
| 5          | Jeans            | Clothing    | 60.00       | Argentina     |
| 6          | Coffee           | Beverages   | 35.00       | France        |
| 7          | Juice            | Beverages   | 5.00        | Colombia      |
```

第二，我们有一个`sales`表格，包含销售ID、产品ID、数量和销售日期。

```sql
| sale_id | product_id | quantity | sale_date  |
| ------- | ---------- | -------- | ---------- |
| 101     | 1          | 2        | 2025-07-18 |
| 102     | 2          | 3        | 2025-02-13 |
| 103     | 6          | 10       | 2025-06-08 |
| 104     | 5          | 8        | 2025-01-10 |
| 105     | 2          | 1        | 2025-05-15 |
```

我们可以基于`product_id`执行`INNER JOIN`，如下所示：

```sql
SELECT *
FROM products
INNER JOIN sales
  ON products.product_id = sales.product_id;
```

这只会获取两个表格中`product_id`相同的行。因此，如果一个产品不在销售表格或产品表格中，它将不被包含。

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
     1     | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
     2     | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
     5     | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
     6     | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
```

我们只看到已售出的产品行。例如，`'Pizza Margherita'`在`sales`表格中，`product_id`为`2`，所以我们得到结果中的该产品。

然而，`product_id`为`4`的`'T-Shirts'`没有售出，所以该产品不在`sales`表格中。它们不在两个表格中，所以不包含在结果中。

连接表格的作用正如其名。它将两个或多个表格连接成一个，这就是为什么我们看到两个表格的所有列，包括两次出现的`product_id`。

`FULL OUTER JOIN`返回两个表格的所有行。

如果在指定的列中找到匹配项，数据将被组合，您将获得每个匹配记录的所有列。

如果在任一表格的指定列中没有匹配项，则缺失的列将用`NULL`值填充。

让我们在示例中基于`product_id`列执行`FULL OUTER JOIN`。此列将确定是否存在匹配。

```sql
SELECT *
FROM products
FULL OUTER JOIN sales
  ON products.product_id = sales.product_id;
```

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

注意`'Pizza Margherita'`如何拥有所有数据，包括来自`sales`表格的列，因为找到了匹配。

但`'T-Shirt'`有空的（`NULL`）列，因为在`sales`表格中找不到匹配（该产品未售出）。

`LEFT OUTER JOIN`用于获取左表的所有记录以及右表中与左表每行匹配的信息。

如果找不到匹配项，则右表的列用`NULL`值填充。

让我们在示例中执行`LEFT OUTER JOIN`。

```sql
SELECT *
FROM products
LEFT JOIN sales
  ON products.product_id = sales.product_id;
```

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         3 | Sushi            | Food      | 18.75 | Japan     |         |            |          |
         4 | T-Shirt          | Clothing  | 25.00 | USA       |         |            |          |
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         7 | Juice            | Beverages |  5.00 | Colombia  |         |            |          |
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

在这种情况下，它与`FULL OUTER JOIN`相同，因为它包括第一个表格`products`的所有行。

`RIGHT OUTER JOIN`非常相似，但现在我们获取右表的所有记录以及左表中与右表每行匹配的信息。

如果没有匹配项，则左表的列用`NULL`值填充。

让我们在示例中执行`RIGHT OUTER JOIN`。

```sql
SELECT *
FROM products
RIGHT JOIN sales
  ON products.product_id = sales.product_id;
```

这是结果：

```sql
product_id | product_name     | category  | price | origin    | sale_id | product_id | quantity | sale_date
---------- | ---------------- | --------- |-------|-----------|---------|------------|----------|------------
         1 | Ice Cream        | Food      |  2.50 | India     |     101 |          1 |        2 | 2025-07-18
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     102 |          2 |        3 | 2025-02-13
         6 | Coffee           | Beverages | 35.00 | France    |     103 |          6 |       10 | 2025-06-08
         5 | Jeans            | Clothing  | 60.00 | Argentina |     104 |          5 |        8 | 2025-01-10
         2 | Pizza Margherita | Food      | 12.00 | Italy     |     105 |          2 |        1 | 2025-05-15
```

您会注意到它有更少的行。这是因为它获取右表（在这种情况下是`sales`）的所有记录，而此表格的行数比`products`表格少。

如果在`products`表格中找到匹配项，它会用数据填充这些列。但如果找不到匹配项，则列用`NULL`填充。

在这种情况下，每个已售出的产品在`products`表格中都有记录，所以数据是完整的。

这些是最常用的`JOIN`操作，但还有另外两种您应该了解的操作。

`SELF JOIN`允许您将表格与自身连接。您可以将其视为将同一表格的两个副本连接起来。这对于比较同一表格内的不同行非常有帮助。

`CROSS JOIN`，也称为笛卡尔连接，将第一个表格的每一行与第二个表格的每一行连接。因此，它生成所有可能的行组合。此操作不需要任何条件来连接表格。

这些`JOIN`操作对于使用SQL是基础性的。通过选择正确的操作，您可以尽可能高效地查询所需的数据。

# --questions--

## --text--

哪种SQL `JOIN`操作只返回基于连接条件在两个表格中都有匹配的行？

## --answers--

`LEFT JOIN`

### --feedback--

想想哪种连接类型在只包括匹配两个表格的记录方面是最严格的。

---

`INNER JOIN`

---

`RIGHT JOIN`

### --feedback--

想想哪种连接类型在只包括匹配两个表格的记录方面是最严格的。

---

`FULL JOIN`

### --feedback--

想想哪种连接类型在只包括匹配两个表格的记录方面是最严格的。

## --video-solution--

2

## --text--

如果您需要检索所有客户（左）以及每个客户可能下的任何订单（右），您会使用哪种SQL `JOIN`操作？没有订单的客户也应该包含在结果中。

## --answers--

`LEFT JOIN`

---

`INNER JOIN`

### --feedback--

想想哪种连接确保customers表格中的所有记录都包含在输出中。

---

`RIGHT JOIN`

### --feedback--

想想哪种连接确保customers表格中的所有记录都包含在输出中。

---

`FULL JOIN`

### --feedback--

想想哪种连接确保customers表格中的所有记录都包含在输出中。

## --video-solution--

1

## --text--

哪种SQL `JOIN`操作返回两个表格的所有行，包括不匹配的行（对于没有匹配的表格列用`NULL`填充）？

## --answers--

`LEFT JOIN`

### --feedback--

这种连接旨在最包容，获取两个表格的所有记录。

---

`INNER JOIN`

### --feedback--

这种连接旨在最包容，获取两个表格的所有记录。

---

`RIGHT JOIN`

### --feedback--

这种连接旨在最包容，获取两个表格的所有记录。

---

`FULL JOIN`

## --video-solution--

4