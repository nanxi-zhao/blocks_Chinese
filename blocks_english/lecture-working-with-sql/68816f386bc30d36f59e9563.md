---
id: 68816f386bc30d36f59e9563
title: SQL中的规范化是什么？
challengeType: 19
dashedName: what-is-normalization-in-sql
---

# --description--

规范化是使用既定的范式组织关系数据库的过程，以减少数据冗余并提高数据完整性。

要规范化数据库，您需要分析表结构中的属性和关系，以识别基于规范化规则的简化机会。然后，您将数据划分为更小、更集中的表，并使用主键和外键在它们之间建立关系。这些较小的表将存储您原来拥有的所有数据，但与较大的表相比，它们更容易管理、组织和使用。

通过最小化数据冗余，规范化减少了存储空间并防止了不一致性。例如，如果客户地址发生变化，您只需要在一个客户表中更新它，而不是在每个订单记录中更新。

它还有助于通过确保主键和外键约束强制执行依赖关系来保护数据完整性。这减少了插入、更新和删除异常的可能性。

规范化的数据库更容易理解和维护，这有助于设计良好的数据库系统。

您应该遵循的一组规则称为范式。每个范式都建立在前一个范式的基础上，随着您转向更高的范式，规则变得更加严格。第一范式（1NF）是基础范式，具有最基本的规则。

如果表满足以下条件，则它处于第一范式（1NF）：

- 每个单元格应仅包含一个值。例如，如果您有一个[students]表，可能有一个学生有多个电话号码。不应将它们作为逗号分隔的列表存储在一个单元格中，而应创建一个单独的[phone_numbers]表，其中包含指向[students]表的外键，并且每个单元格中只存储一个值。这使每个值都保持原子性，设计保持规范化。
- 每条记录（行）必须是唯一的。虽然主键强制执行此要求，但1NF明确要求表中不存在重复行。
- 行和列的顺序不应相关。数据不应依赖于其物理位置。

本质上，第一范式（1NF）专注于使值简单和原子化。

第二范式（2NF）建立在1NF的基础上，要求满足所有1NF要求加上额外的约束。

理解2NF需要熟悉两个关键概念：超键和候选键。超键是唯一标识表中每行的任何属性集，这意味着没有两行可以在超键中的所有列上具有相同的值。

例如，如果我们有一个具有三列的[customers]表：

```sql
customer_id | name | email
```

假设[customer_id]和[email]对于每条记录都必须是唯一的。此表的一些超键示例将是：

- [customer_id]
- [{ customer_id, name }]，此组合唯一标识行，因为[customer_id]本身是唯一的，无论[name]是否唯一。
- [{ customer_id, name, email }]
- [email]，由于我们也在该列上添加了唯一约束，因此每条记录可以通过电子邮件唯一标识。

任何可以一起唯一标识每行的属性集都可以是超键。

候选键类似但又有所不同。它是表上一个或多个列的集合，可以唯一标识每条记录。一个表可以有多个候选键，但您需要选择一个作为主键。

它们听起来很相似，对吗？它们的区别在于超键还可以包含识别每行唯一性所不需要的额外属性，而候选键只包含识别行唯一性的属性。

在我们的[customers]示例中，我们提到[customer_id]、[{ customer_id, name }]、[{ customer_id, name, email }]和[email]可以是超键。在这种情况下，只有[customer_id]和[email]可以是候选键，因为候选键不能包含不识别行唯一性的属性，如[name]。这说明了区分候选键和超键的最小性原则。

现在您熟悉了这些概念，让我们回到第二范式（2NF）。

第二范式（2NF）基于解决部分依赖。当不属于主键的属性仅依赖于复合主键的一部分时（复合键是由多个列组成的主键），表中会发生部分依赖。这可能导致数据冗余和更新异常。

例如，假设我们有一个具有以下列的[orders]表：

```sql
order_id | item_id | order_date | product | quantity | order_shipping_city
```

在此表中，主键是[order_id]和[item_id]的组合，因为相同的项目ID可以出现在不同的订单中，但它们的组合将是唯一的。您可以看到[order_id]和[order_shipping_city]之间存在部分依赖。[order_id]是主键的一部分。[order_shipping_city]依赖于[order_id]，因为具有相同ID的每个订单将具有相同的配送城市。然而，配送城市不依赖于[item_id]，但这也是主键的一部分。因此，[order_shipping_city]不依赖于整个主键。

为了解决这个问题，您可以将表拆分为两个较小的表，如[order_header]和[order_items]。在[order_header]表中，您可以存储订单的顶层信息：

```sql
order_id | order_date | order_shipping_city
```

在[order_items]表中，您可以存储提交的不同订单中的项目信息：

```sql
order_id | item_id | product | quantity
```

通过这些更改，两个表都将处于第二范式（2NF）。

这让我们进入第三范式（3NF）。此范式建立在第二范式的基础上。

表处于第三范式必须满足：

- 处于第二范式。
- 所有非键属性直接依赖于主键，这意味着非键属性不应依赖于另一个非键属性。

要理解第三范式（3NF），您需要理解传递依赖。当不属于主键的属性依赖于另一个不属于主键的属性，而后者又依赖于主键时，会发生传递依赖。

例如，让我们修改我们的[orders]表以具有以下列：

```sql
order_id | customer_id | customer_city | city_postal_code | order_date | product | quantity
```

在此新表中，主键是[order_id]，因为它唯一标识每行。

此表中存在传递依赖：

```sql
order_id > customer_id > customer_city > city_postal_code
```

城市邮政编码由客户城市确定，客户城市由客户ID确定，客户ID由订单ID确定。[city_postal_code]是一个不属于主键的属性，由[customer_city]确定，[customer_city]也不属于主键，但[customer_city]通过[customer_id]由[order_id]确定。这意味着对于居住在同一城市的客户下的每个订单，城市邮政编码将重复。这将导致数据冗余。此外，任何城市邮政编码的更改都需要在多个记录中进行更新。

为了解决传递依赖，您需要将表拆分为多个表。首先，一个[orders]表：

```sql
order_id | customer_id | order_date | product | quantity
```

然后，一个[customers]表：

```sql
customer_id | city_name
```

以及一个[cities]表：

```sql
city_name | city_postal_code
```

这从表中移除了传递依赖。

最后，我们有博伊斯-科德范式（BCNF）。这也称为3.5范式，因为它解决了第三范式可能无法解决的一些异常。表处于博伊斯-科德范式（BCNF）必须满足：

- 处于第三范式。
- 每个函数依赖的左侧必须是超键。

此范式的目标是确保确定另一个属性的每个属性或属性集都是超键，即候选键或它们的超集。

理解和应用范式对于设计健壮高效的关系数据库至关重要。通过消除数据冗余并确保逻辑数据依赖性，规范化可以提高数据完整性，减少存储需求，并简化数据库维护。您通常应该力求达到第三范式（3NF）。

# --questions--

## --text--

哪个范式主要关注用单个值替换单行内的数据组？

## --answers--

第一范式（1NF）

---

第二范式（2NF）

### --feedback--

考虑表内组织的最基本级别以及什么构成单个、不可分割的数据片段。

---

第三范式（3NF）

### --feedback--

考虑表内组织的最基本级别以及什么构成单个、不可分割的数据片段。

---

博伊斯-科德范式（BCNF）

### --feedback--

考虑表内组织的最基本级别以及什么构成单个、不可分割的数据片段。

## --video-solution--

1

## --text--

表处于第二范式（2NF）的条件是它处于第一范式（1NF）并且以下哪项为真？

## --answers--

所有非键属性都传递依赖于主键。

### --feedback--

考虑当表具有复合主键时第二范式（2NF）解决的问题。

---

所有非键属性都完全函数依赖于整个主键。

---

每个决定因素都是候选键。

### --feedback--

考虑当表具有复合主键时第二范式（2NF）解决的问题。

---

没有重复的数据组。

### --feedback--

考虑当表具有复合主键时第二范式（2NF）解决的问题。

## --video-solution--

2

## --text--

哪个范式解决了传递依赖，即非键属性依赖于另一个非键属性？

## --answers--

第一范式（1NF）

### --feedback--

考虑非键属性与主键之间的间接关系，此范式旨在消除这种关系。

---

第二范式（2NF）

### --feedback--

考虑非键属性与主键之间的间接关系，此范式旨在消除这种关系。

---

第三范式（3NF）

---

博伊斯-科德范式（BCNF）

### --feedback--

考虑非键属性与主键之间的间接关系，此范式旨在消除这种关系。

## --video-solution--

3