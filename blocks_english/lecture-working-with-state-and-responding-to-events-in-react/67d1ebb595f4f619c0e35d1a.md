---
id: 67d1ebb595f4f619c0e35d1a
title: 如何更新状态中的对象？
challengeType: 19
dashedName: how-do-you-update-objects-in-state
---

# --description--

如果您习惯于直接更改对象属性值，在React状态中更新对象可能会很棘手。

React将状态视为不可变的，这意味着您不应该直接修改它。

让我们看看如果您尝试直接更改React状态中的对象会发生什么，然后深入了解正确的做法。

假设您的组件状态中有一个表示用户资料的对象，您希望用户更新他们的年龄：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({
    name: "John Doe",
    age: 31,
    city: "LA",
  });

  // 直接更改用户年龄
  const handleAgeChange = (e) => {
    user.age = e.target.value;
    console.log(user);
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" value={user.age} onChange={handleAgeChange} />
    </div>
  );
}

export default Profile;
```

这段代码不会起作用，因为您直接修改了`user.age`属性。

尽管`console.log(user)`会在控制台中显示新年龄，但React不会重新渲染组件以在用户界面中显示它，因为您没有使用设置函数`setUser`。

要直接更新状态中的对象，您需要使用设置函数创建一个具有更新值的新对象。例如：

```js
const handleAgeChange = (e) => {
  setUser({
    age: e.target.value,
  });
};
```

这样可以工作。但如果您现在查看页面，用户的年龄得到了更新，但姓名和城市值丢失了。

这是因为您传递给设置函数的新对象只包含`age`的键值对。

为了防止这种情况发生，您可以首先复制现有对象，然后只更新您想要更新的属性，在这种情况下是`age`。

为此，您可以将一个称为更新函数的特殊函数传递给您的设置函数`setUser`。更新函数将待处理状态作为参数，这里称为`prevUser`，并应返回下一个状态：

```js
const handleAgeChange = (e) => {
  setUser((prevUser) => {
    const updatedUser = { ...prevUser, age: e.target.value };
    console.log('Previous State:', prevUser);
    console.log('Updated State:', updatedUser);
    return updatedUser;
  });
};
```

正如您所见，我们使用展开语法复制待处理的用户对象`...prevUser`创建了一个名为`updatedUser`的新用户对象。然后我们根据表单输入更新年龄，并在函数底部返回`updatedUser`作为下一个状态。

现在您的项目按预期工作，对年龄输入的更新不会影响用户的姓名或城市名称。您还可以在控制台中看到之前和更新后的状态。

这是更新状态中对象的理想方式，特别是当您不更新所有属性时。

要更新剩余的`name`和`city`属性，您可以将它们写成单独的设置函数并连接到各自的输入：

```js
const handleNameChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    name: e.target.value,
  }));
};

const handleCityChange = (e) => {
  setUser((prevUser) => ({
    ...prevUser,
    city: e.target.value,
  }));
};
```

或者您可以将它们组合成一个单独的设置函数，如下所示：

```js
const handleChange = (e) => {
  const { name, value } = e.target;
  setUser((prevUser) => ({
    ...prevUser,
    [name]: value,
  }));
};
```

要使此功能正常工作，每个输入字段都必须具有`name`属性。

以下是完整的代码：

```jsx
import { useState } from "react";

function Profile() {
  const [user, setUser] = useState({ name: "John Doe", age: 31, city: "LA" });

  const handleChange = (e) => {
    const { name, value } = e.target;

    setUser((prevUser) => ({...prevUser, [name]: value}));
  };

  return (
    <div>
      <h1>User Profile</h1>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>City: {user.city}</p>

      <h2>Update User Age </h2>
      <input type="number" name="age" value={user.age} onChange={handleChange} />

      <h2>Update User Name </h2>
      <input type="text" name="name" value={user.name} onChange={handleChange} />

      <h2>Update User City </h2>
      <input type="text" name="city" value={user.city} onChange={handleChange} />
    </div>
  );
}

export default Profile;
```

# --questions--

## --text--

React如何对待组件中的状态？

## --answers--

作为可变的，允许直接修改。

### --feedback--

想想React确保可预测状态变化的方法。

---

作为不可变的，意味着不应直接修改。

---

作为在所有组件中可访问的全局变量。

### --feedback--

想想React确保可预测状态变化的方法。

---

作为在每次渲染时重置的临时变量。

### --feedback--

想想React确保可预测状态变化的方法。

## --video-solution--

2

## --text--

您应该如何更新存储在React状态中的对象？

## --answers--

使用设置函数创建一个新对象。

---

直接修改状态中的对象。

### --feedback--

React将状态视为不可变的，因此避免直接修改。

---

使用`Object.assign()`而不调用设置器。

### --feedback--

React将状态视为不可变的，因此避免直接修改。

---

使用`push()`方法向对象添加属性。

### --feedback--

React将状态视为不可变的，因此避免直接修改。

## --video-solution--

1

## --text--

这段代码中的设置函数是什么？

```js
const [user, setUser] = useState({
   name: 'John Doe',
   age: 31,
   city: 'LA',
 });
```

## --answers--

`user`

### --feedback--

设置函数更新`state`变量。

---

`useState`

### --feedback--

设置函数更新`state`变量。

---

`age`

### --feedback--

设置函数更新`state`变量。

---

`setUser`

## --video-solution--

4