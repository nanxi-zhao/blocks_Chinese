---
id: 6724e46581a1742244e45b59
title: Bash和SQL复习
challengeType: 31
dashedName: review-bash-and-sql
---

# --description--

## 数据库规范化

这是组织关系型数据库以减少数据冗余并提高完整性的过程。

其好处包括：

- 最小化重复数据，从而节省存储空间并减少不一致性。
- 通过使用主键和外键来强制执行数据完整性。
- 使数据库更易于维护和理解。

### 规范化形式

- **1NF（第一范式）**
  - 每个单元格包含单个（原子）值。
  - 每条记录都是唯一的（由主键强制执行）。
  - 行/列的顺序无关紧要。
  - 示例：将多个电话号码从[students](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L27-L27)表移到单独的[student_phones](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L27-L27)表中。

- **2NF（第二范式）**
  - 满足1NF要求。
  - 没有**部分依赖**：每个非键属性必须依赖于整个复合主键。
  - 示例：将[orders](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L30-L30)表拆分为[order_header](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L30-L30)和[order_items](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L30-L30)，以避免属性仅依赖于键的一部分。

- **3NF（第三范式）**
  - 满足2NF要求。
  - 没有**传递依赖**：非键属性不能依赖于其他非键属性。
  - 示例：将[city_postal_code](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L33-L33)移到[cities](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L33-L33)表中，而不是与每个订单一起存储。

- **BCNF（博伊斯-科德范式）**
  - 满足3NF要求。
  - 每个决定因素（函数依赖的左侧）必须是超键。

**提示**：在大多数设计中目标是3NF，以在完整性和性能之间取得良好平衡。

## 关键SQL概念

- SQL是一种用于与关系型数据库通信的结构化查询语言。
- **基本命令** → [SELECT](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47), [INSERT](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47), [UPDATE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47), [DELETE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47), [CREATE TABLE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47), [ALTER TABLE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L47-L47)等。
- [Joins](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11) → 组合来自多个表的数据（[INNER JOIN](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11), [LEFT JOIN](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11), [RIGHT JOIN](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11), [FULL JOIN](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)）。

## 在Bash中运行SQL命令

你可以使用PostgreSQL的[psql](file:///D:/Program%20Files/PostgreSQL/16/bin/psql.exe)命令行客户端或其他数据库的类似工具直接从命令行运行SQL命令。

例如，在PostgreSQL中运行SQL文件：

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

你也可以直接执行MySQL命令：

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### 从文件运行SQL

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### 在Bash脚本中嵌入SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 插入学生数据
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### 在SQL中使用变量

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**提示**：清理变量以避免SQL注入。

## 在Bash中检索和使用SQL查询结果

当你通过[psql](file:///D:/Program%20Files/PostgreSQL/16/bin/psql.exe)运行SQL查询时，你可以在Bash脚本中**捕获**和**处理**返回的值。

### 捕获单个值

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取学生总数
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

输出 → 42

### 检索多列

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取前三名学生的姓名和年龄
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

输出

```bash
Alice,20
Bob,21
Charlie,22
```

### 遍历查询结果

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取学生姓名和专业
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

输出形状

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## SQL注入

这是一种Web安全漏洞，攻击者在输入字段中插入恶意SQL代码来操纵数据库。

这可能导致危险的操作，例如：

- 绕过身份验证。
- 窃取敏感数据。
- 修改或删除记录。

SQL注入攻击的一个示例：

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

此查询将返回所有用户，因为条件[OR "1"="1"](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/blocks_english/quiz-sql-and-postgresql/6724e337ee098d1ef33108b6.md?plain=1#L182-L182)始终为真，允许攻击者绕过登录检查。

### 防止SQL注入

1. **使用预编译语句**：这些语句将SQL代码与数据分离，防止注入。以下是一个示例（Node.js与pg）：

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **输入验证**：清理和验证所有用户输入，确保它们符合预期格式。

3. **最小权限**：使用具有应用程序所需的最低权限的数据库账户。

**注意**：永远不要授予应用程序账户管理员权限。

## N+1问题

当应用程序发出一个查询来检索项目列表（N），然后为每个项目发出一个额外的查询来检索相关数据时，就会出现N+1问题，从而导致N+1个查询。

**为什么它很糟糕**

- 每个查询都会增加网络和处理开销。
- 多个小查询比一个优化的查询慢。

### N+1模式示例

```sql
-- 1: 获取订单列表
SELECT * FROM orders LIMIT 50;

-- N: 对于每个订单，获取客户
SELECT * FROM customers WHERE customer_id = ...;
```

**解决方案**：使用[JOINs](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)或其他基于集合的操作。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

始终寻找机会将相关数据合并到单个查询中。

# --assignment--

复习Bash和SQL的主题和概念。