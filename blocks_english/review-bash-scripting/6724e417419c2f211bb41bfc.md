---
id: 6724e417419c2f211bb41bfc
title: Bash脚本复习
challengeType: 31
dashedName: review-bash-scripting
---

# --description--

## Bash脚本基础

- **Bash脚本**：将一系列Bash命令写入文件中，然后可以用Bash执行该文件来运行其中的内容。
- **Shebang**：脚本开头的注释行（例如 `#!/bin/bash`），用于指示应该使用哪个解释器来运行脚本。

  ```bash
  #!/bin/bash
  ```

- **变量赋值**：使用语法 `variable_name=value` 来实例化变量。

  ```bash
  servers=("prod" "dev")
  ```

- **变量创建规则**：使用 `VARIABLE_NAME=VALUE` 语法创建变量。等号（`=`）周围不允许有空格。如果值包含空格，请使用双引号。

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **变量使用**：通过在变量名前放置 `$` 来访问变量值。

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **变量插值**：使用 `$variable_name` 在字符串和命令中访问变量的值。

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER

  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **变量作用域**：Shell脚本从上到下运行，因此变量只能在其创建位置下方使用。

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **用户输入**：使用 [read](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/globals.d.ts#L30-L30) 接受用户的输入并将其存储在变量中。

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **注释**：使用 `#` 后跟你的注释文本来为脚本添加注释。
  - 单行注释以 `#` 开头并持续到行尾
  - 注释被shell忽略，不会影响脚本执行

  ```bash
  # 这是一个单行注释
  NAME="John"  # 行末的注释
  ```

- **多行注释**：使用冒号和引号来注释掉代码块。

  ```bash
  : '
  这是一个多行注释
  引号之间的所有内容都会被忽略
  对于调试或文档很有用
  '
  ```

- **内置命令和帮助**：
  - 使用 [help](file:///D:/Program%20Files/Git/usr/bin/help.exe) 查看内置bash命令列表
  - 使用 `help <command>` 获取有关特定内置命令的信息
  - 有些命令（如 `if`）是内置的，没有手册页
  - 内置命令由shell直接执行，而不是作为外部程序执行
  - 使用 `help function` 查看关于创建函数的信息

  ```bash
  help
  help if
  help function
  ```

- **查找命令位置**：使用 [which](file:///D:/Program%20Files/Git/usr/bin/which.exe) 定位可执行文件的安装位置。
  - 显示可执行文件的完整路径
  - 对于查找解释器位置（如bash）很有用
  - 帮助验证将执行哪个版本的命令

  ```bash
  which bash
  which python
  which ls
  ```

- **手册页**：使用 [man](file:///D:/Program%20Files/Git/usr/bin/man.exe) 访问命令的详细文档。
  - 提供有关命令使用的综合信息
  - 显示所有可用选项和示例
  - 使用箭头键导航，'q' 退出
  - 并非所有命令都有手册页（内置命令使用 [help](file:///D:/Program%20Files/Git/usr/bin/help.exe)）

  ```bash
  man echo
  man ls
  man bash
  ```

- **帮助标志**：许多命令支持 `--help` 以获取快速帮助信息。
  - 手册页的替代方案，用于快速参考
  - 显示命令语法和常用选项
  - 并非所有命令都支持此标志（有些可能会显示错误）

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Echo命令选项**：[echo](file:///D:/Program%20Files/Git/usr/bin/echo.exe) 命令支持各种选项：
  - `-e` 选项启用反斜杠转义的解释
  - `\n` 创建新行
  - 只有当值用引号括起来时才会打印空行
  - 对于创建格式化输出和程序标题很有用

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **脚本参数**：程序可以接受可通过 `$` 变量访问的参数。
  - `$*` 打印传递给脚本的所有参数
  - `$@` 将传递给脚本的所有参数打印为单独的带引号字符串
  - `$<number>` 按位置访问特定参数（例如 `$1`, `$2`, `$3`）

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## 双括号表达式 `[[ ]]`

- **双括号语法**：使用 `[[ ]]` 进行条件测试和模式匹配。
  - 括号内和运算符周围必须有空格
  - 根据测试结果返回退出状态0（真）或1（假）

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **字符串比较运算符**：在 `[[ ]]` 中使用各种运算符比较字符串。
  - `==`（等于）：测试两个字符串是否相同
  - `!=`（不等于）：测试两个字符串是否不同
  - `<`（字典序小于）：按字母顺序进行字符串比较
  - `>`（字典序大于）：按字母顺序进行字符串比较

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **数值比较运算符**：使用特定的数值运算符比较数字。
  - `-eq`（等于）：数值相等比较
  - `-ne`（不等于）：数值不等比较
  - `-lt`（小于）：数值小于比较
  - `-le`（小于或等于）：数值小于或等于比较
  - `-gt`（大于）：数值大于比较
  - `-ge`（大于或等于）：数值大于或等于比较

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **逻辑运算符**：使用逻辑运算符组合多个条件。
  - `&&`（与）：两个条件都必须为真
  - `||`（或）：至少有一个条件必须为真
  - `!`（非）：否定条件（使真变假，假变真）

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **文件测试运算符**：测试文件属性和存在性。
  - `-e file`：如果文件存在则为真
  - `-f file`：如果文件存在且是普通文件则为真
  - `-d file`：如果文件存在且是目录则为真
  - `-r file`：如果文件存在且可读则为真
  - `-w file`：如果文件存在且可写则为真
  - `-x file`：如果文件存在且可执行则为真
  - `-s file`：如果文件存在且大小大于零则为真

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **使用 `=~` 进行模式匹配**：使用正则表达式进行高级模式匹配。
  - `=~` 运算符启用正则表达式模式匹配
  - 使用正则元字符时不应引用模式
  - 支持完整的正则表达式语法
  - 默认情况下区分大小写

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **变量存在性测试**：检查变量是否已设置或为空。
  - 测试变量是否为空：`[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## 双括号表达式 `(( ))`

- **算术求值**：使用 `(( ))` 进行数学计算和数值比较。
  - 使用C风格语法评估算术表达式
  - 双括号内的变量不需要 `$` 前缀
  - 如果结果非零则返回退出状态0，如果结果为零则返回1
  - 支持所有标准算术运算符

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **算术运算符**：`(( ))` 中可用的数学运算符。
  - `+`（加法）：将两个数字相加
  - `-`（减法）：第二个数字从第一个数字中减去
  - `*`（乘法）：将两个数字相乘
  - `/`（除法）：第一个数字除以第二个数字（整数除法）
  - `%`（模数）：除法后的余数
  - `**`（指数）：将第一个数字提升到第二个数字的幂

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **赋值运算符**：使用算术赋值运算符修改变量。
  - `=`（赋值）：将值赋给变量
  - `+=`（加法赋值）：将值加到变量上
  - `-=`（减法赋值）：从变量中减去值
  - `*=`（乘法赋值）：将变量乘以值
  - `/=`（除法赋值）：将变量除以值
  - `%=`（模数赋值）：将变量设置为余数

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **递增和递减运算符**：将变量修改一。
  - `++variable`（预递增）：在使用前递增
  - `variable++`（后递增）：在使用后递增
  - `--variable`（预递减）：在使用前递减
  - `variable--`（后递减）：在使用后递减

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **比较运算符**：使用算术比较比较数字。
  - `==`（等于）：数字相等
  - `!=`（不等于）：数字不相等
  - `<`（小于）：第一个数字小于第二个数字
  - `<=`（小于或等于）：第一个数字小于或等于第二个数字
  - `>`（大于）：第一个数字大于第二个数字
  - `>=`（大于或等于）：第一个数字大于或等于第二个数字

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **逻辑运算符**：组合算术条件。
  - `&&`（与）：两个条件都必须为真
  - `||`（或）：至少有一个条件必须为真
  - `!`（非）：否定条件

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **按位运算符**：对整数执行位级操作。
  - `&`（按位与）：对每一位进行与操作
  - `|`（按位或）：对每一位进行或操作
  - `^`（按位异或）：对每一位进行异或操作
  - `~`（按位非）：反转所有位
  - `<<`（左移）：将位向左移动
  - `>>`（右移）：将位向右移动

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **条件（三元）运算符**：使用 `condition ? true_value : false_value` 语法。
  - 提供了一种基于条件分配值的简洁方式
  - 类似于C风格语言中的三元运算符
  - 评估条件并返回两个值中的一个

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **带有算术的命令替换**：使用 `$(( ))` 捕获算术结果。
  - 将算术表达式的结果作为字符串返回
  - 可用于赋值或命令参数
  - 对于需要在其他地方使用的计算很有用

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## 控制流和条件语句

- **条件语句**：使用 `if` 语句根据条件执行代码。
  - 基本语法：`if [[ CONDITION ]] then STATEMENTS fi`
  - 完整语法：`if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - 可以使用 `[[ ]]` 和 `(( ))` 表达式进行不同类型条件的判断
  - **elif（else if）**：可选，可以重复多次以按顺序测试其他条件
  - **else**：可选，当所有先前条件都为假时执行
  - 可以在同一条件链中混合使用双括号 `(( ... ))` 和双方括号 `[[ ... ]]`

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## 命令执行和进程控制

- **命令分隔**：使用分号（`;`）在一行上运行多个命令。
  - 命令从左到右依次执行
  - 可以单独检查每个命令的退出状态

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **退出状态**：每个命令都有一个表示成功或失败的退出状态。
  - 使用 `$?` 访问最后一个命令的退出状态
  - 退出状态 `0` 表示成功（真/无错误）
  - 任何非零退出状态表示失败（假/发生错误）
  - 常见错误代码：`127`（找不到命令），`1`（一般错误）

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **子shell和命令替换**：用于执行上下文的不同括号用法。
  - 单括号 `( ... )` 创建子shell
  - `$( ... )` 执行命令替换
  - 子shell在独立环境中运行，不影响父shell变量

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Sleep命令**：暂停脚本执行指定的秒数。
  - 对于在脚本中创建延迟很有用
  - 可以与小数值一起使用以实现亚秒延迟

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## 循环

- **While循环**：在条件为真时重复执行代码。
  - 语法：`while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Until循环**：在条件变为真之前重复执行代码。
  - 语法：`until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **For循环**：使用 [for](file:///D:/Program%20Files/Git/usr/bin/for.exe) 循环迭代数组或列表，使用 [do](file:///D:/Program%20Files/Git/usr/bin/do.exe) 和 [done](file:///D:/Program%20Files/Git/usr/bin/done.exe) 定义循环的逻辑块。

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## 数组

- **数组**：在单个变量中存储多个值。
  - 使用括号创建数组：`ARRAY=("value1" "value2" "value3")`
  - 按索引访问元素：`${ARRAY[0]}`, `${ARRAY[1]}`
  - 访问所有元素：`${ARRAY[@]}` 或 `${ARRAY[*]}`
  - 数组索引从0开始

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")
  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # Index 5 doesn't exist; empty string              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **使用declare检查数组**：使用 `declare -p` 查看数组详细信息。
  - 使用 `-a` 标志显示数组类型
  - 显示所有数组元素及其结构

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **数组扩展**：使用 `"${array_name[@]}"` 语法将数组扩展为各个元素。

```bash
for server in "${servers[@]}"
```

## 函数

- **函数**：创建可重用的代码块。
  - 使用 `FUNCTION_NAME() { STATEMENTS }` 定义
  - 通过使用函数名调用
  - 可以接受可通过 `$1`, `$2` 等访问的参数

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **函数参数**：函数可以像脚本一样接受参数。
  - 调用函数时传递参数
  - 在函数内部使用 `$1`, `$2` 等访问参数
  - 使用条件逻辑处理不同的参数

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## 随机数和数学运算

- **随机数**：使用 `$RANDOM` 变量生成随机值。
  - `$RANDOM` 生成0到32767之间的数字
  - 使用模运算符限制范围：`$RANDOM % 75`
  - 加1以避免零：`$(( RANDOM % 75 + 1 ))`
  - 必须使用 `$(( ... ))` 语法与 `$RANDOM` 进行计算

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **随机数组访问**：使用随机数随机访问数组元素。
  - 生成数组边界内的随机索引
  - 使用随机索引访问数组元素
  - 对于从预定义选项中进行随机选择很有用

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **模运算符**：使用 `%` 获取除法运算的余数。
  - 对于限制随机数范围至关重要
  - 与 `$RANDOM` 一起使用创建有界的随机值
  - `RANDOM % n` 给出从0到n-1的数字

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## 环境和系统信息

- **环境变量**：shell环境中预定义的变量。
  - `$RANDOM`：生成0到32767之间的随机数
  - `$LANG`：系统语言设置
  - `$HOME`：用户主目录路径
  - `$PATH`：搜索可执行命令的目录
  - 使用 [printenv](file:///D:/Program%20Files/Git/usr/bin/printenv.exe) 或 [declare](file:///D:/Program%20Files/Git/usr/bin/declare.exe) -p 查看所有

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **变量检查**：使用 [declare](file:///D:/Program%20Files/Git/usr/bin/declare.exe) 查看和处理变量。
  - `declare -p`：打印所有变量及其值
  - `declare -p VARIABLE`：打印特定变量的详细信息
  - 显示变量类型（字符串、数组等）和属性

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **命令类型**：bash中可用的不同类别的命令。
  - **内置命令**：由shell直接执行（例如 `echo`, `read`, `if`）
  - **外部命令**：系统目录中的二进制文件（例如 `ls`, `sleep`, `bash`）
  - **Shell关键字**：语言构造（例如 `then`, `do`, `done`）
  - 使用 `type <command>` 查看命令的类型

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## 文件创建和管理

- **文件创建**：使用 [touch](file:///D:/Program%20Files/Git/usr/bin/touch.exe) 创建新的空文件。
  - 如果文件不存在，则创建新文件
  - 如果文件已存在，则更新时间戳
  - 通常用于在编辑之前创建脚本文件

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## 创建和运行Bash脚本

- **脚本执行方法**：运行bash脚本的多种方式：
  - **`sh scriptname.sh`**：使用sh shell解释器运行。
  - **`bash scriptname.sh`**：使用bash shell解释器运行。
  - **`./scriptname.sh`**：直接执行（需要可执行权限）。

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## 文件权限和脚本执行

- **权限被拒绝错误**：使用 `./scriptname.sh` 时，如果文件缺少可执行权限，可能会得到"权限被拒绝"的提示。
- **检查权限**：使用 `ls -l` 查看文件权限。

  ```bash
  ls -l questionnaire.sh
  ```

- **权限格式**：输出将权限显示为 `-rw-r--r--`，其中：
  - 第一个字符（`-`）：文件类型（-表示普通文件，d表示目录）
  - 接下来的9个字符：所有者、组和其他人的权限
  - `r` = 读取，`w` = 写入，`x` = 执行

- **添加可执行权限**：使用 `chmod +x` 为所有人赋予可执行权限。

  ```bash
  chmod +x questionnaire.sh
  ```

- **脚本组织**：构建bash脚本的最佳实践。
  - 以shebang（`#!/bin/bash`）开头
  - 添加关于脚本目的的描述性注释
  - 在顶部定义变量
  - 将相关的函数组合在一起
  - 主脚本逻辑放在底部

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **顺序脚本执行**：创建按顺序运行多个程序的主脚本。
  - 对于自动化涉及多个脚本的工作流程很有用
  - 每个脚本在下一个开始之前运行到完成
  - 可以将不同的程序组合成单一的执行流程
  - 可以根据需要向各个脚本传递参数
  - 可以包含不同类型的程序（交互式、自动化等）

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

# --assignment--

复习Bash脚本的主题和概念。