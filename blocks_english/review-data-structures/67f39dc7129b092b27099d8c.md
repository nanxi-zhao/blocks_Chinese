---
id: 67f39dc7129b092b27099d8c
title: 数据结构复习
challengeType: 31
dashedName: review-data-structures
---

# --description--

## 算法和大O表示法

- **算法**：一组用于解决问题或执行任务的明确指令。算法必须在有限的步骤内完成，每个步骤都必须精确且明确。

- **大O表示法**：描述算法在输入规模增加时的最坏情况性能或增长率。它关注资源使用如何随着输入规模增长，忽略常数因子和低阶项。

### 常见的时间复杂度

- **O(1) - 常数时间**：算法花费相同的时间，无论输入规模如何。

```python
def check_even_or_odd(number):
    if number % 2 == 0:
        return 'Even'
    else:
        return 'Odd'
```

- **O(log n) - 对数时间**：随着输入增长，时间缓慢增加。常见于反复将问题规模减少一部分的算法（如二分查找）。

- **O(n) - 线性时间**：运行时间与输入规模成比例增加。

```python
for grade in grades:
    print(grade)
```

- **O(n log n) - 线性对数时间**：高效排序算法（如归并排序和快速排序）的常见时间复杂度。

- **O(n²) - 平方时间**：运行时间呈二次增长。常见于嵌套循环。

```python
for i in range(n):
    for j in range(n):
        print("Hello, World!")
```

### 空间复杂度

- **O(1) - 常数空间**：算法使用的内存量与输入规模无关。
- **O(n) - 线性空间**：内存使用量与输入规模成比例增长。
- **O(n²) - 平方空间**：内存使用量与输入规模的平方成比例增长。

## 问题解决技巧

- **理解问题**：多次阅读问题陈述。识别输入、预期输出以及如何将输入转换为输出。

- **伪代码**：算法逻辑的高级描述，与语言无关。使用常用书面语言混合编程结构如[IF](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)、[ELSE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)、[FOR](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)、[WHILE](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)。

```md
GET original_string
SET reversed_string = ""
FOR EACH character IN original_string:
  ADD character TO THE BEGINNING OF reversed_string
DISPLAY reversed_string
```

- **边界情况**：在算法应处理的边界上发生的特定有效输入。始终考虑和测试边界情况。

## 数组

- **静态数组**：具有在初始化时确定的固定大小。元素存储在相邻的内存位置。在程序执行期间大小不能改变。

- **动态数组**：在程序执行期间可以自动增长或缩小。通过在需要时自动复制到更大的数组来处理调整大小。

### Python列表（动态数组）

```python
numbers = [3, 4, 5, 6]

# 访问元素
numbers[0]  # 3

# 更新元素
numbers[2] = 16

# 添加元素
numbers.append(7)
numbers.insert(3, 15)  # 在特定索引处插入

# 删除元素
numbers.pop(2)  # 删除特定索引处的元素
numbers.pop()   # 删除最后一个元素
```

### 动态数组的时间复杂度

- **访问**：O(1)
- **在末尾插入**：平均O(1)，需要调整大小时为O(n)
- **在中间插入**：O(n)
- **删除**：中间为O(n)，末尾为O(1)

## 栈

- **栈**：后进先出（LIFO）数据结构。元素只能从顶部添加和删除。

- **压入操作**：向栈顶添加元素。时间复杂度：O(1)。

- **弹出操作**：从栈顶删除元素。时间复杂度：O(1)。

```python
# 使用Python列表作为栈
stack = []

# 压入操作
stack.append(1)
stack.append(2)
stack.append(3)

# 弹出操作
top_element = stack.pop()  # 返回3
```

## 队列

- **队列**：先进先出（FIFO）数据结构。元素从后部添加，从前部删除。

- **入队操作**：向队列后部添加元素。时间复杂度：O(1)。

- **出队操作**：从队列前部删除元素。时间复杂度：O(1)。

```python
from collections import deque

# 使用deque进行高效的队列操作
queue = deque()

# 入队操作
queue.append(1)
queue.append(2)
queue.append(3)

# 出队操作
first_element = queue.popleft()  # 返回1
```

## 链表

- **链表**：线性数据结构，其中每个节点包含数据和对下一个节点的引用。节点像链条一样连接。

### 单向链表

- **结构**：每个节点有数据和一个对下一个节点的引用。
- **遍历**：只能从头到尾向前移动。
- **头节点**：列表中的第一个节点，通常是唯一可以直接访问的节点。
- **尾节点**：列表中的最后一个节点，指向[None](file:///E:/1.work/byy/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E7%A8%8B/blocks/node_modules/@types/node/stream/consumers.d.ts#L11-L11)。

### 操作和时间复杂度

- **在开头插入**：O(1)
- **在末尾插入**：O(n) - 必须遍历到末尾
- **在中间插入**：O(n) - 必须遍历到位置
- **从开头删除**：O(1)
- **从末尾删除**：O(n) - 必须遍历以找到前一个节点
- **从中间删除**：O(n) - 必须遍历以找到节点

### 双向链表

- **结构**：每个节点有数据和两个引用：下一个节点和上一个节点。
- **遍历**：可以双向移动。
- **内存**：由于额外的引用，比单向链表需要更多内存。

## 哈希映射和集合

### 映射和哈希映射

- **映射（抽象数据类型）**：管理键值对集合。每个键必须是唯一的，但值可以重复。

- **哈希映射**：使用哈希技术的映射ADT的具体实现。使用哈希函数为键生成哈希值，这决定了在底层数组中的存储位置。

### Python字典（哈希映射）

```python
# 创建字典
my_dictionary = {
    "A": 1,
    "B": 2, 
    "C": 3
}

# 替代创建方式
my_dictionary = dict(A=1, B=2, C=3)

# 访问和修改
value = my_dictionary["A"]  # 1
my_dictionary["A"] = 4      # 更新值
del my_dictionary["A"]      # 删除键值对

# 检查成员资格
"C" in my_dictionary

# 获取键、值、项
my_dictionary.keys()
my_dictionary.values()
my_dictionary.items()
```

### 哈希映射的时间复杂度

- **平均情况**：插入、获取、删除为O(1)
- **最坏情况**：当发生许多哈希冲突时为O(n)

### 集合

- **集合**：唯一元素的无序集合。不允许重复，不维护特定顺序。

- **仅限不可变元素**：集合只能包含不可变数据类型（数字、字符串、元组），因为哈希值必须保持不变。

```python
# 创建集合
numbers = {1, 2, 3, 4}
empty_set = set()  # 必须使用set()，而不是{}

# 添加和删除元素
numbers.add(5)
numbers.remove(4)      # 如果未找到会引发KeyError
numbers.discard(4)     # 如果未找到不会出错

# 集合操作
set_a = {1, 2, 3, 4}
set_b = {2, 3, 4, 5, 6}

# 并集、交集、差集、对称差集
set_a.union(set_b)                    # 或 set_a | set_b
set_a.intersection(set_b)             # 或 set_a & set_b
set_a.difference(set_b)               # 或 set_a - set_b
set_a.symmetric_difference(set_b)     # 或 set_a ^ set_b

# 子集和超集检查
set_a.issubset(set_b)
set_a.issuperset(set_b)
set_a.isdisjoint(set_b)

# 成员资格测试
5 in numbers
```

### 集合的时间复杂度

- **平均情况**：添加、删除、成员资格测试为O(1)
- **最坏情况**：由于哈希冲突为O(n)

## 哈希冲突

- **哈希冲突**：当两个不同的键产生相同的哈希值时发生。

- **冲突解决策略**：
  - **链式法**：每个数组索引指向一个链表，存储所有具有相同哈希值的元素
  - **开放寻址法**：使用预定义序列搜索下一个可用索引

## 何时使用每种数据结构

- **列表**：当你需要有序的索引访问且不知道大小时
- **栈**：用于LIFO操作（撤销功能、表达式求值、回溯）
- **队列**：用于FIFO操作（任务调度、广度优先搜索）
- **链表**：当频繁在开头插入/删除、未知大小、不需要随机访问时
- **哈希映射**：用于快速键值查找、计算出现次数、缓存
- **集合**：用于唯一性检查、数学集合操作、删除重复项

# --assignment--

复习数据结构的主题和概念。