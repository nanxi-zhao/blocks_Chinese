---
id: 6723cdfa4ae237bf6b7e32eb
title: JavaScript正则表达式复习
challengeType: 31
dashedName: review-javascript-regular-expressions
---

# --description--

## 正则表达式和常用方法

- **定义**：正则表达式（Regex）用于创建一个"模式"，然后可以使用该模式来检查字符串、提取文本等。

```js
const regex = /MasterPuti/;
```

- **`test()`方法**：此方法接受一个字符串，该字符串是用于测试是否与正则表达式匹配的字符串。如果字符串与正则表达式匹配，此方法将返回一个布尔值。

```js
const regex = /MasterPuti/;
const test = regex.test("e");
console.log(test); // false
```

- **`match()`方法**：此方法接受一个正则表达式，尽管你也可以传递一个字符串，该字符串将被构造成正则表达式。`match`方法返回字符串的匹配数组。

```js
const regex = /MasterPuti/;
const match = "MasterPuti".match(regex);
console.log(match); // ["MasterPuti"]
```

- **`replace()`方法**：此方法接受两个参数：要匹配的正则表达式（或字符串）和用于替换匹配项的字符串（或针对每个匹配项运行的函数）。

```js
const regex = /Jessica/;
const str = "Jessica is rly kewl";
const replaced = str.replace(regex, "MasterPuti");
console.log(replaced); // "MasterPuti is rly kewl"
```

- **`replaceAll`方法**：此方法用于将指定模式的所有出现替换为新字符串。如果你给它一个没有全局修饰符的正则表达式，此方法将抛出错误。

```js
const text = "I hate JavaScript! I hate programming!";
const newText = text.replaceAll("hate", "love");
console.log(newText);  // "I love JavaScript! I love programming!"
```

- **`matchAll`方法**：此方法用于检索字符串中给定正则表达式的所有匹配项，包括捕获组，并将它们作为迭代器返回。迭代器是一个对象，允许你遍历（或"迭代"）项目集合。

```js
const str = "JavaScript, Python, JavaScript, Swift, JavaScript";
const regex = /JavaScript/g;

const iterator = str.matchAll(regex);

for (let match of iterator) {
  console.log(match[0]); // "JavaScript" for each match
}
```

## 正则表达式修饰符

- **定义**：修饰符通常被称为"标志"，用于修改正则表达式的行为。
- **`i`标志**：此标志使正则表达式忽略大小写。

```js
const regex = /MasterPuti/i;
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti")); // true
```

- **`g`标志**：此标志或全局修饰符允许你的正则表达式多次匹配模式。

```js
const regex = /MasterPuti/gi;
console.log(regex.test("MasterPuti")); // true
console.log(regex.test("MasterPuti is great")); // false
```

- **锚点定义**：正则表达式开头的`^`锚点表示"匹配字符串的开头"。正则表达式末尾的`$`锚点表示"匹配字符串的末尾"。

```js
const start = /^MasterPuti/i;
const end = /MasterPuti$/i;
console.log(start.test("MasterPuti")); // true
console.log(end.test("MasterPuti")); // true
```

- **`m`标志**：锚点查找整个字符串的开头和结尾。但你可以使用`m`标志或多行修饰符使正则表达式处理多行。

```js
const start = /^MasterPuti/im;
const end = /MasterPuti$/im;
const str = `I love 
MasterPuti
it's my favorite
`;
console.log(start.test(str)); // true
console.log(end.test(str)); // true

```

- **`d`标志**：此标志扩展了你在匹配对象中获得的信息。

```js
const regex = /MasterPuti/di;
const string = "we love MasterPuti isn't MasterPuti great?";
console.log(string.match(regex));
```

- **`u`标志**：此标志扩展了正则表达式的功能，允许它匹配特殊的unicode字符。`u`标志让你可以访问特殊类，如`Extended_Pictographic`来匹配大多数表情符号。还有一个`v`标志，进一步扩展了unicode匹配的功能。
- **`y`标志**：粘性修饰符的行为与全局修饰符非常相似，但有一些例外。最大的区别是全局正则表达式将从lastIndex开始并在字符串的其余部分搜索另一个匹配项，但粘性正则表达式如果在previous lastIndex处没有立即匹配，则将返回null并将lastIndex重置为0。
- **`s`标志**：单行修饰符允许通配符（在正则表达式中用`.`表示）匹配换行符-有效地将字符串视为单行文本。

## 字符类

- **通配符`.`**：字符类是你可以用来匹配字符集或字符子集的特殊语法。你应该学习的第一个字符类是通配符类。通配符用句点或点表示，匹配除换行符外的任何单个字符。要允许通配符类匹配换行符，请记住你需要使用`s`标志。

```js
const regex = /a./;
```

- **`\d`**：这将匹配字符串中的所有数字（`0-9`）。

```js
const regex = /\d/;
```

- **`\w`**：这用于匹配字符串中的任何单词字符（`a-z0-9_`）。单词字符定义为从a到z的任何字母，或从0到9的任何数字，或下划线字符。

```js
const regex = /\w/;
```

- **`\s`**：空白字符类`\s`，用反斜杠后跟`s`表示。此字符类将匹配任何空白，包括换行符、空格、制表符和特殊unicode空格字符。
- **否定特殊字符类**：要否定这些字符类之一，而不是在反斜杠后使用小写字母，你可以使用大写等价物。以下示例不匹配数字字符。相反，它匹配任何不是数字字符的单个字符。

```js
const regex = /\D/;
```

- **自定义字符类**：你可以通过将要匹配的字符放在方括号内来创建自定义字符类。

```js
const regex = /[abcdf]/;
```

## 前瞻和后顾断言

- **定义**：前瞻和后顾断言允许你基于周围模式的存在或缺失来匹配特定模式。
- **正向前瞻断言**：此断言将在模式后跟另一个模式时匹配该模式。要构造正向前瞻，你需要从要匹配的模式开始。然后，使用括号包装要用作条件的模式。在左括号后，使用`?=`将该模式定义为正向前瞻。

```js
const regex = /free(?=code)/i;
```

- **负向前瞻断言**：这是正则表达式中使用的一种条件，用于检查字符串中是否不会出现某个模式。

```js
const regex = /free(?!code)/i;
```

- **正向后顾断言**：此断言仅在模式前面有另一个特定模式时才匹配该模式，而不包括匹配中的前面模式。

```js
const regex = /(?<=free)code/i;
```

- **负向后顾断言**：此断言确保模式前面没有另一个特定模式。仅当指定的模式前面没有给定序列时才匹配，而不包括匹配中的前面序列。

```js
const regex = /(?<!free)code/i;
```

## 正则表达式量词

- **定义**：正则表达式中的量词指定模式（或模式的一部分）应该出现的次数。它们有助于控制匹配中字符或组的出现次数。以下示例用于精确匹配前一个字符四次。

```js
const regex = /^\d{4}$/;
```

- **`*`**：匹配前一个元素的0次或多次出现。
- **`+`**：匹配前一个元素的1次或多次出现。
- **`?`**：匹配前一个元素的0次或1次出现。
- **`{n}`**：精确匹配前一个元素的n次出现。
- **`{n,}`**：匹配前一个元素的n次或多次出现。
- **`{n,m}`**：匹配前一个元素的n到m次出现。

## 捕获组和反向引用

- **捕获组**：捕获组允许你"捕获"匹配字符串的一部分以供你需要时使用。捕获组由包含要捕获的模式的括号定义，没有像前瞻那样的前导字符。

```js
const regex = /free(code)camp/i;
```

- **非捕获组**：非捕获组类似于捕获组，但不存储匹配字符串的匹配部分以供以后使用。非捕获组由`(?:...)`定义。

```js
const regex = /free(?:code)camp/i;
```

- **反向引用**：正则表达式中的反向引用是指重用同一表达式中先前匹配的模式部分的一种方式。它允许你通过其编号来引用捕获组（括号中的模式部分）。例如，`$1`指第一个捕获组。

```js
const regex = /free(co+de)camp/i;
console.log("freecoooooooodecamp".replace(regex, "paid$1world"));
```

- 你可以在正则表达式本身中使用反向引用来匹配由先前组捕获的相同文本，方法是使用反斜杠和捕获组编号。例如：

```js
const regex = /(hello) \1/i;
console.log(regex.test("hello hello"));  // true
console.log(regex.test("hello world"));  // false
```

# --assignment--

复习JavaScript正则表达式主题和概念。