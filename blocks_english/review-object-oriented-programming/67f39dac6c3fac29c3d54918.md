---
id: 67f39dac6c3fac29c3d54918
title: 面向对象编程复习
challengeType: 31
dashedName: review-object-oriented-programming
---

# --description--

## 什么是面向对象编程？

- **面向对象编程**：一种编程风格，开发者将代码中的所有内容都视为真实世界的对象。它通常被称为OOP。帮助你有效组织和管理代码的四个关键原则是**封装**、**继承**、**多态**和**抽象**
- **类**：创建对象的蓝图。从类创建的每个对象都具有定义数据的属性和确定对象行为的方法。

## 什么是封装？

- **封装**：将对象的属性和方法捆绑到一个单一单元中。它让你将对象的内部状态隐藏在一组简单的公共方法和属性后面，这些方法和属性就像门一样。在这些门后面是私有属性和方法，它们控制数据如何变化以及谁可以看到它。
- **封装示例**：如果你想跟踪钱包余额，你将允许存款和取款，但你不希望任何人篡改钱包余额本身：

```py
class Wallet:
   def __init__(self, balance):
       self.__balance = balance # 私有属性

   def deposit(self, amount):
       if amount > 0:
           self.__balance += amount # 安全地添加到余额中

   def withdraw(self, amount):
       if 0 < amount <= self.__balance:
           self.__balance -= amount # 安全地从余额中扣除

account = Wallet(500)
print(account.__balance) # AttributeError: 'Wallet' object has no attribute '__balance'
```

- **单下划线和双下划线前缀属性的区别**：用单下划线前缀属性和方法意味着它们仅供内部使用。这是一种约定，它不会强制从外部访问属性。用双下划线前缀属性和方法可以有效防止它们从类外部被访问。

## 什么是Getter和Setter？

- **Getter和Setter**：让你控制如何访问和修改类的属性的方法。你使用getter检索值，使用setter设置值。
- **属性**：它们连接getter和setter，并允许访问数据。当你获取、设置或删除值时，它们在幕后运行额外的逻辑。
- **为什么使用属性而不是方法**：属性用于更好的可读性和更清晰的代码。它们让你使用点表示法访问值，就像常规属性一样，无需括号。
- **创建Getter**：要创建getter，你使用`@property`装饰器。这是一个获取圆半径的getter：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self): # 用于获取半径的getter
        return self._radius

    @property
    def area(self):  # 用于计算面积的getter
        return 3.14 * (self._radius ** 2)

my_circle = Circle(3)

print(my_circle.radius) # 3
print(my_circle.area) # 28.26
```

- **创建Setter**：要创建设置半径的setter，你必须定义另一个同名方法并在其上方使用`@<property_name>.setter`：

```py
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):  # 用于获取半径的getter
        return self._radius

    @radius.setter
    def radius(self, value):  # 用于设置半径的setter
        if value <= 0:
            raise ValueError('半径必须为正数')
        self._radius = value

my_circle = Circle(3)
print('初始半径:', my_circle.radius) # 初始半径: 3

my_circle.radius = 8
print('修改半径后:', my_circle.radius) # 修改半径后: 8
```

- **Python如何处理Getter和Setter**：一旦你定义了getter和setter，Python会在你以这种方式使用正常属性语法时自动在幕后调用它们：

```py
my_circle.radius # 这将调用getter
my_circle.radius = 4 # 这将调用setter
```

设置值时，你不应该分配给属性名本身，因为这会导致`RecursionError`。使用单独的内部名称，通常带下划线，来存储值。

- **Deleter**：在使用setter和getter设置和获取值后，你可以使用`deleter`控制如何删除它。Deleter在你对属性使用`del`语句时运行自定义逻辑。要创建deleter，你使用`@<property_name>.deleter`装饰器。

```py
  # Deleter
    @radius.deleter
    def radius(self):
        print("删除半径...")
        del self._radius
```

## 什么是继承以及它如何促进代码重用？

- **继承**：子类使用父类的属性和方法的过程。继承促进代码重用，提供清晰的层次结构，并在不重写所有内容的情况下自定义行为。要实现继承，子类需要传入父类的名称：

```py
class Parent:
    # 父类的属性和方法

class Child(Parent):
    # 子类继承、扩展和/或在必要时重写
```

- **单继承和多继承**：当子类从单个父类继承属性和方法时，如上所示，这个过程称为**单继承**。当子类从多个父类继承属性和方法时，这就是**多继承**。以下是其语法：

```py
class Parent:
    # Parent的属性和方法

class Child:
    # Child的属性和方法

class GrandChild(Parent, Child):
    # GrandChild从Parent和Child继承
    # GrandChild可以组合或重写每个类的行为
```

- **`super()`函数**：一个让你在子类中重写父类方法的函数。

## 什么是多态以及它如何促进代码重用？

- **多态**：OOP原则，让不同的类使用相同的方法名，但每个类在被调用时以不同的方式实现它。以下是其语法：

```py
class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # 适用于A、B或C
```

- **基于继承的多态**：父类设置一个方法，每个子类根据自己的用途对其进行调整。

## 什么是名称修饰以及它如何工作？

- **名称修饰**：Python内部将双下划线前缀的属性重命名的过程，通过添加下划线和类名作为前缀，将`__attribute`变成`_ClassName__attribute`。
- **名称修饰的目的**：名称修饰的主要目的是防止在使用继承时意外覆盖属性和方法。以下是使这一点更易理解的代码：

```py
class Parent:
    def __init__(self):
        self.__data = 'Parent data'

class Child(Parent):
    def __init__(self):
        super().__init__()
        self.__data = 'Child data'

c = Child()
print(c.__dict__) # {'_Parent__data': 'Parent data', '_Child__data': 'Child data'}
```

## 什么是抽象以及它如何帮助保持复杂系统的组织性？

- **抽象**：一种编程概念，其中对象或系统的复杂实现细节被隐藏，只显示基本特征。在Python和其他编程语言中，抽象通过增加可重用性来简化复杂系统。
- **抽象示例**：日常生活中抽象的一个好例子是汽车让你只需使用方向盘、踏板和换挡器，而无需知道发动机或刹车如何工作。
- **Python如何实现抽象**：Python通过`abc`模块实现抽象。该模块提供`ABC`类（抽象基类）和`@abstractmethod`装饰器。抽象基类（ABC）定义子类必须实现的公共方法和属性。它不能被实例化。
- **如何定义抽象方法**：抽象方法用`@abstractmethod`定义，必须在子类中重写，即使它有默认实现。抽象的基本语法如下：

```py
from abc import ABC, abstractmethod

# 定义抽象基类
class AbstractClass(ABC):
    @abstractmethod
    def abstract_method(self):
        pass

# 实现抽象方法的具体子类
class ConcreteClassOne(AbstractClass):
    def abstract_method(self):
        print('ConcreteClassOne中的实现')

# 另一个具体子类
class ConcreteClassTwo(AbstractClass):
    def abstract_method(self):
        print('ConcreteClassTwo中的实现')
```

# --assignment--

复习面向对象编程主题和概念。