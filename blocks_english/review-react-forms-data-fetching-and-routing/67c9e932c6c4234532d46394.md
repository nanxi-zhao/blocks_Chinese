---
id: 67c9e932c6c4234532d46394
title: React表单、数据获取和路由复习
challengeType: 31
dashedName: review-react-forms-data-fetching-and-routing
---

# --description--

## 在React中处理表单

- **受控输入**：这是指你将输入字段的值存储在状态中并通过`onChange`事件更新它。这让你完全控制表单数据，并允许即时验证和条件渲染。

```jsx
import { useState } from "react";

function App() {
  const [name, setName] = useState("");

  const handleChange = (e) => {
    setName(e.target.value);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    console.log(name);
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        <label htmlFor="name">你的名字</label> <br />
        <input value={name} id="name" onChange={handleChange} type="text" />
        <button type="submit">提交</button>
      </form>
    </>
  );
}

export default App;
```

- **非受控输入**：与通过`useState` hook处理输入不同，HTML中的非受控输入借助DOM维护自己的内部状态。由于DOM控制输入值，你需要使用`ref`来获取输入字段的值。

```jsx
import { useRef } from "react";

function App() {
 const nameRef = useRef();

 const handleSubmit = (e) => {
   e.preventDefault();
   console.log(nameRef.current.value);
 };

 return (
   <form onSubmit={handleSubmit}>
     <label htmlFor="name">你的</label>{" "}
     <input type="text" ref={nameRef} id="name" />
     <button type="submit">提交</button>
   </form>
 );
}

export default App;
```

## 使用`useActionState` Hook

- **服务器操作**：这些是在服务器上运行的函数，允许直接在服务器上处理表单，而无需API端点。以下是Next.js应用程序的示例：

```js
"use server";

async function submitForm(formData) {
 const name = formData.get("name");
 return { message: `你好, ${name}!` };
}
```

`"user server"`指令将函数标记为服务器操作。

- **`useActionState` Hook**：此hook根据表单提交的结果更新状态。以下是`useActionState` hook的基本语法：

```js
const [state, action, isPending] = useActionState(actionFunction, initialState, permalink);
```

- `state`是操作返回的当前状态。
- `action`是触发服务器操作的函数。
- `isPending`是一个布尔值，指示操作当前是否正在运行。
- `actionFunction`参数是服务器操作本身。
- `initialState`是表示操作运行前状态起始点的参数。
- `permalink`是包含表单修改的唯一页面URL的可选字符串。

## React中的数据获取

- **数据获取选项**：在React中有许多不同的方式来获取数据。你可以使用原生Fetch API，或第三方工具如Axios或SWR。
- **获取数据时常用的狀態變量**：无论你选择哪种方式在React中获取数据，都需要跟踪一些状态。第一个是数据本身。第二个将跟踪数据是否仍在获取中。第三个是状态变量，用于捕获数据获取过程中可能发生的任何错误。

```js
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);
```

由于数据获取是一个副作用，最好在`useEffect` hook中使用`Fetch API`。

```js
useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/posts");

      if (!res.ok) {
        throw new Error("网络响应不正常");
      }

      const data = await res.json();
      setData(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

然后，如果数据获取未完成，你可以渲染加载消息，如果获取数据时出错则显示错误消息，或者显示结果。

```jsx
if (loading) {
  return <p>加载中...</p>;
}

if (error) {
  return <p>{error.message}</p>;
}

return (
  <ul>
    {data.map((post) => (
      <li key={post.id}>{post.title}</li>
    ))}
  </ul>
);
```

如果你想使用Axios，你需要安装并导入它：

```bash
npm i axios
```

```js
import axios from "axios";
```

然后你可以使用`axios.get`获取数据：

```jsx
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);

useEffect(() => {
  const fetchData = async () => {
    try {
      const res = await axios.get(
        "https://jsonplaceholder.typicode.com/users"
      );
      setData(res.data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  };

  fetchData();
}, []);
```

要使用`useSWR` hook获取数据，你需要先安装并导入它。

```bash
npm i swr
```

```js
import useSWR from "swr";
```

以下是使用hook获取数据的方法：

```jsx
import useSWR from "swr";

const fetcher = (url) => fetch(url).then((res) => res.json());

const FetchTodos = () => {
 const { data, error } = useSWR(
   "https://jsonplaceholder.typicode.com/todos",
   fetcher
 );

 if (!data) {
   return <h2>加载中...</h2>;
 }
 if (error) {
   return <h2>错误: {error.message}</h2>;
 }

 return (
   <>
     <h2>待办事项</h2>
     <div>
       {data.map((todo) => (
         <h3 key={todo.id}>{todo.title}</h3>
       ))}
     </div>
   </>
 );
};

export default FetchTodos;
```

## 使用`useOptimistic` Hook

- **`useOptimistic` Hook**：此hook用于在等待异步操作在后台完成时保持UI响应。它有助于管理UI中的"乐观更新"，这是一种策略，即根据操作的预期结果立即更新UI，比如等待服务器响应。

这是基本语法：

```js
const [optimisticState, addOptimistic] = useOptimistic(actualState, updateFunction);
```

- `optimisticState`是为更好用户体验而立即更新的临时状态。
- `addOptimistic`是在实际状态更改之前应用乐观更新的函数。
- `actualState`是来自操作结果的真实状态值，比如从服务器获取数据。
- `updateFunction`是确定调用时乐观状态应如何更新的函数。

以下是`TaskList`组件中使用`useOptimistic` hook的示例：

```jsx
"use client";

import { useOptimistic } from "react";

export default function TaskList({ tasks, addTask }) {
  const [optimisticTasks, addOptimisticTask] = useOptimistic(
    tasks,
    (state, newTask) => [...state, { text: newTask, pending: true }]
  );

  async function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);

    addOptimisticTask(formData.get("task"));

    addTask(formData);
    e.target.reset();
  }

  return <>{/* UI */}</>;
}
```

- **`startTransition`**：这用于渲染部分UI并将状态更新标记为非紧急过渡。这允许UI在昂贵的更新期间保持响应。这是基本语法：

```js
startTransition(action);
```

`action`执行状态更新或触发一些与过渡相关的逻辑。这确保紧急UI更新（如打字或点击）不会被阻塞。

## 使用`useMemo` Hook

- **记忆化**：这是一种优化技术，其中基于特定参数缓存（记住）昂贵函数调用的结果。当提供相同参数时，返回缓存的结果而不是重新计算函数。
- **`useMemo` Hook**：此hook用于记忆计算值。以下是记忆化排序大数组结果的示例。`expensiveSortFunction`只在`largeArray`更改时运行：

```js
const memoizedSortedArray = useMemo(
  () => expensiveSortFunction(largeArray),
  [largeArray]
);
```

## 使用`useCallback` Hook

- **`useCallback` Hook**：这用于记忆函数引用。

```js
const handleClick = useCallback(() => {
  // 代码在这里
}, [dependency]);
```

- **`React.memo`**：这用于记忆组件，以防止在prop未更改时不必要的重新渲染。

```jsx
const MemoizedComponent = React.memo(({ prop }) => {
 return (
   <>
     {/* 展示内容 */}
   </>
});
```

## 依赖管理工具

- **依赖定义**：在软件中，依赖是指应用程序中的一个组件或模块依赖于另一个组件或模块才能正常工作。依赖在软件应用程序中很常见，因为它们允许开发人员使用其他人创建的预构建函数或工具。React项目需要的两个核心依赖是`react`和`react-dom`包：

```json
"dependencies": {
  "react": "^18.3.1",
  "react-dom": "^18.3.1"
}
```

- **包管理器定义**：要管理项目中的软件依赖，你需要使用包管理器。包管理器是用于安装、更新和删除依赖的工具。许多流行的编程语言如JavaScript、Python、Ruby和Java都使用包管理器。JavaScript的流行包管理器包括npm、Yarn和pnpm。
- **`package.json`文件**：这是项目中的关键配置文件，包含有关项目的元数据，包括其名称、版本和依赖。它还定义了脚本、许可信息和其他有助于管理项目及其依赖的设置。
- **`package-lock.json`文件**：此文件将锁定项目使用的所有包的确切版本。当你更新包时，新版本也会在锁定文件中更新。
- **`node_modules`文件夹**：此文件夹包含`package.json`文件中列出的依赖的实际代码，包括项目的直接依赖和这些依赖的依赖。
- **开发依赖**：这些是仅用于开发而不用于生产的包。例如测试库如Jest。你会将Jest安装为开发依赖，因为本地测试应用程序时需要它，但应用程序在生产中运行时不需要它。

```json
"devDependencies": {
  "@eslint/js": "^9.17.0",
  "@types/react": "^18.3.18",
  "@types/react-dom": "^18.3.5",
  "@vitejs/plugin-react": "^4.3.4",
  "eslint": "^9.17.0",
  "eslint-plugin-react": "^7.37.2",
  "eslint-plugin-react-hooks": "^5.0.0",
  "eslint-plugin-react-refresh": "^0.4.16",
  "globals": "^15.14.0",
  "vite": "^6.0.5"
}
```

## React Router

- **介绍**：React Router是一个第三方库，允许你向React应用程序添加路由。首先，你需要在现有的React项目中安装React Router，如下所示：

```bash
npm i react-router
```

然后在`main.jsx`或`index.jsx`文件中，你需要设置路由结构，如下所示：

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter, Routes, Route } from "react-router";
import App from "./App.jsx";

import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>
);
```

`path`和`element`用于将URL和UI组件耦合在一起。在这种情况下，我们正在为指向`App`组件的主页设置路由。

- **多视图和路由设置**：在较大的应用程序中，通常会设置多个视图和路由，如下所示：

```jsx
<Routes>
  <Route index element={<Home />} />
  <Route path="about" element={<About />} />

  <Route path="products">
    <Route index element={<ProductsHome />} />
    <Route path=":category" element={<Category />} />
    <Route path=":category/:productId" element={<ProductDetail />} />
    <Route path="trending" element={<Trending />} />
  </Route>
</Routes>
```

这些示例中的`index`属性表示给定路径段的默认路由。因此，`Home`组件将显示在根`/`路径上，而`ProductsHome`组件将显示在`/products`路径上。

- **嵌套路由**：你可以将路由嵌套在其他路由中，这会导致子路由的路径附加到父路由的路径上。

```jsx
<Route path="products">
  <Route path="trending" element={<Trending />} />
</Route>
```

在上面的示例中，热门产品的路径将是products/trending。

- **动态段**：动态段是指URL路径的任何部分都是动态的。

```jsx
<Route path=":category" element={<Category />} />
```

在此示例中，我们有一个名为`category`的动态段。当用户导航到类似products/brass-instruments的URL时，视图将更改为`Category`组件，你可以根据段动态获取适当的数据。

- **`useParams` Hook**：此hook用于访问URL路径中的动态参数。

```jsx
import { useParams } from "react-router";

export default function Category() {
  let params = useParams();
  {/* 访问category参数: params.category */}
  {/* 其余代码在这里 */}
}
```

## React框架

- **介绍**：React框架提供路由、图像优化、数据获取、身份验证等功能。这意味着在某些用例中，你可能不需要为前端和后端应用程序分别设置。React框架的示例包括Next.js和Remix。
- **Next.js路由**：此路由系统包括对动态路由、并行路由、路由处理程序、重定向、国际化等的支持。

以下是创建自定义请求处理程序的示例：

```js
export async function GET() {
  const res = await fetch("https://example-api.com");
  const data = await res.json();

  return Response.json({ data });
}
```

- **Next.js图像优化**：`Image`组件扩展了原生HTML `img`元素，允许更快的页面加载和尺寸优化。这意味着图像只在进入视口时才加载，`Image`组件将自动为每个设备提供正确尺寸的图像。

```jsx
import Image from "next/image";

export default function Page() {
  return (
    <Image src="link-to-image-goes-here" alt="descriptive-title-goes-here" />
  );
}
```

## Prop钻取

- **定义**：Prop钻取是将props从父组件传递到深度嵌套的子组件的过程，即使一些子组件不需要这些props。

## 状态管理

- **Context API**：Context是指父组件向子组件提供信息而无需通过props显式传递。`createContext`用于创建表示其他组件将读取的上下文的上下文对象。`Provider`用于向子组件提供上下文值。

```jsx
import { useState, createContext } from "react";

const CounterContext = createContext();

const CounterProvider = ({ children }) => {
  const [count, setCount] = useState(0);

  return (
    <CounterContext.Provider value={{ count, setCount }}>
      {children}
    </CounterContext.Provider>
  );
};

export { CounterContext, CounterProvider };
```

- **Redux**：Redux通过提供中央存储和对状态更新的严格控制来处理状态管理。它使用可预测的模式，包括操作、reducers和中间件。操作是将数据从应用程序发送到Redux存储的有效载荷，通常由用户交互触发。Reducers是指定状态应如何响应这些操作的函数，确保以不可变的方式更新状态。另一方面，中间件充当操作分发和reducer之间的桥梁，允许你扩展Redux的功能（例如日志记录、处理异步操作），而无需修改核心流程。

- **Zustand**：这种状态管理解决方案适用于中小型应用程序。它通过使用`useStore` hook直接在组件和页面中访问状态来工作。这让你可以在不需要操作、reducers或提供者的情况下修改和访问数据。

## 使用React DevTools调试React组件

- **React开发者工具**：这是你可以在Chrome、Firefox和Edge中使用的浏览器扩展，用于检查React组件和识别性能问题。对于Safari，你需要安装`react-devtools` npm包。安装React DevTools并在浏览器中打开React应用程序后，打开浏览器开发者工具以访问为调试React提供的两个额外选项卡——组件和分析器。
- **组件选项卡**：此选项卡以树视图格式显示每个组件。在此选项卡中你可以执行以下操作：
  - 查看应用程序的组件层次结构
  - 实时检查和修改props、状态和上下文值
  - 检查每个选定组件的源代码
  - 将组件数据记录到控制台
  - 检查组件的DOM元素
- **分析器选项卡**：此选项卡帮助你分析组件性能。你可以记录组件性能，以便识别不必要的重新渲染，查看提交持续时间，随后优化慢组件。

## React服务器组件

- **定义**：React服务器组件是仅在服务器上渲染的React组件，只将最终HTML发送到客户端。这意味着这些组件可以直接访问服务器端资源，并显著减少发送到浏览器的JavaScript数量。

# --assignment--

复习React路由、状态管理、表单和数据获取。