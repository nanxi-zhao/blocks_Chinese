---
id: 6724e5e321bce627736ea145
title: 关系型数据库复习
challengeType: 31
dashedName: review-relational-databases
---

# --description--

## 终端、Shell 和命令行基础

- **命令行**: 用户输入命令的文本界面。
- **终端**: 提供访问命令行的应用程序。
- **终端模拟器**: 为终端添加额外功能。
- **Shell**: 解释输入到终端中的命令（例如，Bash）。
- **PowerShell / 命令提示符 / Microsoft 终端**: 在 Windows 上访问命令行的选项。
- **终端 (macOS)**: macOS 上的内置选项，还有 iTerm 或 Ghostty 等第三方替代品。
- **终端 (Linux)**: 选项因发行版而异，有许多第三方模拟器，如 kitty。
- **术语**: 尽管"终端"、"shell"和"命令行"经常互换使用，但它们有特定的含义。

## 命令行快捷键

- **上下箭头**: 在历史记录中循环浏览上一个/下一个命令。
- **Tab**: 自动补全命令。
- **`Control+L`** (Linux/macOS) 或输入 `cls` (Windows): 清除终端屏幕。
- **`Control+C`**: 中断正在运行的命令（在 PowerShell 中如果选择了文本也用于复制）。
- **`Control+Z`** (仅限 Linux/macOS): 将任务挂起到后台；使用 `fg` 恢复它。
- **`!!`**: 立即重新运行最后执行的命令。

## Bash 基础

- **Bash** (Bourne Again Shell): 广泛使用的类 Unix shell。  
  主要命令:

  - **`pwd`**: 显示当前目录。
  - **`cd`**: 更改目录。
    - **`..`** 指向父目录（上一级）。
    - **`.`** 指向当前目录。
  - **`ls`**: 列出文件和文件夹。
    - **`-a`**: 显示所有文件，包括隐藏文件。
    - **`-l`**: 显示文件的详细信息。
  - **`less`**: 逐页查看文件内容，带有导航选项，包括向后滚动和搜索。
  - **`more`**: 一次显示一屏文件内容，向后滚动功能有限，具有基本导航功能。
  - **`cat`**: 一次性显示整个文件内容，无滚动或导航功能，适用于较小的文件。
  - **`mkdir`**: 创建新目录。
  - **`rmdir`**: 删除空目录。
  - **`touch`**: 创建新文件。
  - **`mv`**: 移动或重命名文件。
    - 重命名: `mv oldname.txt newname.txt`
    - 移动: `mv filename.txt /path/to/target/`
  - **`cp`**: 复制文件。
    - **`-r`**: 递归复制目录及其内容。
  - **`rm`**: 删除文件。
    - **`-r`**: 递归删除目录及其内容。
  - **`echo`**: 显示一行文本或变量的值。
    - 使用 `>` 覆盖文件中的现有内容。(例如，`echo "text" > file.txt`)
    - 使用 `>>` 将输出追加到文件**而不覆盖现有内容** (例如，`echo "text" >> file.txt`)。
  - **`exit`**: 退出终端会话。
  - **`clear`**: 清除终端屏幕。
  - **`find`**: 搜索文件和目录。
    - **`-name`**: 按名称模式搜索文件 (例如，`find . -name "*.txt"`)。
  - 使用 **`man`** 后跟命令 (例如，`man ls`) 访问详细的帮助手册页面。

## 命令选项和标志

- **选项** 或 **标志**: 修改命令的行为，通常以连字符为前缀:
  - **长格式 (两个连字符)**:
    - 示例: `--help`, `--version`
    - 值使用等号附加，例如，`--width=50`。
  - **短格式 (一个连字符)**:
    - 示例: `-a`, `-l`
    - 值用空格传递，例如，`-w 50`。
    - 多个短选项可以链接在一起，例如，`ls -alh`。
- **`--help`**: 你可以始终使用带有此标志的命令来了解任何命令的可用选项。

## 关系型数据库简介

- **关系型数据库**: 将数据组织成相关的表，表由行和列组成。每行代表一条记录，每列代表数据的一个属性。
- **关系型数据库的优势**: 可扩展，在各个领域（如医疗保健、商业、游戏）广泛适用，并且结构化以保持可靠的数据。
- **常见用例**: Web 开发、库存系统、电子商务、医疗保健和企业应用。

## 关键概念

- **模式**: 关系型数据库需要一个模式来定义其结构——表、列、数据类型、约束和关系。
- **主键**: 表中每行的唯一标识符。它们对数据完整性至关重要，并通过外键用于关联表之间的记录。
- **外键**: 引用另一个表中的主键，用于链接表之间的相关数据。
- **关系**: 通过主键和外键连接表，可以构建规范化数据并执行有意义的查询。
- **实体关系图 (ERD)**: 可视化数据库模式中实体（表）之间的关系。
- **数据完整性**: 使用键和数据类型强制执行。确保存储数据的一致性和准确性。

## SQL 基础

- **查询**: 从数据库中检索特定数据的请求。

```sql
SELECT * FROM dogs WHERE age < 3;
```

- **WHERE 子句**: 根据条件过滤结果。使用比较运算符如 `<`, `=`, `>` 等。
- **带 ORDER BY 的选择**: 根据列检索和排序结果。

```sql
SELECT columns FROM table_name ORDER BY column_name;
```

## 表操作

- **`CREATE TABLE` 语句**: 用于在数据库中创建新表。

```sql
CREATE TABLE first_table();
```

- **`ALTER TABLE ADD COLUMN` 语句**: 用于向现有表添加列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE;
```

- **`ALTER TABLE DROP COLUMN` 语句**: 用于从现有表中删除列。

```sql
ALTER TABLE table_name DROP COLUMN column_name;
```

- **`ALTER TABLE RENAME COLUMN` 语句**: 用于重命名表中的列。

```sql
ALTER TABLE table_name RENAME COLUMN column_name TO new_name;
```

- **`DROP TABLE` 语句**: 用于从数据库中删除整个表。

```sql
DROP TABLE table_name;
```

- **`ALTER DATABASE RENAME` 语句**: 用于重命名数据库。

```sql
ALTER DATABASE database_name RENAME TO new_database_name;
```

- **`DROP DATABASE` 语句**: 用于删除整个数据库。

```sql
DROP DATABASE database_name;
```

## 约束和数据完整性

- **带约束的 `ALTER TABLE ADD COLUMN`**: 用于向现有表添加带约束的列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT;
```

- **`NOT NULL` 约束**: 此约束确保列不能为空值。

```sql
column_name VARCHAR(50) NOT NULL
```

- **`ALTER TABLE ADD PRIMARY KEY` 语句**: 用于向表添加主键约束。

```sql
ALTER TABLE table_name ADD PRIMARY KEY(column_name);
```

- **`ALTER TABLE DROP CONSTRAINT` 语句**: 用于从表中删除约束。

```sql
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
```

- **带外键的 `ALTER TABLE ADD COLUMN`**: 用于添加引用另一个表的外键列。

```sql
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name);
```

- **`ALTER TABLE ADD UNIQUE` 语句**: 用于向列添加 UNIQUE 约束。

```sql
ALTER TABLE table_name ADD UNIQUE(column_name);
```

- **`ALTER TABLE ALTER COLUMN SET NOT NULL` 语句**: 用于在现有列上设置 NOT NULL 约束。

```sql
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL;
```

- **带 NULL 值的 `INSERT` 语句**: 此语句演示如何向表中插入 NULL 值。

```sql
INSERT INTO table_name(column_a) VALUES(NULL);
-- 或
INSERT INTO table_name(column_b) VALUES('value'); -- 如果 column_a 允许空值
```

- **复合主键**: 此约束定义由多个列组成的主键。

```sql
CREATE TABLE course_enrollments (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
```

## 数据操作 (CRUD)

- **`INSERT` 语句**: 用于向表中插入单行。

```sql
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2);
```

- **省略列的 `INSERT` 语句**: 此语句显示如何在不显式列出列名的情况下插入值，依赖于表中的默认列顺序。

```sql
INSERT INTO dogs VALUES ('Gino', 3);
```

- **带多行的 `INSERT` 语句**: 用于在单个操作中向表中插入多行。

```sql
INSERT INTO dogs (name, age) VALUES 
('Gino', 3),
('Nora', 2);
```

- **`UPDATE` 语句**: 用于根据条件更新表中的现有数据。

```sql
UPDATE table_name SET column_name=new_value WHERE condition;
```

- **`DELETE` 语句**: 用于根据条件从表中删除行。

```sql
DELETE FROM table_name WHERE condition;
```

## 数据类型

- **`NUMERIC` 数据类型**: 用于存储具有指定精度和小数位数的精确十进制数。

```sql
price NUMERIC(10, 2)
```

- **`TEXT` 数据类型**: 用于存储可变长度的字符串，没有特定的长度限制。

```sql
column_name TEXT
```

- **`INTEGER` 数据类型**: 用于存储不带小数位的整数。

```sql
units_sold INTEGER
```

- **`SMALLINT` 和 `BIGINT` 数据类型**: 这些是 INTEGER 的变体，分别具有较小和较大的范围。

- **`SERIAL` 数据类型**: 用于在 PostgreSQL 中创建自动递增的整数列。

```sql
id SERIAL
```

- **`AUTO_INCREMENT` 属性**: 在 MySQL 中用于创建自动递增的整数列。

```sql
id INT AUTO_INCREMENT
```

- **`VARCHAR` 数据类型**: 用于存储具有指定最大长度的可变长度字符串。

```sql
name VARCHAR(50)
```

- **`DATE` 数据类型**: 用于存储日期值（年、月、日）。

```sql
event_date DATE
```

- **`TIME` 数据类型**: 用于存储时间值（小时、分钟、秒）。

```sql
start_time TIME
```

- **`TIMESTAMP` 数据类型**: 用于存储日期和时间值，可选择带时区信息。

```sql
event_timestamp TIMESTAMP
event_timestamp TIMESTAMP WITH TIME ZONE
```

- **`BOOLEAN` 数据类型**: 用于存储真/假值。

```sql
is_active BOOLEAN
```

## 数据库关系

- **关系类型**: 这些是在关系型数据库中表之间可以关联的不同方式。
  - 一对一
  - 一对多
  - 多对一
  - 多对多
  - 自引用（递归）

- **一对一关系**: 这种关系类型意味着一个表中的每条记录对应另一个表中的恰好一条记录。

```md
一个员工被分配恰好一辆车。
表: employees, vehicles
```

- **一对多关系**: 这种关系类型意味着一个表中的一条记录可以与另一个表中的多条记录关联。

```md
一个客户可以有多个订单。
表: customers → orders
```

- **通过连接表的多对多关系**: 这种关系类型使用包含两个相关表外键的连接表来实现。

```sql
CREATE TABLE books_authors (
    author_id INT REFERENCES authors(id),
    book_id INT REFERENCES books(id)
);
```

- **自引用关系**: 当一个表引用自身时发生这种关系类型，创建层次结构。

```md
员工表中每个员工可能向另一个员工报告。
```

## 高级 SQL (连接)

- **`INNER JOIN` 语句**: 此连接仅返回两个表中具有匹配值的行。

```sql
SELECT *
FROM products
INNER JOIN sales ON products.product_id = sales.product_id;
```

- **`FULL OUTER JOIN` 语句**: 此连接返回两个表中的所有行，包括任一表中不匹配的行。

```sql
SELECT *
FROM products
FULL OUTER JOIN sales ON products.product_id = sales.product_id;
```

- **`LEFT OUTER JOIN` 语句**: 此连接返回左表中的所有行和右表中的匹配行。

```sql
SELECT *
FROM products
LEFT JOIN sales ON products.product_id = sales.product_id;
```

- **`RIGHT OUTER JOIN` 语句**: 此连接返回右表中的所有行和左表中的匹配行。

```sql
SELECT *
FROM products
RIGHT JOIN sales ON products.product_id = sales.product_id;
```

- **`SELF JOIN` 语句**: 用于将表与其自身连接，以比较同一表中的行。

```sql
SELECT A.column_name, B.column_name
FROM table_name A
JOIN table_name B ON A.related_column = B.related_column;
```

- **`CROSS JOIN` 语句**: 此连接返回两个表的笛卡尔积，将第一个表的每一行与第二个表的每一行组合。

```sql
SELECT *
FROM table1
CROSS JOIN table2;
```

## PostgreSQL 特定命令

- **`psql` 登录命令**: 用于使用特定用户名和数据库登录到 PostgreSQL。

```bash
psql --username=MasterPuti --dbname=postgres
```

- **`\l` 命令**: 此命令列出 PostgreSQL 实例中的所有数据库。

```sql
\l
```

- **`CREATE DATABASE` 和 `\c` 命令**: 这些命令用于创建新数据库并连接到它。

```sql
CREATE DATABASE database_name;
\c database_name
```

- **`\d` 命令**: 此命令列出当前数据库中的所有表。

```sql
\d
```

- **`\d table_name` 命令**: 此命令显示特定表的模式/结构。

```sql
\d table_name
```

- **`\q` 命令**: 此命令退出 PostgreSQL 客户端。

```bash
\q
```

## 关系型与非关系型

- **非关系型 (NoSQL) 数据库**: 存储非结构化或半结构化数据。不需要严格的模式，对于不断变化的数据模型更加灵活。
- **关系型与非关系型的选择**: 取决于数据的性质和应用程序需求。
- **关系型与非关系型**: 选择关系型用于结构化数据和一致性；NoSQL 用于灵活性和快速变化的数据。

## 流行的 RDBMS 系统

- **MySQL**: 开源、可靠，在 Web 开发中广泛使用，拥有庞大的社区支持。
- **PostgreSQL**: 开源、高级、可扩展。支持自定义数据类型和服务器端编程。
- **SQLite**: 轻量级、基于文件、无服务器。适用于小型应用程序。
- **Microsoft SQL Server**: 商业级数据库。
- **Oracle Database**: 商业 RDBMS，以大规模性能和可扩展性著称。

## 最佳实践

- **命名约定**: 使用 `snake_case` (例如，`delivery_orders`) 为表和列命名。

## Bash 脚本基础

- **Bash 脚本**: 在文件中编写一系列 Bash 命令，然后可以使用 Bash 执行该文件来运行文件内容。
- **Shebang**: 脚本开头的注释行 (例如，`#!/bin/bash`)，指示应使用哪个解释器来执行脚本。

  ```bash
  #!/bin/bash
  ```

- **变量赋值**: 使用语法 `variable_name=value` 实例化变量。

  ```bash
  servers=("prod" "dev")
  ```

- **变量创建规则**: 使用 `VARIABLE_NAME=VALUE` 语法创建变量。等号 (`=`) 周围不允许有空格。如果值包含空格，请使用双引号。

  ```bash
  NAME=John
  MESSAGE="Hello World"
  COUNT=5
  TEXT="The next number is, "
  ```

- **变量使用**: 通过在变量名前放置 `$` 来访问变量值。

  ```bash
  echo $NAME
  echo "The message is: $MESSAGE"
  ```

- **变量插值**: 使用 `$variable_name` 在字符串和命令中访问变量的值。

  ```bash
  TEXT="The next number is, "
  NUMBER=42
  echo $TEXT B:$NUMBER
  echo $TEXT I:$NUMBER

  echo "Pulling $server"
  rsync --archive --verbose $server:/etc/nginx/conf.d/server.conf configs/$server.conf
  ```

- **变量作用域**: Shell 脚本从上到下运行，因此变量只能在创建位置下方使用。

  ```bash
  NAME="Alice"
  echo $NAME
  ```

- **用户输入**: 使用 `read` 接受用户输入并将其存储在变量中。

  ```bash
  read USERNAME
  echo "Hello $USERNAME"
  ```

- **注释**: 使用 `#` 后跟注释文本向脚本添加注释。
  - 单行注释以 `#` 开头并延续到行尾
  - 注释被 shell 忽略，不影响脚本执行

  ```bash
  # 这是单行注释
  NAME="John"  # 行尾注释
  ```

- **多行注释**: 使用冒号和引号注释掉代码块。

  ```bash
  : '
  这是多行注释
  引号之间的所有内容都被忽略
  用于调试或文档
  '
  ```

- **内置命令和帮助**:
  - 使用 `help` 查看内置 bash 命令列表
  - 使用 `help <command>` 获取特定内置命令的信息
  - 一些命令 (如 `if`) 是内置的，没有手册页
  - 内置命令由 shell 直接执行，而不是作为外部程序
  - 使用 `help function` 查看创建函数的信息

  ```bash
  help
  help if
  help function
  ```

- **查找命令位置**: 使用 `which` 定位可执行文件的安装位置。
  - 显示可执行文件的完整路径
  - 用于查找解释器位置 (如 bash)
  - 有助于验证将执行哪个版本的命令

  ```bash
  which bash
  which python
  which ls
  ```

- **手册页**: 使用 `man` 访问命令的详细文档。
  - 提供有关命令用法的全面信息
  - 显示所有可用选项和示例
  - 使用箭头键导航，'q' 退出
  - 并非所有命令都有手册页 (内置命令使用 `help` 代替)

  ```bash
  man echo
  man ls
  man bash
  ```

- **帮助标志**: 许多命令支持 `--help` 以获取快速帮助信息。
  - 手册页的替代方案，用于快速参考
  - 显示命令语法和常用选项
  - 并非所有命令都支持此标志 (有些可能显示错误)

  ```bash
  ls --help
  chmod --help
  mv --help
  ```

- **Echo 命令选项**: `echo` 命令支持各种选项:
  - `-e` 选项启用反斜杠转义的解释
  - `\n` 创建新行
  - 只有在引号中包含值时才打印空行
  - 用于创建格式化输出和程序标题

  ```bash
  echo -e "Line 1\nLine 2"
  echo ""
  echo -e "\n~~ Program Title ~~\n"
  echo "Line 1\nLine 2"
  ```

- **脚本参数**: 程序可以接受可通过 `$` 变量访问的参数。
  - `$*` 打印传递给脚本的所有参数
  - `$@` 以单独的带引号字符串形式打印传递给脚本的所有参数
  - `$<number>` 按位置访问特定参数 (例如，`$1`, `$2`, `$3`)

  ```bash
  echo $*
  echo $@
  echo $1
  echo $2
  ```

## 双括号表达式 `[[ ]]`

- **双括号语法**: 使用 `[[ ]]` 进行条件测试和模式匹配。
  - 括号内和运算符周围必须有空格
  - 根据测试结果返回退出状态 0 (真) 或 1 (假)

  ```bash
  [[ $variable == "value" ]]
  [[ $number -gt 10 ]]
  [[ -f filename.txt ]]
  ```

- **字符串比较运算符**: 在 `[[ ]]` 内使用各种运算符比较字符串。
  - `==` (相等): 测试两个字符串是否相同
  - `!=` (不相等): 测试两个字符串是否不同
  - `<` (字典序小于): 按字母顺序进行字符串比较
  - `>` (字典序大于): 按字母顺序进行字符串比较

  ```bash
  [[ "apple" == "apple" ]]
  [[ "apple" != "orange" ]]
  [[ "apple" < "banana" ]]
  [[ "zebra" > "apple" ]]
  ```

- **数值比较运算符**: 使用特定的数值运算符比较数字。
  - `-eq` (相等): 数值相等比较
  - `-ne` (不相等): 数值不等比较
  - `-lt` (小于): 数值小于比较
  - `-le` (小于或等于): 数值小于或等于比较
  - `-gt` (大于): 数值大于比较
  - `-ge` (大于或等于): 数值大于或等于比较

  ```bash
  [[ $number -eq 5 ]]
  [[ $count -ne 0 ]]
  [[ $age -ge 18 ]]
  [[ $score -lt 100 ]]
  ```

- **逻辑运算符**: 使用逻辑运算符组合多个条件。
  - `&&` (与): 两个条件都必须为真
  - `||` (或): 至少一个条件必须为真
  - `!` (非): 否定条件 (使真为假，假为真)

  ```bash
  [[ $age -ge 18 && $age -le 65 ]]
  [[ $name == "John" || $name == "Jane" ]]
  [[ ! -f missing_file.txt ]]
  ```

- **文件测试运算符**: 测试文件属性和存在性。
  - `-e file`: 如果文件存在则为真
  - `-f file`: 如果文件存在且是常规文件则为真
  - `-d file`: 如果文件存在且是目录则为真
  - `-r file`: 如果文件存在且可读则为真
  - `-w file`: 如果文件存在且可写则为真
  - `-x file`: 如果文件存在且可执行则为真
  - `-s file`: 如果文件存在且大小大于零则为真

  ```bash
  [[ -e /path/to/file ]]
  [[ -f script.sh ]]
  [[ -d /home/user ]]
  [[ -x program ]]
  ```

- **使用 `=~` 进行模式匹配**: 使用正则表达式进行高级模式匹配。
  - `=~` 运算符启用正则表达式模式匹配
  - 使用正则元字符时模式不应加引号
  - 支持完整的正则表达式语法
  - 默认区分大小写

  ```bash
  [[ "hello123" =~ [0-9]+ ]]
  [[ "email@domain.com" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
  [[ "filename.txt" =~ \.txt$ ]]
  ```

- **变量存在性测试**: 检查变量是否已设置或为空。
  - 测试变量是否为空: `[[ ! $variable ]]`

  ```bash
  [[ ! $undefined_var ]]
  ```

## 双括号表达式 `(( ))`

- **算术求值**: 使用 `(( ))` 进行数学计算和数值比较。
  - 使用 C 风格语法求值算术表达式
  - 双括号内变量不需要 `$` 前缀
  - 如果结果非零则返回退出状态 0，如果结果为零则返回 1
  - 支持所有标准算术运算符

  ```bash
  (( result = 10 + 5 ))
  (( count++ ))
  (( total += value ))
  ```

- **算术运算符**: `(( ))` 中可用的数学运算符。
  - `+` (加法): 两个数相加
  - `-` (减法): 第二个数从第一个数中减去
  - `*` (乘法): 两个数相乘
  - `/` (除法): 第一个数除以第二个数 (整数除法)
  - `%` (取模): 除法后的余数
  - `**` (指数): 将第一个数提升到第二个数的幂

  ```bash
  (( sum = a + b ))
  (( diff = x - y ))
  (( product = width * height ))
  (( remainder = num % 10 ))
  (( power = base ** exponent ))
  ```

- **赋值运算符**: 使用算术赋值运算符修改变量。
  - `=` (赋值): 将值赋给变量
  - `+=` (加法赋值): 将值加到变量上
  - `-=` (减法赋值): 从变量中减去值
  - `*=` (乘法赋值): 将变量乘以值
  - `/=` (除法赋值): 将变量除以值
  - `%=` (取模赋值): 将变量设置为余数

  ```bash
  (( counter = 0 ))
  (( counter += 5 ))
  (( total -= cost ))
  (( area *= 2 ))
  (( value /= 3 ))
  ```

- **递增和递减运算符**: 将变量修改 1。
  - `++variable` (前递增): 使用前递增
  - `variable++` (后递增): 使用后递增
  - `--variable` (前递减): 使用前递减
  - `variable--` (后递减): 使用后递减

  ```bash
  (( ++counter ))
  (( index++ ))
  (( --remaining ))
  (( attempts-- ))
  ```

- **比较运算符**: 使用算术比较比较数字。
  - `==` (相等): 数字相等
  - `!=` (不相等): 数字不相等
  - `<` (小于): 第一个数小于第二个数
  - `<=` (小于或等于): 第一个数小于或等于第二个数
  - `>` (大于): 第一个数大于第二个数
  - `>=` (大于或等于): 第一个数大于或等于第二个数

  ```bash
  (( age >= 18 ))
  (( score < 100 ))
  (( count == 0 ))
  (( temperature > freezing ))
  ```

- **逻辑运算符**: 组合算术条件。
  - `&&` (与): 两个条件都必须为真
  - `||` (或): 至少一个条件必须为真
  - `!` (非): 否定条件

  ```bash
  (( age >= 18 && age <= 65 ))
  (( score >= 90 || extra_credit > 0 ))
  (( !(count == 0) ))
  ```

- **位运算符**: 对整数执行位级操作。
  - `&` (按位与): 对每一位进行与操作
  - `|` (按位或): 对每一位进行或操作
  - `^` (按位异或): 对每一位进行异或操作
  - `~` (按位非): 反转所有位
  - `<<` (左移): 将位向左移动
  - `>>` (右移): 将位向右移动

  ```bash
  (( result = a & b ))
  (( flags |= new_flag ))
  (( shifted = value << 2 ))
  ```

- **条件 (三元) 运算符**: 使用 `condition ? true_value : false_value` 语法。
  - 提供了一种基于条件赋值的简洁方式
  - 类似于 C 风格语言中的三元运算符
  - 求值条件并返回两个值中的一个

  ```bash
  (( result = (score >= 60) ? 1 : 0 ))
  (( max = (a > b) ? a : b ))
  (( sign = (num >= 0) ? 1 : -1 ))
  ```

- **带算术的命令替换**: 使用 `$(( ))` 捕获算术结果。
  - 将算术表达式的结果作为字符串返回
  - 可用于赋值或命令参数
  - 用于需要在其他地方使用的计算

  ```bash
  result=$(( 10 + 5 ))
  echo "The answer is $(( a * b ))"
  array_index=$(( RANDOM % array_length ))
  ```

## 控制流和条件语句

- **条件语句**: 使用 `if` 语句根据条件执行代码。
  - 基本语法: `if [[ CONDITION ]] then STATEMENTS fi`
  - 完整语法: `if [[ CONDITION ]] then STATEMENTS elif [[ CONDITION ]] then STATEMENTS else STATEMENTS fi`
  - 可以在不同的条件类型中使用 `[[ ]]` 和 `(( ))` 表达式
  - **elif (else if)**: 可选，可以重复多次以按顺序测试附加条件
  - **else**: 可选，当所有先前条件为假时执行
  - 可以在同一条件链中混合使用双括号 `(( ... ))` 和双括号 `[[ ... ]]`

  ```bash
  if (( NUMBER <= 15 ))
  then
      echo "B:$NUMBER"
  elif [[ $NUMBER -le 30 ]]
  then
      echo "I:$NUMBER"
  elif (( NUMBER < 46 ))
  then
      echo "N:$NUMBER"
  elif [[ $NUMBER -lt 61 ]]
  then
      echo "G:$NUMBER"
  else
      echo "O:$NUMBER"
  fi
  ```

## 命令执行和进程控制

- **命令分隔**: 使用分号 (`;`) 在单行上运行多个命令。
  - 命令从左到右依次执行
  - 可以单独检查每个命令的退出状态

  ```bash
  [[ 4 -ge 5 ]]; echo $?
  ls -l; echo "Done"
  ```

- **退出状态**: 每个命令都有一个退出状态，表示成功或失败。
  - 使用 `$?` 访问上一个命令的退出状态
  - 退出状态 `0` 表示成功 (真/无错误)
  - 任何非零退出状态表示失败 (假/发生错误)
  - 常见错误代码: `127` (命令未找到), `1` (一般错误)

  ```bash
  echo $?
  [[ 4 -le 5 ]]; echo $?
  ls; echo $?
  bad_command; echo $?
  ```

- **子 shell 和命令替换**: 用于执行上下文的不同括号用法。
  - 单括号 `( ... )` 创建子 shell
  - `$( ... )` 执行命令替换
  - 子 shell 在单独的环境中运行，不影响父 shell 变量

  ```bash
  ( cd /tmp; echo "Current dir: $(pwd)" )
  current_date=$(date)
  file_count=$(ls | wc -l)
  echo "Today is $current_date"
  echo "Found $file_count files"
  ```

- **Sleep 命令**: 暂停脚本执行指定的秒数。
  - 用于在脚本中创建延迟
  - 可以与小数值一起使用以实现亚秒级延迟

  ```bash
  sleep 3
  sleep 0.5
  sleep 1
  ```

## 循环

- **While 循环**: 当条件为真时重复执行代码。
  - 语法: `while [[ CONDITION ]] do STATEMENTS done`

  ```bash
  I=5
  while [[ $I -ge 0 ]]
  do
      echo $I
      (( I-- ))
      sleep 1
  done
  ```

- **Until 循环**: 当条件变为真时重复执行代码。
  - 语法: `until [[ CONDITION ]] do STATEMENTS done`

  ```bash
  until [[ $QUESTION =~ \?$ ]]
  do
      echo "Please enter a question ending with ?"
      read QUESTION
  done
  until [[ $QUESTION =~ \?$ ]]
  do
      GET_FORTUNE again
  done
  ```

- **For 循环**: 使用 `for` 循环迭代数组或列表，使用 `do` 和 `done` 定义循环的逻辑块。

  ```bash
  for server in "${servers[@]}"
  do
      echo "Processing $server"
  done
  for (( i = 1; i <= 5; i++ ))
  do
      echo "Number: $i"
  done
  for (( i = 5; i >= 1; i-- ))
  do
      echo "Countdown: $i"
  done
  for i in {1..5}
  do
      echo "Count: $i"
  done
  ```

## 数组

- **数组**: 在单个变量中存储多个值。
  - 使用括号创建数组: `ARRAY=("value1" "value2" "value3")`
  - 按索引访问元素: `${ARRAY[0]}`, `${ARRAY[1]}`
  - 访问所有元素: `${ARRAY[@]}` 或 `${ARRAY[*]}`
  - 数组索引从 0 开始

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Ask again later")

  echo ${RESPONSES[0]}     # Yes          
  echo ${RESPONSES[1]}     # No         
  echo ${RESPONSES[5]}     # 索引 5 不存在; 空字符串              
  echo ${RESPONSES[@]}     # Yes No Maybe Ask again later   
  echo ${RESPONSES[*]}     # Yes No Maybe Ask again later 
  ```

- **使用 declare 检查数组**: 使用 `declare -p` 查看数组详细信息。
  - 显示带有 `-a` 标志的数组类型
  - 显示所有数组元素及其结构

  ```bash
  ARR=("a" "b" "c")
  declare -p ARR # ARR=([0]="a" [1]="b" [2]="c")
  ```

- **数组扩展**: 使用 `"${array_name[@]}"` 语法将数组扩展为单个元素。

```bash
for server in "${servers[@]}"
```

## 函数

- **函数**: 创建可重用的代码块。
  - 定义为 `FUNCTION_NAME() { STATEMENTS }`
  - 通过使用函数名调用
  - 可以接受可通过 `$1`, `$2` 等访问的参数

  ```bash
  GET_FORTUNE() {
      echo "Ask a question:"
      read QUESTION
  }
  GET_FORTUNE
  ```

- **函数参数**: 函数可以像脚本一样接受参数。
  - 调用函数时传递参数
  - 在函数内部使用 `$1`, `$2` 等访问参数
  - 使用条件逻辑处理不同参数

  ```bash
  GET_FORTUNE() {
      if [[ ! $1 ]]
      then
          echo "Ask a yes or no question:"
      else
          echo "Try again. Make sure it ends with a question mark:"
      fi
      read QUESTION
  }
  GET_FORTUNE
  GET_FORTUNE again
  ```

## 随机数和数学运算

- **随机数**: 使用 `$RANDOM` 变量生成随机值。
  - `$RANDOM` 生成 0 到 32767 之间的数字
  - 使用模运算符限制范围: `$RANDOM % 75`
  - 加 1 避免零: `$(( RANDOM % 75 + 1 ))`
  - 必须使用 `$(( ... ))` 语法进行 `$RANDOM` 计算

  ```bash
  NUMBER=$(( RANDOM % 6 ))
  DICE=$(( RANDOM % 6 + 1 ))
  BINGO=$(( RANDOM % 75 + 1 ))
  echo $(( RANDOM % 10 ))
  ```

- **随机数组访问**: 使用随机数随机访问数组元素。
  - 生成数组边界内的随机索引
  - 使用随机索引访问数组元素
  - 用于从预定义选项中随机选择

  ```bash
  RESPONSES=("Yes" "No" "Maybe" "Outlook good" "Don't count on it" "Ask again later")
  N=$(( RANDOM % 6 ))
  echo ${RESPONSES[$N]}
  ```

- **模运算符**: 使用 `%` 获取除法运算的余数。
  - 对于限制随机数范围至关重要
  - 与 `$RANDOM` 一起工作以创建有界的随机值
  - `RANDOM % n` 给出从 0 到 n-1 的数字

  ```bash
  echo $(( 15 % 4 ))
  echo $(( RANDOM % 100 ))
  echo $(( RANDOM % 10 + 1 ))
  ```

## 环境和系统信息

- **环境变量**: shell 环境中可用的预定义变量。
  - `$RANDOM`: 生成 0 到 32767 之间的随机数
  - `$LANG`: 系统语言设置
  - `$HOME`: 用户主目录路径
  - `$PATH`: 搜索可执行命令的目录
  - 使用 `printenv` 或 `declare -p` 查看所有变量

  ```bash
  echo $RANDOM
  echo $HOME
  echo $LANG
  printenv
  ```

- **变量检查**: 使用 `declare` 查看和处理变量。
  - `declare -p`: 打印所有变量及其值
  - `declare -p VARIABLE`: 打印特定变量详细信息
  - 显示变量类型 (字符串、数组等) 和属性

  ```bash
  declare -p
  declare -p RANDOM
  declare -p MY_ARRAY
  ```

- **命令类型**: bash 中命令的不同类别。
  - **内置命令**: 由 shell 直接执行 (例如，`echo`, `read`, `if`)
  - **外部命令**: 系统目录中的二进制文件 (例如，`ls`, `sleep`, `bash`)
  - **Shell 关键字**: 语言构造 (例如，`then`, `do`, `done`)
  - 使用 `type <command>` 查看命令类型

  ```bash
  type echo
  type ls
  type if
  type ./script.sh
  ```

## 文件创建和管理

- **文件创建**: 使用 `touch` 创建新的空文件。
  - 如果文件不存在则创建新文件
  - 如果文件已存在则更新时间戳
  - 通常用于在编辑前创建脚本文件

  ```bash
  touch script.sh
  touch bingo.sh
  touch filename.txt
  ```

## 创建和运行 Bash 脚本

- **脚本执行方法**: 运行 bash 脚本的多种方式:
  - **`sh scriptname.sh`**: 使用 sh shell 解释器运行。
  - **`bash scriptname.sh`**: 使用 bash shell 解释器运行。
  - **`./scriptname.sh`**: 直接执行 (需要可执行权限)。

```bash
sh questionnaire.sh
bash questionnaire.sh
./questionnaire.sh
```

## 文件权限和脚本执行

- **权限被拒绝错误**: 使用 `./scriptname.sh` 时，如果文件缺少可执行权限，可能会得到"权限被拒绝"。
- **检查权限**: 使用 `ls -l` 查看文件权限。

  ```bash
  ls -l questionnaire.sh
  ```

- **权限格式**: 输出显示权限为 `-rw-r--r--`，其中:
  - 第一个字符 (`-`): 文件类型 (- 为常规文件，d 为目录)
  - 接下来的 9 个字符: 所有者、组和其他用户的权限
  - `r` = 读取, `w` = 写入, `x` = 执行

- **添加可执行权限**: 使用 `chmod +x` 给每个人添加可执行权限。

  ```bash
  chmod +x questionnaire.sh
  ```

- **脚本组织**: 构建 bash 脚本的最佳实践。
  - 以 shebang 开头 (`#!/bin/bash`)
  - 添加关于脚本目的的描述性注释
  - 在顶部定义变量
  - 将相关函数分组
  - 在底部放置主要脚本逻辑

  ```bash
  #!/bin/bash
  NAME="value"
  ARRAY=("item1" "item2")
  my_function() {
      echo "Function code here"
  }
  my_function
  echo "Script complete"
  ```

- **顺序脚本执行**: 创建按顺序运行多个程序的主脚本。
  - 用于自动化涉及多个脚本的工作流程
  - 每个脚本在下一个脚本开始前运行完成
  - 可以将不同程序组合成单个执行流程
  - 可以根据需要向各个脚本传递参数
  - 可以包含不同类型的程序 (交互式、自动化等)

  ```bash
  #!/bin/bash
  ./setup.sh
  ./interactive.sh
  ./processing.sh
  ./cleanup.sh
  ```

## 数据库规范化

这是组织关系型数据库以减少数据冗余并提高完整性的过程。

其好处包括:

- 最小化重复数据，节省存储空间并减少不一致性。
- 通过使用主键和外键强制执行数据完整性。
- 使数据库更易于维护和理解。

### 范式

- **1NF (第一范式)**
  - 每个单元格包含单个 (原子) 值。
  - 每条记录都是唯一的 (由主键强制执行)。
  - 行/列的顺序无关紧要。
  - 示例: 将多个电话号码从 `students` 表移动到单独的 `student_phones` 表。

- **2NF (第二范式)**
  - 满足 1NF 要求。
  - 无 **部分依赖**: 每个非键属性必须依赖于整个复合主键。
  - 示例: 将 `orders` 表拆分为 `order_header` 和 `order_items` 以避免属性仅依赖于键的一部分。

- **3NF (第三范式)**
  - 满足 2NF 要求。
  - 无 **传递依赖**: 非键属性不能依赖于其他非键属性。
  - 示例: 将 `city_postal_code` 移动到 `cities` 表而不是与每个订单一起存储。

- **BCNF (Boyce-Codd 范式)**
  - 满足 3NF 要求。
  - 每个决定因素 (函数依赖的左侧) 必须是超键。

**提示**: 在大多数设计中以 3NF 为目标，在完整性和性能之间取得良好平衡。

## 关键 SQL 概念

- SQL 是一种用于与关系型数据库通信的结构化查询语言。
- **基本命令** → `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `CREATE TABLE`, `ALTER TABLE` 等。
- `连接` → 组合来自多个表的数据 (`INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL JOIN`)。

## 在 Bash 中运行 SQL 命令

你可以使用 PostgreSQL 的 `psql` 命令行客户端或其他数据库的类似工具直接从命令行运行 SQL 命令。

例如，在 PostgreSQL 中运行 SQL 文件:

```bash
psql -U username -d database_name -c "SELECT * FROM students;"
```

你也可以直接执行 MySQL 命令:

```bash
mysql -u username -p database_name -e "SELECT * FROM students;"
```

### 从文件运行 SQL

```bash
# PostgreSQL
psql -U username -d database_name -f script.sql

# MySQL
mysql -u username -p database_name < script.sql
```

### 在 Bash 脚本中嵌入 SQL

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 插入学生数据
psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age, major) VALUES ('Alice', 20, 'CS');"
```

### 在 SQL 中使用变量

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"
STUDENT_NAME="Bob"
AGE=21

psql -U "$DB_USER" -d "$DB_NAME" -c \
"INSERT INTO students (name, age) VALUES ('$STUDENT_NAME', $AGE);"
```

**提示**: 清理变量以避免 SQL 注入。

## 检索和在 Bash 中使用 SQL 查询结果

当你通过 `psql` 运行 SQL 查询时，你可以在 Bash 脚本中 **捕获** 和 **处理** 返回的值。

### 捕获单个值

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取学生总数
STUDENT_COUNT=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -c \
"SELECT COUNT(*) FROM students;")

echo "Total students: $STUDENT_COUNT"
```

输出 → 42

### 检索多列

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取前 3 名学生的姓名和年龄
RESULTS=$(psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, age FROM students LIMIT 3;")

echo "Top 3 students:"
echo "$RESULTS"
```

输出

```bash
Alice,20
Bob,21
Charlie,22
```

### 遍历查询结果

```bash
#!/bin/bash
DB_USER="school_admin"
DB_NAME="school"

# 获取学生姓名和专业
psql -U "$DB_USER" -d "$DB_NAME" -t -A -F"," -c \
"SELECT name, major FROM students;" | while IFS="," read -r name major
do
    echo "Student: $name | Major: $major"
done
```

输出形状

```bash
Student: Alice | Major: CS
Student: Bob   | Major: Math
Student: Carol | Major: Physics
```

## SQL 注入

这是一种 Web 安全漏洞，攻击者在输入字段中插入恶意 SQL 代码以操纵数据库。

这可能导致以下风险操作:

- 绕过身份验证。
- 窃取敏感数据。
- 修改或删除记录。

SQL 注入攻击示例:

```sql
SELECT * FROM users WHERE username = ' " " OR "1"="1" -- ' AND password = 'anything';
```

此查询将返回所有用户，因为条件 `OR "1"="1"` 总是为真，允许攻击者绕过登录检查。

### 防止 SQL 注入

1. **使用预处理语句**: 这些语句将 SQL 代码与数据分离，防止注入。以下是一个示例 (Node.js 与 pg):

    ```sql
    client.query('SELECT * FROM users WHERE username = $1 AND password = $2', [username, password]);
    ```

2. **输入验证**: 清理和验证所有用户输入，确保它们符合预期格式。

3. **最小权限**: 使用具有应用程序所需最小权限的数据库账户。

**注意**: 永远不要授予应用程序账户管理员权限。

## N+1 问题

当应用程序发出一个查询来检索项目列表 (N)，然后为每个项目发出一个附加查询来检索相关数据时，就会出现 N+1 问题，导致 N+1 个查询。

**为什么这很糟糕**

- 每个查询都会增加网络和处理开销。
- 多个小查询比一个优化的查询慢。

### N+1 模式的示例

```sql
-- 1: 获取订单列表
SELECT * FROM orders LIMIT 50;

-- N: 对于每个订单，获取客户
SELECT * FROM customers WHERE customer_id = ...;
```

**解决方案**: 使用 `JOINs` 或其他基于集合的操作。

```sql
SELECT 
  orders.order_id,
  orders.product,
  orders.quantity,
  customers.customer_id,
  customers.name,
  customers.email,
  customers.address
FROM orders
JOIN customers 
  ON orders.customer_id = customers.customer_id
WHERE orders.order_id IN (SELECT order_id FROM orders LIMIT 50);
```

始终寻找将相关数据组合到单个查询中的机会。

## 版本控制简介

- **定义**: 版本控制系统允许你跟踪和管理项目中的更改。软件中使用的版本控制系统的示例包括 Git、SVN 或 Mercurial。

## 基于云的版本控制提供商

- **基于云的版本控制提供商列表**: GitHub 和 GitLab 是流行的基于云的版本控制提供商示例，它们允许软件团队协作和管理存储库。

## 安装和设置 Git

- **安装 Git**: 要检查你的机器上是否已安装 Git，你可以在终端中运行以下命令:

```sh
git --version
```

如果你看到版本号，说明 Git 已安装。如果没有，则需要安装它。

对于 Linux 系统，Git 通常随大多数发行版预安装。如果你没有预安装 Git，你应该能够使用包管理器命令如 `sudo apt-get install git` 或 `sudo pacman -S git` 安装它。

对于 Mac 用户，你可以通过 Homebrew 使用 `brew install git` 安装 Git，或者你可以从 Git 网站下载可执行安装程序。

对于 Windows，你可以从 Git 网站下载可执行安装程序。或者，如果你已设置 Chocolatey，你可以在 PowerShell 中运行 `choco install git.install`。请注意，在 Windows 上，你可能还希望下载 Git Bash，以便拥有可用的类 Unix shell 环境。

要确保安装成功，请再次在终端中运行 `git --version` 命令。

- **Git 配置**: `git config` 用于设置负责 Git 在你的机器上如何操作的配置变量。要查看你当前的设置变量以及它们在系统中的存储位置，你可以运行以下命令:

```sh
git config --list --show-origin
```

如果你刚刚安装了 Git，现在你应该只看到系统级配置设置。

要设置你的用户名，你可以运行以下命令:

```sh
git config --global user.name "Jane Doe"
```

这里使用 `--global` 标志为系统上使用 Git 的所有项目设置用户名。如果你需要为特定项目覆盖用户名，则可以在该特定项目目录中运行不带 `--global` 标志的命令。

要设置用户电子邮件地址，你可以运行以下命令:

```sh
git config --global user.email janedoe@example.com
```

你可以设置的另一个配置是你希望 Git 使用的首选编辑器。以下是如何将你的首选编辑器设置为 Emacs 的示例:

```sh
git config --global core.editor emacs
```

如果你选择不设置首选编辑器，则 Git 将默认使用你的系统默认编辑器。

## 开源与闭源软件

- **定义**: "开源" 意味着人们可以看到你发布的代码，提出更改建议，报告问题，甚至运行修改版本。"闭源" 意味着只有你明确授权的人才能看到和与项目交互。

## GitHub

- **定义**: GitHub 是一个基于云的解决方案，提供将版本控制的项目存储在称为 "存储库" 的东西中，并启用与这些项目一起使用的协作功能。
- **GitHub CLI**: 此工具用于在不离开命令行的情况下执行 GitHub 特定任务。如果你没有安装它，你可以从 GitHub 文档中获取安装说明 - 但你应该可以在系统的包管理器中找到它。
- **GitHub Pages**: GitHub Pages 是部署静态站点或不需要后端服务器处理逻辑的应用程序的选项。也就是说，在用户浏览器中完全运行的客户端应用程序可以在此平台上完全部署。
- **GitHub Actions**: GitHub Actions 是一项功能，允许你直接在 GitHub 存储库中自动化工作流程，包括构建、测试和部署代码。

## 常用 Git 命令

- **`git init`**: 这将初始化一个空的 Git 存储库，以便 Git 可以开始跟踪此项目的更改。当你初始化一个空的 Git 存储库到项目中时，会添加一个新的 `.git` 隐藏目录。这个 `.git` 目录包含 Git 管理项目的重要信息。
- **`git status`**: 此命令用于显示工作目录的当前状态 - 你将在工作流程中经常使用此命令。
- **`git add`**: 此命令用于暂存你的更改。暂存区中的任何内容都将添加到下一次提交中。如果你想暂存所有未暂存的更改，则可以使用 `git add .`。句点 (`.`) 是当前目录的别名。
- **`git commit`**: 此命令用于提交你的更改。提交是在给定时间点的项目状态快照。如果你运行 `git commit`，它将打开你在 Git 配置中设置的首选编辑器。编辑器打开后，你可以提供更改的详细信息。你也可以选择使用 `git commit -m` 命令提供较短的消息，如下所示:

```sh
git commit -m "short message goes here"
```

- **`git log`**: 这将列出所有先前的提交，并提供有用的信息，如作者、提交日期、提交消息和提交哈希。提交哈希是一个长字符串，作为提交的唯一标识符。
- **`git remote add`**: 此命令用于设置与远程存储库的远程连接。
- **`git push`**: 此命令用于将你的更改推送到远程存储库。
- **`git pull`**: 此命令用于将远程存储库中的最新更改拉取到你的本地存储库中。
- **`git clone`**: 此命令将克隆一个存储库。这意味着你将拥有存储库的副本。此副本包括存储库历史记录、所有文件/文件夹和提交到你的本地设备。
- **`git remote -v`**: 此命令将显示与你的本地 Git 存储库关联的远程存储库列表。
- **`git branch`**: 此命令将列出你的所有本地分支。
- **`git fetch upstream`**: 此命令告诉 Git 去获取上游远程 (即原始存储库) 上的最新更改。
- **`git merge upstream/main`**: 此命令告诉 Git 将上游远程中的 `main` 分支的最新更改合并到你的当前分支中。
- **`git reset`**: 此命令允许你重置分支的当前状态。传递 `--hard` 标志告诉 Git 强制本地文件匹配分支状态。这确保你有一个干净的工作环境。
- **`git rebase`**: Git 中的变基是一种将一系列提交从一个分支移动或组合到另一个分支的方式。

## 使用分支

- **定义**: Git 中的分支是一个独立的工作空间，你可以在其中进行更改。`main` 分支通常代表现实世界应用程序中的主要或生产分支。开发团队将创建多个分支用于新功能和错误修复，然后将这些更改合并回 `main` 分支。
- **创建新分支**: 要创建新分支，你可以运行以下命令:

```sh
git branch feature
```

要检出该分支，你可以运行以下命令:

```sh
git checkout feature
```

大多数开发人员将使用创建和检出分支的简写命令，如下所示:

```sh
git checkout -b new-branch-name
```

较新的替代命令是 `git switch` 命令。以下是创建和切换到新分支的示例:

```sh
git switch -c new-branch-name
```

- **分支策略**: 你的 `main` 分支是默认分支，通常相当稳定。因此，最好从那里分支出来为错误修复、新功能或其他杂项工作创建新分支。
- **合并冲突**: 当 Git 尝试自动合并来自不同分支的更改但无法决定保留哪些更改时，就会发生这种情况。当同一文件的相同部分有冲突的更改时，通常会发生这种情况。

## Git 跟踪文件的五种状态

- **"未跟踪"**: 这意味着文件是存储库中的新文件，Git 之前没有"见过"它。
- **"已修改"**: 此文件在先前的提交中存在，并且有未提交的更改。
- **"已忽略"**: 你可能在 Git 中看不到忽略的文件，但你的 IDE 可能有指示器。忽略的文件从 Git 操作中排除，通常是因为它们包含在 `.gitignore` 文件中。
- **"已删除"**: 已删除的文件是未跟踪文件的反面 - 它是以前存在但已被删除的文件。
- **"已重命名"**: 已重命名的文件是内容未更改但文件名或位置已修改的文件。在某些情况下，即使文件有少量更改，也可能被认为是已重命名的。

## `.gitignore` 文件

- **定义**: `.gitignore` 文件是与 Git 操作相关的特殊类型的文件。名称表明此文件用于告诉 Git 忽略事物，这是常见用例。但它实际做的是告诉 Git 停止跟踪文件。

## 使用存储库

- **定义**: 存储库就像项目的容器 - 如果你正在处理一个应用程序，你会将该应用程序的文件保存在存储库中。存储库可以位于你的计算机上，也可以位于 GitHub 等服务上的远程存储库。
- **公共与私有存储库**: 公共存储库可以被任何人查看和下载。私有存储库只能由你和你明确授予访问权限的任何人访问。
- **在 GitHub 上创建存储库**: 要在 GitHub 上创建新存储库，你可以点击 `"New Repository"` 按钮并通过 GitHub UI 设置新存储库。
- **将本地存储库推送到 GitHub**: 如果你的计算机上有本地项目，你可以将该存储库推送到 GitHub。以下是该过程的逐步概述:

1. 在项目目录中初始化空的 git 存储库 (`git init`)。
2. 对项目进行更改。
3. 运行 `git status` 命令查看 git 跟踪的所有更改。
4. 暂存你的更改 (`git add`)。
5. 提交你的更改 (`git commit`)。
6. 设置远程连接 (`git remote add`)。
7. 将你的更改推送到 GitHub (`git push`)。

## 拉取请求

- **拉取请求**: 拉取请求是将更改从你的分支拉取到目标分支的请求。当你想要为项目贡献代码更改时，这是你使用的流程。这种方法允许项目维护者审查你的更改。他们可以留下评论、提出问题和建议调整。然后一旦审查过程完成，它可以被批准并合并到主分支。

## 为其他存储库做贡献

- **流程**: 有数千个项目你可以贡献。以下是为另一个存储库做贡献的基本流程:

1. 阅读贡献文档
2. 找到可处理的问题
3. 分叉存储库
4. 克隆你分叉的存储库副本
5. 创建新分支
6. 根据问题进行更改
7. 创建 PR (拉取请求)
8. 等待对该 PR 的审查

## 使用 SSH 和 GPG 密钥

- **GPG 密钥**: GPG，或 Gnu Privacy Guard 密钥，通常用于签署文件或提交。然后有人可以使用你的公共 GPG 密钥来验证文件签名来自你的密钥，并且文件内容未被修改或篡改。

要生成 GPG 密钥，你需要运行:

```sh
gpg --full-generate-key
```

- **SSH 密钥**: SSH，或安全 shell 密钥，通常用于验证到服务器的远程连接 - 通过 `ssh` 实用程序。你也可以使用 SSH 密钥签署提交。

对于 SSH 密钥，你将运行:

```sh
ssh-keygen -t ed25519 -C "your_email@example.com"
```

`ed25519` 是一种现代公钥签名算法。

- **使用 GPG 密钥签署提交**: 为了用你的 GPG 密钥签署提交，你需要上传你的公钥，而不是私钥，到你的 GitHub 账户。要列出你的公钥，你需要运行以下命令:

```sh
gpg --list-secret-keys --keyid-format=long
```

然后，要获取公钥，使用:

```sh
gpg --armor --export "<key id>"
```

然后，获取从列出密钥得到的短 ID 并运行此命令将其设置为你的 git 签名密钥:

```sh
git config --global user.signingkey <your_gpg_key_id>
```

然后，你可以将 `-S` 标志传递给你的 `git commit` 命令来签署特定提交 - 你需要提供你的密码短语。或者，如果你想自动签署每个提交，你可以将自动签名配置设置为 `true`:

```sh
git config --global commit.gpgsign true
```

- **使用 SSH 密钥签署提交**: 要使用 SSH 密钥签署提交，这是 GitHub 上的一项相对较新功能，你需要首先将密钥上传到你的 GitHub 账户。然后你需要设置 git 使用 SSH 的签名模式:

```sh
git config --global gpg.format ssh
```

然后，要设置签名密钥，你将传递文件路径而不是 ID:

```sh
git config --global user.signingkey <path_to_your_ssh_keys>
```

# --assignment--

复习 Bash、SQL 和其他关系型数据库主题和概念。