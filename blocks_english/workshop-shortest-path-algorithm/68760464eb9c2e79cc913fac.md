# --description--

在这一步中，你将添加一个循环，该循环将为图中的每个节点运行一次。这个循环将允许算法在多次传递中更新距离和路径。

创建一个运行`n`次的`for`循环。使用`_`作为循环变量，因为你不需要使用迭代值。

在循环内部，你需要通过创建两个变量来准备选择下一个要处理的节点：

- 一个用于保存当前迭代中找到的最小距离
- 另一个用于存储具有此最小距离的节点的索引

创建变量`min_distance`和`current`，并将它们分别设置为`INF`和`-1`。

# --hints--

在`shortest_path`函数内应该有一个`for`循环。

```js
({
    test: () => {
      assert(
        runPython(
          `_Node(_code).find_function("shortest_path").find_for_loops()[0]`
        )
      );
    }
});
```

你的`for`循环应该遍历`range(n)`。

```js
({
    test: () => {
      assert(
        runPython(
          `_Node(_code).find_function("shortest_path").find_for_loops()[0].find_for_iter().is_equivalent("range(n)")`
        )
      );
    }
});
```

你的for循环应该使用`_`作为迭代变量。

```js
({
    test: () => {
      assert(
        runPython(
          `_Node(_code).find_function("shortest_path").find_for_loops()[0].find_for_vars().is_equivalent("_")`
        )
      );
    }
});
```

你应该创建一个名为`min_distance`的变量，并在for循环内部将其设置为`INF`。

```js
({
    test: () => {
      assert(
        runPython(
          `_Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].has_stmt("min_distance = INF")`
        )
      );
    }
});
```

你应该创建一个名为`current`的变量，并在for循环内部将其设置为`-1`。

```js
({
    test: () => {
      assert(
        runPython(
          `_Node(_code).find_function("shortest_path").find_for_loops()[0].find_bodies()[0].has_stmt("current = -1")`
        )
      );
    }
});
```